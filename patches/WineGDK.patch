# Add changes from https://github.com/Weather-OS/WineGDK
# None of this should impact SC specifically
diff --git a/README.md b/README.md
index 1e3c748c510..082bf849ebd 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,19 @@
+# NOTES FOR PEOPLE TRYING TO RUN MINECRAFT'S GDK BUILD
+
+Microsoft Services have not been added yet. This is because `XUser` hasn't been implemented in `xgameruntime.dll` yet.
+
+As of [3414250](https://github.com/Weather-OS/WineGDK/commit/341425050f4f9b968b807dbd61942dabca8f6af1), Online functionality has been implemented. To get it working, resort to [GDK-Proton](https://github.com/Weather-OS/GDK-Proton)
+
+### NOTES ABOUT THIS PROJECT
+
+Unfortunately, since I don't have the right conditions to be able to   
+push my changes upstream, I've decided to declare every part of my contributions that isn't    
+derived from other parts of the wine project, CC0 (A.K.A "Public Domain") (i.e xgameruntime).
+**What this means**:  
+You're allowed to derive, redistribute and reimplement my code at will,  
+without any attributions.
+**THIS ONLY APPLIES TO THE CODE I HAVE WRITTEN, NOT THE REST OF WINE'S PROJECT!**
+
 ## INTRODUCTION
 
 Wine is a program which allows running Microsoft Windows programs
diff --git a/configure b/configure
index 97912b72526..0f5acc8be42 100755
--- a/configure
+++ b/configure
@@ -1634,6 +1634,7 @@ enable_xaudio2_6
 enable_xaudio2_7
 enable_xaudio2_8
 enable_xaudio2_9
+enable_xgameruntime
 enable_xinput1_1
 enable_xinput1_2
 enable_xinput1_3
@@ -9627,18 +9628,18 @@ then :
 fi
 if test "$enable_largefile,$enable_year2038" != no,no
 then :
-  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CPPFLAGS option for large files" >&5
-printf %s "checking for $CPPFLAGS option for large files... " >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable large file support" >&5
+printf %s "checking for $CC option to enable large file support... " >&6; }
 if test ${ac_cv_sys_largefile_opts+y}
 then :
   printf %s "(cached) " >&6
 else case e in #(
-  e) ac_save_CPPFLAGS=$CPPFLAGS
+  e) ac_save_CC="$CC"
   ac_opt_found=no
-  for ac_opt in "none needed" "-D_FILE_OFFSET_BITS=64" "-D_LARGE_FILES=1"; do
+  for ac_opt in "none needed" "-D_FILE_OFFSET_BITS=64" "-D_LARGE_FILES=1" "-n32"; do
     if test x"$ac_opt" != x"none needed"
 then :
-  CPPFLAGS="$ac_save_CPPFLAGS $ac_opt"
+  CC="$ac_save_CC $ac_opt"
 fi
     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -9667,12 +9668,12 @@ then :
   if test x"$ac_opt" = x"none needed"
 then :
   # GNU/Linux s390x and alpha need _FILE_OFFSET_BITS=64 for wide ino_t.
-	 CPPFLAGS="$CPPFLAGS -DFTYPE=ino_t"
+	 CC="$CC -DFTYPE=ino_t"
 	 if ac_fn_c_try_compile "$LINENO"
 then :
 
 else case e in #(
-  e) CPPFLAGS="$CPPFLAGS -D_FILE_OFFSET_BITS=64"
+  e) CC="$CC -D_FILE_OFFSET_BITS=64"
 	    if ac_fn_c_try_compile "$LINENO"
 then :
   ac_opt='-D_FILE_OFFSET_BITS=64'
@@ -9688,7 +9689,7 @@ fi
 rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
     test $ac_opt_found = no || break
   done
-  CPPFLAGS=$ac_save_CPPFLAGS
+  CC="$ac_save_CC"
 
   test $ac_opt_found = yes || ac_cv_sys_largefile_opts="support not detected" ;;
 esac
@@ -9712,14 +9713,16 @@ printf "%s\n" "#define _FILE_OFFSET_BITS 64" >>confdefs.h
 
 printf "%s\n" "#define _LARGE_FILES 1" >>confdefs.h
  ;; #(
+  "-n32") :
+    CC="$CC -n32" ;; #(
   *) :
     as_fn_error $? "internal error: bad value for \$ac_cv_sys_largefile_opts" "$LINENO" 5 ;;
 esac
 
 if test "$enable_year2038" != no
 then :
-  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CPPFLAGS option for timestamps after 2038" >&5
-printf %s "checking for $CPPFLAGS option for timestamps after 2038... " >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option for timestamps after 2038" >&5
+printf %s "checking for $CC option for timestamps after 2038... " >&6; }
 if test ${ac_cv_sys_year2038_opts+y}
 then :
   printf %s "(cached) " >&6
@@ -23342,6 +23345,8 @@ wine_fn_config_makefile dlls/xaudio2_7/tests enable_tests
 wine_fn_config_makefile dlls/xaudio2_8 enable_xaudio2_8
 wine_fn_config_makefile dlls/xaudio2_8/tests enable_tests
 wine_fn_config_makefile dlls/xaudio2_9 enable_xaudio2_9
+wine_fn_config_makefile dlls/xgameruntime enable_xgameruntime
+wine_fn_config_makefile dlls/xgameruntime/tests enable_tests
 wine_fn_config_makefile dlls/xinput1_1 enable_xinput1_1
 wine_fn_config_makefile dlls/xinput1_2 enable_xinput1_2
 wine_fn_config_makefile dlls/xinput1_3 enable_xinput1_3
diff --git a/configure.ac b/configure.ac
index 3b0520b5cb7..2827cd3e75c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3482,6 +3482,8 @@ WINE_CONFIG_MAKEFILE(dlls/xaudio2_7/tests)
 WINE_CONFIG_MAKEFILE(dlls/xaudio2_8)
 WINE_CONFIG_MAKEFILE(dlls/xaudio2_8/tests)
 WINE_CONFIG_MAKEFILE(dlls/xaudio2_9)
+WINE_CONFIG_MAKEFILE(dlls/xgameruntime)
+WINE_CONFIG_MAKEFILE(dlls/xgameruntime/tests)
 WINE_CONFIG_MAKEFILE(dlls/xinput1_1)
 WINE_CONFIG_MAKEFILE(dlls/xinput1_2)
 WINE_CONFIG_MAKEFILE(dlls/xinput1_3)
diff --git a/dlls/gameinput/Makefile.in b/dlls/gameinput/Makefile.in
index 7b239def911..0fd1ee425ef 100644
--- a/dlls/gameinput/Makefile.in
+++ b/dlls/gameinput/Makefile.in
@@ -1,7 +1,12 @@
 MODULE     = gameinput.dll
 EXTRADEFS  = -D_GAMEINPUT_
+IMPORTS    = combase user32 hid setupapi dinput8
+UNIX_CFLAGS  = $(SDL2_CFLAGS)
 
 EXTRADLLFLAGS = -Wb,--prefer-native
 
 SOURCES = \
-	gameinput.c
+	gameinput.c \
+	inputdevice.c \
+	inputreading.c \
+	mouinput.c 
diff --git a/dlls/gameinput/gameinput.c b/dlls/gameinput/gameinput.c
index c3923bf2efc..b8f8930beec 100644
--- a/dlls/gameinput/gameinput.c
+++ b/dlls/gameinput/gameinput.c
@@ -16,26 +16,715 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include <stddef.h>
-#include <stdarg.h>
+#include "initguid.h"
+#include "private.h"
 
-#define COBJMACROS
-#include "windef.h"
-#include "winbase.h"
+#include <time.h>
 
-#include "gameinput.h"
-#include "wine/debug.h"
+#include "inputdevice.h"
+#include "mouinput.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(ginput);
 
-HRESULT WINAPI GameInputCreate( v0_IGameInput **out )
+HINSTANCE game_input;
+
+struct game_input
+{
+    v0_IGameInput v0_IGameInput_iface;
+    v1_IGameInput v1_IGameInput_iface;
+    v2_IGameInput v2_IGameInput_iface;
+
+    LONG ref;
+};
+
+static inline struct game_input *impl_from_v0_IGameInput( v0_IGameInput *iface )
+{
+    return CONTAINING_RECORD( iface, struct game_input, v0_IGameInput_iface );
+}
+
+static HRESULT WINAPI game_input_QueryInterface( v0_IGameInput *iface, REFIID iid, void **out )
+{
+    struct game_input *impl = impl_from_v0_IGameInput( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_v0_IGameInput ))
+    {
+        *out = &impl->v0_IGameInput_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_v1_IGameInput ))
+    {
+        *out = &impl->v1_IGameInput_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_v2_IGameInput ))
+    {
+        *out = &impl->v2_IGameInput_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI game_input_AddRef( v0_IGameInput *iface )
 {
-    FIXME( "out %p, stub!\n", out );
+    struct game_input *impl = impl_from_v0_IGameInput( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI game_input_Release( v0_IGameInput *iface )
+{
+    struct game_input *impl = impl_from_v0_IGameInput( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static uint64_t WINAPI game_input_GetCurrentTimestamp( v0_IGameInput *iface )
+{
+    FIXME( "iface %p, stub GetCurrentTimestamp.\n", iface );
+    return (uint64_t)0;
+}
+
+static HRESULT WINAPI game_input_GetCurrentReading( v0_IGameInput *iface, GameInputKind kind,
+                                                   v0_IGameInputDevice *device, v0_IGameInputReading **reading )
+{
+    FIXME( "iface %p GetCurrentReading kind=%d device=%p reading_out=%p\n", iface, (int)kind, device, reading );
+    if (reading) *reading = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input_GetNextReading( v0_IGameInput *iface, v0_IGameInputReading *reference,
+                                                 GameInputKind kind, v0_IGameInputDevice *device,
+                                                 v0_IGameInputReading **reading )
+{
+    FIXME( "iface %p GetNextReading reference=%p kind=%d device=%p reading_out=%p\n", iface, reference, (int)kind, device, reading );
+    if (reading) *reading = NULL;
     return E_NOTIMPL;
 }
 
+static HRESULT WINAPI game_input_GetPreviousReading( v0_IGameInput *iface, v0_IGameInputReading *reference,
+                                                     GameInputKind kind, v0_IGameInputDevice *device,
+                                                     v0_IGameInputReading **reading )
+{
+    FIXME( "iface %p GetPreviousReading reference=%p kind=%d device=%p reading_out=%p\n", iface, reference, (int)kind, device, reading );
+    if (reading) *reading = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input_GetTemporalReading( v0_IGameInput *iface, uint64_t timestamp,
+                                                    v0_IGameInputDevice *device, v0_IGameInputReading **reading )
+{
+    FIXME( "iface %p GetTemporalReading timestamp=%llu device=%p reading_out=%p\n", iface, (unsigned long long)timestamp, device, reading );
+    if (reading) *reading = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input_RegisterReadingCallback( v0_IGameInput *iface, v0_IGameInputDevice *device,
+                                                          GameInputKind kind, float threshold, void *context,
+                                                          v0_GameInputReadingCallback callback, GameInputCallbackToken *token )
+{
+    FIXME( "iface %p RegisterReadingCallback device=%p kind=%d threshold=%f callback=%p token_out=%p\n",
+           iface, device, (int)kind, threshold, callback, token );
+    if (token) *token = (GameInputCallbackToken)0;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input_RegisterDeviceCallback( v0_IGameInput *iface, v0_IGameInputDevice *device,
+                                                         GameInputKind kind, GameInputDeviceStatus filter,
+                                                         GameInputEnumerationKind enum_kind, void *context,
+                                                         v0_GameInputDeviceCallback callback, GameInputCallbackToken *token )
+{
+    FIXME( "iface %p RegisterDeviceCallback device=%p kind=%d filter=%d enum_kind=%d callback=%p token_out=%p\n",
+           iface, device, (int)kind, (int)filter, (int)enum_kind, callback, token );
+    if (token) *token = (GameInputCallbackToken)0;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input_RegisterSystemButtonCallback( v0_IGameInput *iface, v0_IGameInputDevice *device,
+                                                               GameInputSystemButtons filter, void *context,
+                                                               v0_GameInputSystemButtonCallback callback, GameInputCallbackToken *token )
+{
+    FIXME( "iface %p RegisterSystemButtonCallback device=%p filter=%u callback=%p token_out=%p\n",
+           iface, device, (unsigned)filter, callback, token );
+    if (token) *token = (GameInputCallbackToken)0;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input_RegisterKeyboardLayoutCallback( v0_IGameInput *iface, v0_IGameInputDevice *device,
+                                                                 void *context, v0_GameInputKeyboardLayoutCallback callback,
+                                                                 GameInputCallbackToken *token )
+{
+    FIXME( "iface %p RegisterKeyboardLayoutCallback device=%p callback=%p token_out=%p\n",
+           iface, device, callback, token );
+    if (token) *token = (GameInputCallbackToken)0;
+    return E_NOTIMPL;
+}
+
+static void WINAPI game_input_StopCallback( v0_IGameInput *iface, GameInputCallbackToken token )
+{
+    FIXME( "iface %p StopCallback token=%llu\n", iface, (unsigned long long)token );
+    /* no-op stub */
+}
+
+static bool WINAPI game_input_UnregisterCallback( v0_IGameInput *iface, GameInputCallbackToken token, uint64_t timeout_ms )
+{
+    FIXME( "iface %p UnregisterCallback token=%llu timeout_ms=%llu\n", iface, (unsigned long long)token, (unsigned long long)timeout_ms );
+    return false;
+}
+
+static HRESULT WINAPI game_input_CreateDispatcher( v0_IGameInput *iface, IGameInputDispatcher **dispatcher )
+{
+    FIXME( "iface %p CreateDispatcher dispatcher_out=%p\n", iface, dispatcher );
+    if (dispatcher) *dispatcher = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input_CreateAggregateDevice( v0_IGameInput *iface, GameInputKind kind, v0_IGameInputDevice **device )
+{
+    FIXME( "iface %p CreateAggregateDevice kind=%d device_out=%p\n", iface, (int)kind, device );
+    if (device) *device = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input_FindDeviceFromId( v0_IGameInput *iface, const APP_LOCAL_DEVICE_ID *value, v0_IGameInputDevice **device )
+{
+    FIXME( "iface %p FindDeviceFromId value=%p device_out=%p\n", iface, value, device );
+    if (device) *device = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input_FindDeviceFromObject( v0_IGameInput *iface, IUnknown *value, v0_IGameInputDevice **device )
+{
+    FIXME( "iface %p FindDeviceFromObject unknown=%p device_out=%p\n", iface, value, device );
+    if (device) *device = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input_FindDeviceFromPlatformHandle( v0_IGameInput *iface, HANDLE value, v0_IGameInputDevice **device )
+{
+    FIXME( "iface %p FindDeviceFromPlatformHandle handle=%p device_out=%p\n", iface, value, device );
+    if (device) *device = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input_FindDeviceFromPlatformString( v0_IGameInput *iface, const WCHAR *value, v0_IGameInputDevice **device )
+{
+    FIXME( "iface %p FindDeviceFromPlatformString value=%p device_out=%p\n", iface, value, device );
+    if (device) *device = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input_EnableOemDeviceSupport( v0_IGameInput *iface, uint16_t vid, uint16_t pid,
+                                                         uint8_t iface_num, uint8_t collection )
+{
+    FIXME( "iface %p EnableOemDeviceSupport vid=0x%04x pid=0x%04x iface=%u collection=%u\n",
+           iface, (unsigned)vid, (unsigned)pid, (unsigned)iface_num, (unsigned)collection );
+    return E_NOTIMPL;
+}
+
+static void WINAPI game_input_SetFocusPolicy( v0_IGameInput *iface, GameInputFocusPolicy policy )
+{
+    FIXME( "iface %p SetFocusPolicy policy=%d\n", iface, (int)policy );
+    /* no-op stub */
+}
+
+static const struct v0_IGameInputVtbl game_input_vtbl =
+{
+    /* IUnknown methods */
+    game_input_QueryInterface,
+    game_input_AddRef,
+    game_input_Release,
+    /* v0_IGameInput methods */
+    game_input_GetCurrentTimestamp,
+    game_input_GetCurrentReading,
+    game_input_GetNextReading,
+    game_input_GetPreviousReading,
+    game_input_GetTemporalReading,
+    game_input_RegisterReadingCallback,
+    game_input_RegisterDeviceCallback,
+    game_input_RegisterSystemButtonCallback,
+    game_input_RegisterKeyboardLayoutCallback,
+    game_input_StopCallback,
+    game_input_UnregisterCallback,
+    game_input_CreateDispatcher,
+    game_input_CreateAggregateDevice,
+    game_input_FindDeviceFromId,
+    game_input_FindDeviceFromObject,
+    game_input_FindDeviceFromPlatformHandle,
+    game_input_FindDeviceFromPlatformString,
+    game_input_EnableOemDeviceSupport,
+    game_input_SetFocusPolicy
+};
+
+static inline struct game_input *impl_from_v1_IGameInput( v1_IGameInput *iface )
+{
+    return CONTAINING_RECORD( iface, struct game_input, v1_IGameInput_iface );
+}
+
+static HRESULT WINAPI game_input1_QueryInterface( v1_IGameInput *iface, REFIID iid, void **out )
+{
+    struct game_input *impl = impl_from_v1_IGameInput( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_v0_IGameInput ))
+    {
+        *out = &impl->v0_IGameInput_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_v1_IGameInput ))
+    {
+        *out = &impl->v1_IGameInput_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_v2_IGameInput ))
+    {
+        *out = &impl->v2_IGameInput_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI game_input1_AddRef( v1_IGameInput *iface )
+{
+    struct game_input *impl = impl_from_v1_IGameInput( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI game_input1_Release( v1_IGameInput *iface )
+{
+    struct game_input *impl = impl_from_v1_IGameInput( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+};
+
+static uint64_t WINAPI game_input1_GetCurrentTimestamp( v1_IGameInput *iface )
+{
+    TRACE( "iface %p, stub GetCurrentTimestamp.\n", iface );
+    return (uint64_t)0;
+}
+
+static HRESULT WINAPI game_input1_GetCurrentReading( v1_IGameInput *iface, GameInputKind kind,
+                                                   v1_IGameInputDevice *device, v1_IGameInputReading **reading )
+{
+    FIXME( "iface %p GetCurrentReading kind=%d device=%p reading_out=%p\n", iface, (int)kind, device, reading );
+    if (reading) *reading = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input1_GetNextReading( v1_IGameInput *iface, v1_IGameInputReading *reference,
+                                                 GameInputKind kind, v1_IGameInputDevice *device,
+                                                 v1_IGameInputReading **reading )
+{
+    FIXME( "iface %p GetNextReading reference=%p kind=%d device=%p reading_out=%p\n", iface, reference, (int)kind, device, reading );
+    if (reading) *reading = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input1_GetPreviousReading( v1_IGameInput *iface, v1_IGameInputReading *reference,
+                                                     GameInputKind kind, v1_IGameInputDevice *device,
+                                                     v1_IGameInputReading **reading )
+{
+    FIXME( "iface %p GetPreviousReading reference=%p kind=%d device=%p reading_out=%p\n", iface, reference, (int)kind, device, reading );
+    if (reading) *reading = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input1_RegisterReadingCallback( v1_IGameInput *iface, v1_IGameInputDevice *device,
+                                                          GameInputKind kind, void *context,
+                                                          v1_GameInputReadingCallback callback, GameInputCallbackToken *token )
+{
+    FIXME( "iface %p RegisterReadingCallback device=%p kind=%d callback=%p token_out=%p\n",
+           iface, device, (int)kind, callback, token );
+    if (token) *token = (GameInputCallbackToken)0;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input1_RegisterDeviceCallback( v1_IGameInput *iface, v1_IGameInputDevice *device,
+                                                         GameInputKind kind, GameInputDeviceStatus filter,
+                                                         GameInputEnumerationKind enum_kind, void *context,
+                                                         v1_GameInputDeviceCallback callback, GameInputCallbackToken *token )
+{
+    FIXME( "iface %p RegisterDeviceCallback device=%p kind=%d filter=%d enum_kind=%d callback=%p token_out=%p\n",
+           iface, device, (int)kind, (int)filter, (int)enum_kind, callback, token );
+    if (token) *token = (GameInputCallbackToken)0;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input1_RegisterSystemButtonCallback( v1_IGameInput *iface, v1_IGameInputDevice *device,
+                                                               GameInputSystemButtons filter, void *context,
+                                                               v1_GameInputSystemButtonCallback callback, GameInputCallbackToken *token )
+{
+    FIXME( "iface %p RegisterSystemButtonCallback device=%p filter=%u callback=%p token_out=%p\n",
+           iface, device, (unsigned)filter, callback, token );
+    if (token) *token = (GameInputCallbackToken)0;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input1_RegisterKeyboardLayoutCallback( v1_IGameInput *iface, v1_IGameInputDevice *device,
+                                                                 void *context, v1_GameInputKeyboardLayoutCallback callback,
+                                                                 GameInputCallbackToken *token )
+{
+    FIXME( "iface %p RegisterKeyboardLayoutCallback device=%p callback=%p token_out=%p\n",
+           iface, device, callback, token );
+    if (token) *token = (GameInputCallbackToken)0;
+    return E_NOTIMPL;
+}
+
+static void WINAPI game_input1_StopCallback( v1_IGameInput *iface, GameInputCallbackToken token )
+{
+    FIXME( "iface %p StopCallback token=%llu\n", iface, (unsigned long long)token );
+    /* no-op stub */
+}
+
+static bool WINAPI game_input1_UnregisterCallback( v1_IGameInput *iface, GameInputCallbackToken token )
+{
+    FIXME( "iface %p UnregisterCallback token=%llu\n", iface, (unsigned long long)token );
+    return false;
+}
+
+static HRESULT WINAPI game_input1_CreateDispatcher( v1_IGameInput *iface, IGameInputDispatcher **dispatcher )
+{
+    FIXME( "iface %p CreateDispatcher dispatcher_out=%p\n", iface, dispatcher );
+    if (dispatcher) *dispatcher = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input1_FindDeviceFromId( v1_IGameInput *iface, const APP_LOCAL_DEVICE_ID *value, v1_IGameInputDevice **device )
+{
+    FIXME( "iface %p FindDeviceFromId value=%p device_out=%p\n", iface, value, device );
+    if (device) *device = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input1_FindDeviceFromPlatformString( v1_IGameInput *iface, const WCHAR *value, v1_IGameInputDevice **device )
+{
+    FIXME( "iface %p FindDeviceFromPlatformString value=%p device_out=%p\n", iface, value, device );
+    if (device) *device = NULL;
+    return E_NOTIMPL;
+}
+
+static void WINAPI game_input1_SetFocusPolicy( v1_IGameInput *iface, GameInputFocusPolicy policy )
+{
+    FIXME( "iface %p SetFocusPolicy policy=%d\n", iface, (int)policy );
+    /* no-op stub */
+}
+
+static const struct v1_IGameInputVtbl game_input1_vtbl =
+{
+    /* IUnknown methods */
+    game_input1_QueryInterface,
+    game_input1_AddRef,
+    game_input1_Release,
+    /* v0_IGameInput methods */
+    game_input1_GetCurrentTimestamp,
+    game_input1_GetCurrentReading,
+    game_input1_GetNextReading,
+    game_input1_GetPreviousReading,
+    game_input1_RegisterReadingCallback,
+    game_input1_RegisterDeviceCallback,
+    game_input1_RegisterSystemButtonCallback,
+    game_input1_RegisterKeyboardLayoutCallback,
+    game_input1_StopCallback,
+    game_input1_UnregisterCallback,
+    game_input1_CreateDispatcher,
+    game_input1_FindDeviceFromId,
+    game_input1_FindDeviceFromPlatformString,
+    game_input1_SetFocusPolicy
+};
+
+static inline struct game_input *impl_from_v2_IGameInput( v2_IGameInput *iface )
+{
+    return CONTAINING_RECORD( iface, struct game_input, v2_IGameInput_iface );
+}
+
+static HRESULT WINAPI game_input2_QueryInterface( v2_IGameInput *iface, REFIID iid, void **out )
+{
+    struct game_input *impl = impl_from_v2_IGameInput( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_v0_IGameInput ))
+    {
+        *out = &impl->v0_IGameInput_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_v1_IGameInput ))
+    {
+        *out = &impl->v1_IGameInput_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_v2_IGameInput ))
+    {
+        *out = &impl->v2_IGameInput_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI game_input2_AddRef( v2_IGameInput *iface )
+{
+    struct game_input *impl = impl_from_v2_IGameInput( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI game_input2_Release( v2_IGameInput *iface )
+{
+    struct game_input *impl = impl_from_v2_IGameInput( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+};
+
+static uint64_t WINAPI game_input2_GetCurrentTimestamp( v2_IGameInput *iface )
+{
+    TRACE( "iface %p, stub GetCurrentTimestamp.\n", iface );
+    return (uint64_t)0;
+}
+
+static HRESULT WINAPI game_input2_GetCurrentReading( v2_IGameInput *iface, GameInputKind kind,
+                                                   v2_IGameInputDevice *device, v2_IGameInputReading **reading )
+{
+    HRESULT status = S_OK;
+
+    TRACE( "iface %p kind %d device %p reading %p\n", iface, kind, device, reading );
+
+    if ( kind == GameInputKindMouse )
+    {
+        // TODO: Using HID to read mouse values is finicky 
+        //status = mouse_input_device_ReadCurrentStateFromHID( device, GetTickCount64(), reading );
+        status = mouse_input_device_ReadCurrentStateFromDInput8( device, GetTickCount64(), reading );
+    } else
+    {
+        FIXME("requested controller device!\n");
+        return E_NOTIMPL;
+    }
+
+    return status;
+}
+
+static HRESULT WINAPI game_input2_GetNextReading( v2_IGameInput *iface, v2_IGameInputReading *reference,
+                                                 GameInputKind kind, v2_IGameInputDevice *device,
+                                                 v2_IGameInputReading **reading )
+{
+    FIXME( "iface %p GetNextReading reference=%p kind=%d device=%p reading_out=%p\n", iface, reference, (int)kind, device, reading );
+    if (reading) *reading = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input2_GetPreviousReading( v2_IGameInput *iface, v2_IGameInputReading *reference,
+                                                     GameInputKind kind, v2_IGameInputDevice *device,
+                                                     v2_IGameInputReading **reading )
+{
+    FIXME( "iface %p GetPreviousReading reference=%p kind=%d device=%p reading_out=%p\n", iface, reference, (int)kind, device, reading );
+    if (reading) *reading = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input2_RegisterReadingCallback( v2_IGameInput *iface, v2_IGameInputDevice *device,
+                                                          GameInputKind kind, void *context,
+                                                          v2_GameInputReadingCallback callback, GameInputCallbackToken *token )
+{
+    FIXME( "iface %p RegisterReadingCallback device=%p kind=%d callback=%p token_out=%p\n",
+           iface, device, (int)kind, callback, token );
+    if (token) *token = (GameInputCallbackToken)0;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input2_RegisterDeviceCallback( v2_IGameInput *iface, v2_IGameInputDevice *device,
+                                                         GameInputKind kind, GameInputDeviceStatus filter,
+                                                         GameInputEnumerationKind enum_kind, void *context,
+                                                         v2_GameInputDeviceCallback callback, GameInputCallbackToken *token )
+{
+    HRESULT status = S_OK;
+
+    FIXME( "iface %p, device %p, kind %#x, filter %#x, enum_kind %d, context %p, callback %p, token %p semi-stub!\n", iface, device, kind, filter, enum_kind, context, callback, token );
+    
+    status = RegisterDeviceCallback( device, kind, enum_kind, context, callback, token );
+
+    return status;
+}
+
+static HRESULT WINAPI game_input2_RegisterSystemButtonCallback( v2_IGameInput *iface, v2_IGameInputDevice *device,
+                                                               GameInputSystemButtons filter, void *context,
+                                                               v2_GameInputSystemButtonCallback callback, GameInputCallbackToken *token )
+{
+    FIXME( "iface %p RegisterSystemButtonCallback device=%p filter=%u callback=%p token_out=%p\n",
+           iface, device, (unsigned)filter, callback, token );
+    if (token) *token = (GameInputCallbackToken)0;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input2_RegisterKeyboardLayoutCallback( v2_IGameInput *iface, v2_IGameInputDevice *device,
+                                                                 void *context, v2_GameInputKeyboardLayoutCallback callback,
+                                                                 GameInputCallbackToken *token )
+{
+    FIXME( "iface %p RegisterKeyboardLayoutCallback device=%p callback=%p token_out=%p\n",
+           iface, device, callback, token );
+    if (token) *token = (GameInputCallbackToken)0;
+    return E_NOTIMPL;
+}
+
+static void WINAPI game_input2_StopCallback( v2_IGameInput *iface, GameInputCallbackToken token )
+{
+    FIXME( "iface %p StopCallback token=%llu\n", iface, (unsigned long long)token );
+    /* no-op stub */
+}
+
+static bool WINAPI game_input2_UnregisterCallback( v2_IGameInput *iface, GameInputCallbackToken token )
+{
+    FIXME( "iface %p UnregisterCallback token=%llu\n", iface, (unsigned long long)token );
+    return TRUE;
+}
+
+static HRESULT WINAPI game_input2_CreateDispatcher( v2_IGameInput *iface, IGameInputDispatcher **dispatcher )
+{
+    FIXME( "iface %p CreateDispatcher dispatcher_out=%p\n", iface, dispatcher );
+    if (dispatcher) *dispatcher = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input2_FindDeviceFromId( v2_IGameInput *iface, const APP_LOCAL_DEVICE_ID *value, v2_IGameInputDevice **device )
+{
+    FIXME( "iface %p FindDeviceFromId value=%p device_out=%p\n", iface, value, device );
+    if (device) *device = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_input2_FindDeviceFromPlatformString( v2_IGameInput *iface, const WCHAR *value, v2_IGameInputDevice **device )
+{
+    FIXME( "iface %p FindDeviceFromPlatformString value=%p device_out=%p\n", iface, value, device );
+    if (device) *device = NULL;
+    return E_NOTIMPL;
+}
+
+static void WINAPI game_input2_SetFocusPolicy( v2_IGameInput *iface, GameInputFocusPolicy policy )
+{
+    FIXME( "iface %p SetFocusPolicy policy=%d\n", iface, (int)policy );
+    /* no-op stub */
+}
+
+static const struct v2_IGameInputVtbl game_input2_vtbl =
+{
+    /* IUnknown methods */
+    game_input2_QueryInterface,
+    game_input2_AddRef,
+    game_input2_Release,
+    /* v0_IGameInput methods */
+    game_input2_GetCurrentTimestamp,
+    game_input2_GetCurrentReading,
+    game_input2_GetNextReading,
+    game_input2_GetPreviousReading,
+    game_input2_RegisterReadingCallback,
+    game_input2_RegisterDeviceCallback,
+    game_input2_RegisterSystemButtonCallback,
+    game_input2_RegisterKeyboardLayoutCallback,
+    game_input2_StopCallback,
+    game_input2_UnregisterCallback,
+    game_input2_CreateDispatcher,
+    game_input2_FindDeviceFromId,
+    game_input2_FindDeviceFromPlatformString,
+    game_input2_SetFocusPolicy
+};
+
+static BOOL WINAPI start_monitor_thread( INIT_ONCE *once, void *param, void **context )
+{
+    HANDLE thread, start_event;
+
+    TRACE( "once %p, param %p, context %p.\n", once, param, context );
+
+    start_event = CreateEventA( NULL, FALSE, FALSE, NULL );
+    if (!start_event) ERR( "Failed to create start event, error %lu\n", GetLastError() );
+
+    thread = CreateThread( NULL, 0, DeviceMonitorThread, start_event, 0, NULL );
+    if (!thread) ERR( "Failed to create monitor thread, error %lu\n", GetLastError() );
+    else
+    {
+        WaitForSingleObject( start_event, INFINITE );
+        CloseHandle( thread );
+    }
+
+    CloseHandle( start_event );
+    return !!thread;
+}
+
+HRESULT WINAPI GameInputCreate( v0_IGameInput **out )
+{
+    struct game_input *input = NULL;
+
+    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+
+    TRACE( "out %p\n", out );
+
+    InitOnceExecuteOnce( &init_once, start_monitor_thread, NULL, NULL );
+
+    if (!(input = calloc( 1, sizeof(*input) ))) return E_OUTOFMEMORY;
+
+    input->v0_IGameInput_iface.lpVtbl = &game_input_vtbl;
+    input->v1_IGameInput_iface.lpVtbl = &game_input1_vtbl;
+    input->v2_IGameInput_iface.lpVtbl = &game_input2_vtbl;
+    input->ref = 1;
+
+    *out = &input->v0_IGameInput_iface;
+
+    return S_OK;
+}
+
 HRESULT WINAPI DllGetClassObject( REFCLSID clsid, REFIID riid, void **out )
 {
     FIXME( "clsid %s, riid %s, out %p stub!\n", debugstr_guid(clsid), debugstr_guid(riid), out );
     return CLASS_E_CLASSNOTAVAILABLE;
 }
+
+BOOL WINAPI DllMain( HINSTANCE instance, DWORD reason, void *reserved )
+{
+    TRACE( "instance %p, reason %lu, reserved %p.\n", instance, reason, reserved );
+
+    switch (reason)
+    {
+        case DLL_PROCESS_ATTACH:
+            DisableThreadLibraryCalls( instance );
+            game_input = instance;
+            break;
+    }
+    return TRUE;
+}
\ No newline at end of file
diff --git a/dlls/gameinput/inputdevice.c b/dlls/gameinput/inputdevice.c
new file mode 100644
index 00000000000..656bf65b49b
--- /dev/null
+++ b/dlls/gameinput/inputdevice.c
@@ -0,0 +1,1008 @@
+/*
+ * Game Input Library
+ *  -> Game Input Devices
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <time.h>
+
+#include "mouinput.h"
+#include "inputdevice.h"
+#include "initguid.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(ginput);
+
+extern HINSTANCE game_input;
+
+static CRITICAL_SECTION provider_cs;
+static CRITICAL_SECTION_DEBUG provider_cs_debug =
+{
+    0, 0, &provider_cs,
+    { &provider_cs_debug.ProcessLocksList, &provider_cs_debug.ProcessLocksList },
+      0, 0, { (ULONG_PTR)(__FILE__ ": provider_cs") }
+};
+static CRITICAL_SECTION provider_cs = { &provider_cs_debug, -1, 0, 0, 0, 0 };
+
+DEFINE_GUID( device_path_guid, 0x00000000, 0x0000, 0x0000, 0x8d, 0x4a, 0x23, 0x90, 0x3f, 0xb6, 0xbd, 0xf8 );
+
+static const DIOBJECTDATAFORMAT data_format_objs[] =
+{
+    {NULL,DIJOFS_X,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_Y,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_Z,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_RX,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_RY,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_RZ,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_SLIDER(0),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_SLIDER(1),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_POV(0),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_POV(1),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_POV(2),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_POV(3),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(0),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(1),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(2),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(3),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(4),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(5),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(6),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(7),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(8),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(9),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(10),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(11),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(12),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(13),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(14),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(15),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(16),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(17),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(18),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(19),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(20),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(21),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(22),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(23),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(24),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(25),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(26),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(27),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(28),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(29),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(30),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(31),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(32),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(33),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(34),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(35),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(36),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(37),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(38),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(39),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(40),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(41),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(42),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(43),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(44),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(45),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(46),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(47),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(48),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(49),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(50),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(51),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(52),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(53),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(54),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(55),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(56),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(57),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(58),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(59),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(60),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(61),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(62),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(63),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(64),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(65),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(66),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(67),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(68),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(69),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(70),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(71),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(72),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(73),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(74),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(75),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(76),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(77),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(78),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(79),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(80),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(81),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(82),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(83),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(84),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(85),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(86),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(87),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(88),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(89),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(90),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(91),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(92),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(93),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(94),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(95),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(96),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(97),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(98),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(99),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(100),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(101),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(102),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(103),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(104),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(105),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(106),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(107),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(108),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(109),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(110),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(111),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(112),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(113),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(114),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(115),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(116),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(117),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(118),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(119),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(120),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(121),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(122),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(123),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(124),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(125),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(126),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(127),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+};
+
+static const DIDATAFORMAT data_format =
+{
+    sizeof(DIDATAFORMAT),
+    sizeof(DIOBJECTDATAFORMAT),
+    DIDF_ABSAXIS,
+    sizeof(DIJOYSTATE2),
+    ARRAY_SIZE(data_format_objs),
+    (LPDIOBJECTDATAFORMAT)data_format_objs
+};
+
+static struct list device_list = LIST_INIT( device_list );
+static struct list callback_list = LIST_INIT( callback_list );
+static UINT64 nextId = 0;
+
+static inline struct game_input_device *impl_from_IGameInputDevice( v2_IGameInputDevice *iface )
+{
+    return CONTAINING_RECORD( iface, struct game_input_device, v2_IGameInputDevice_iface );
+}
+
+static HRESULT WINAPI game_input_device_QueryInterface( v2_IGameInputDevice *iface, REFIID iid, void **out )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_v2_IGameInputDevice ))
+    {
+        *out = &impl->v2_IGameInputDevice_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI game_input_device_AddRef( v2_IGameInputDevice *iface )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI game_input_device_Release( v2_IGameInputDevice *iface )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+};
+
+static HRESULT WINAPI game_input_device_GetDeviceInfo( v2_IGameInputDevice *iface, const v2_GameInputDeviceInfo **info )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+    TRACE( "iface %p, info %p.\n", iface, info );
+    *info = &impl->deviceInfo;
+    return S_OK;
+}
+
+static HRESULT WINAPI game_input_device_GetHapticInfo( v2_IGameInputDevice *iface, GameInputHapticInfo *info )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+
+    TRACE( "iface %p, info %p.\n", iface, info );
+
+    if ( !(impl->deviceStatus | GameInputDeviceHapticInfoReady) )
+        return GAMEINPUT_E_HAPTIC_INFO_NOT_FOUND;
+
+    *info = impl->hapticInfo;
+
+    return S_OK;
+}
+
+static GameInputDeviceStatus WINAPI game_input_device_GetDeviceStatus( v2_IGameInputDevice *iface )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+    TRACE( "iface %p.\n", iface );
+    return impl->deviceStatus;
+}
+
+static HRESULT WINAPI game_input_device_CreateForceFeedbackEffect( v2_IGameInputDevice *iface, uint32_t motor, const GameInputForceFeedbackParams *params, v2_IGameInputForceFeedbackEffect **effect )
+{
+    FIXME( "iface %p, motor %d, params %p, effect %p stub!\n", iface, motor, params, effect );
+    return E_NOTIMPL;
+}
+
+static bool WINAPI game_input_device_IsForceFeedbackMotorPoweredOn( v2_IGameInputDevice *iface, uint32_t motor )
+{
+    FIXME( "iface %p, motor %d stub!\n", iface, motor );
+    return FALSE;
+}
+
+static VOID WINAPI game_input_device_SetForceFeedbackMotorGain( v2_IGameInputDevice *iface, uint32_t motor, float gain )
+{
+    FIXME( "iface %p, motor %d, gain %f stub!\n", iface, motor, gain );
+    return;
+}
+
+static VOID WINAPI game_input_device_SetRumbleState( v2_IGameInputDevice *iface, const GameInputRumbleParams *params )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+    TRACE( "iface %p, params %p.\n", iface, params );
+    if ( params )
+        impl->rumbleState = *params;
+    return;
+}
+
+static HRESULT WINAPI game_input_device_DirectInputEscape( v2_IGameInputDevice *iface, uint32_t command, const void *input, uint32_t in_size, void *output, uint32_t out_size, uint32_t *size )
+{    
+    HRESULT hr;
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+    
+    DIEFFESCAPE dinputEscape = { .dwSize = sizeof(DIEFFESCAPE), .dwCommand = (DWORD)command, .lpvInBuffer = (const PVOID)input, 
+                                 .cbInBuffer = (DWORD)in_size, .lpvOutBuffer = output, .cbOutBuffer = (DWORD)out_size };
+
+    TRACE( "iface %p, command %d, input %p, in_size %d, output %p, out_size %d, size %p.\n", iface, command, input, in_size, output, out_size, size );
+
+    if ( !impl->pDevice )
+        return E_HANDLE;
+    if ( size ) 
+        *size = 0;
+    
+    hr = impl->pDevice->lpVtbl->Escape( impl->pDevice, &dinputEscape );
+
+    if ( SUCCEEDED( hr ) )
+        if ( size )
+            *size = dinputEscape.cbOutBuffer;
+
+    return hr;
+}
+
+HRESULT game_input_device_AcquireDInputDevice( IN v2_IGameInputDevice *iface, OUT LPDIRECTINPUTDEVICE8W *device )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+    TRACE( "iface %p, device %p.\n", iface, device );
+    if ( device )
+        *device = impl->pDevice;
+    return S_OK;
+}
+
+HRESULT game_input_device_SetDInputDevice( IN v2_IGameInputDevice *iface, IN LPDIRECTINPUTDEVICE8W device )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+    TRACE( "iface %p, device %p.\n", iface, device );
+    impl->pDevice = device;
+    return S_OK;
+}
+
+HRESULT game_input_device_AddGameHID( IN v2_IGameInputDevice *iface, IN LPWSTR devicePath )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+    
+    HRESULT status = S_OK;
+
+    CHAR nameBuf[512];
+    DWORD request;
+    DWORD interfaceDetailSizeNeeded = 0;
+    HANDLE deviceFileHandle = NULL;
+    HIDP_CAPS caps;
+    DEVPROPTYPE propType;
+    SP_DEVINFO_DATA deviceData = { .cbSize = sizeof(SP_DEVINFO_DATA) };
+    PHIDP_PREPARSED_DATA preparsedData = NULL;
+    SP_DEVICE_INTERFACE_DATA interfaceData = { .cbSize = sizeof(SP_DEVICE_INTERFACE_DATA) };
+    PSP_DEVICE_INTERFACE_DETAIL_DATA_A interfaceDetail = NULL;
+
+    TRACE("iface %p, devicePath %s\n", iface, debugstr_w(devicePath));
+
+    impl->pnpPath = (LPWSTR)malloc( (wcslen(devicePath) + 1) * sizeof(WCHAR));
+    wcscpy( impl->pnpPath, devicePath );
+
+    // Check if we can write to this device
+    deviceFileHandle = CreateFileW( devicePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL );
+    if ( deviceFileHandle != INVALID_HANDLE_VALUE )
+    {
+        impl->deviceStatus |= GameInputDeviceConnected;
+        impl->deviceStatus |= GameInputDeviceInputEnabled;
+        impl->deviceStatus |= GameInputDeviceOutputEnabled;
+        CloseHandle( deviceFileHandle );
+    }
+
+    deviceFileHandle = CreateFileW( devicePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL );
+    if ( deviceFileHandle == INVALID_HANDLE_VALUE )
+    {
+        // If we can't read from the device, we probably can't access it.
+        status = HRESULT_FROM_WIN32( GetLastError() );
+        goto _CLEANUP;
+    }
+
+    if ( wcsstr( devicePath, L"BTHENUM" ) != NULL )
+        impl->deviceStatus |= GameInputDeviceWireless;
+
+    impl->deviceStatus |= GameInputDeviceConnected;
+    impl->deviceStatus |= GameInputDeviceInputEnabled;
+
+    if ( HidD_GetPreparsedData( deviceFileHandle, &preparsedData ) )
+    {
+        CloseHandle( deviceFileHandle );
+        impl->preparsed = preparsedData;
+        if ( HidP_GetCaps( preparsedData, &caps ) == HIDP_STATUS_SUCCESS )
+        {
+            impl->deviceInfo.usage.id = caps.Usage;
+            impl->deviceInfo.usage.page = caps.UsagePage;
+            switch ( caps.UsagePage )
+            {
+                // These are the ones we support for now
+                case HID_USAGE_PAGE_GENERIC:
+                {
+                    switch ( caps.Usage )
+                    {
+                        case HID_USAGE_GENERIC_MOUSE:
+                        case HID_USAGE_GENERIC_KEYBOARD:
+                        {
+                            impl->deviceInfo.supportedInput = GameInputKindKeyboard | GameInputKindMouse;
+                            status = mouse_input_device_InitDevice( iface );
+                            TRACE("mouse_input_device_InitDevice returned %#lx\n", status);
+                            if ( FAILED( status ) ) goto _CLEANUP;
+                            break;
+                        }
+
+                        case HID_USAGE_GENERIC_GAMEPAD:
+                        {
+                            impl->deviceInfo.supportedInput = GameInputKindGamepad;
+                            break;
+                        }
+
+                        case HID_USAGE_GENERIC_JOYSTICK:
+                        {
+                            impl->deviceInfo.supportedInput = GameInputKindArcadeStick;
+                            break;
+                        }
+
+                        default:
+                            FIXME( "Unsupported usage %#x\n", caps.Usage ) ;
+                            status = E_NOTIMPL;
+                            goto _CLEANUP;
+                    }
+                    break;
+                }
+                
+                default:
+                    FIXME( "Unsupported usage page %#x\n", caps.UsagePage ) ;
+                    status = E_NOTIMPL;
+                    goto _CLEANUP;
+            }
+        } else
+        {
+            status = HRESULT_FROM_WIN32( GetLastError() );
+            goto _CLEANUP;
+        }
+    } else
+    {
+        status = HRESULT_FROM_WIN32( GetLastError() );
+        goto _CLEANUP;
+    }
+
+    impl->hidInfo = SetupDiCreateDeviceInfoList( NULL, NULL );
+    if ( impl->hidInfo == INVALID_HANDLE_VALUE ) { status = HRESULT_FROM_WIN32( GetLastError() ); goto _CLEANUP; }
+
+    if ( !SetupDiOpenDeviceInterfaceW( impl->hidInfo, devicePath, 0, &interfaceData ) )
+    { status = HRESULT_FROM_WIN32( GetLastError() ); goto _CLEANUP; }
+
+    SetupDiGetDeviceInterfaceDetailW( impl->hidInfo, &interfaceData, NULL, 0, &interfaceDetailSizeNeeded, NULL );
+    if ( interfaceDetailSizeNeeded == 0 ) { status = HRESULT_FROM_WIN32( GetLastError() ); goto _CLEANUP; }
+
+    interfaceDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA_A)malloc( interfaceDetailSizeNeeded );
+    if ( !interfaceDetail ) { status = E_OUTOFMEMORY; goto _CLEANUP; }
+    interfaceDetail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);
+
+    if ( !SetupDiGetDeviceInterfaceDetailA( impl->hidInfo, &interfaceData, interfaceDetail, interfaceDetailSizeNeeded, NULL, &deviceData ) )
+    { status = HRESULT_FROM_WIN32( GetLastError() ); goto _CLEANUP; }
+
+    impl->hidData = deviceData;
+
+    {
+        // GameInputDeviceInfo::vendorId, GameInputDeviceInfo::productId & GameInputDeviceInfo::revisionNumber
+        CHAR *hardwareId = NULL;
+        DWORD hardwareIdSizeNeeded = 0;
+
+        SetupDiGetDeviceRegistryPropertyA( impl->hidInfo, &impl->hidData, SPDRP_HARDWAREID, NULL, NULL, 0, &hardwareIdSizeNeeded );
+        hardwareId = (CHAR *)malloc( hardwareIdSizeNeeded );
+        if ( !hardwareId )
+        {
+            status = E_OUTOFMEMORY;
+            goto _CLEANUP;
+        }
+
+        if ( SetupDiGetDeviceRegistryPropertyA( impl->hidInfo, &impl->hidData, SPDRP_HARDWAREID, NULL, 
+            (PBYTE)hardwareId, hardwareIdSizeNeeded, NULL ) )
+        {
+            sscanf_s( hardwareId, "HID\\VID_%4hx&PID_%4hx", 
+                &impl->deviceInfo.vendorId, &impl->deviceInfo.productId );
+            FIXME( "hardwareId is %s\n", debugstr_a(hardwareId) );
+            FIXME( "vendorId is %4hx, productId is %4hx\n", impl->deviceInfo.vendorId, impl->deviceInfo.productId );
+        }
+        free( hardwareId );
+    }
+
+    {
+        // GameInputDeviceInfo::deviceFamily
+        impl->deviceInfo.deviceFamily = GameInputFamilyHid;
+    }
+        
+    {
+        // GameInputDeviceInfo::containerId
+        SetupDiGetDevicePropertyW( impl->hidInfo, &impl->hidData, &DEVPKEY_Device_ContainerId,
+              &propType, (PBYTE)&impl->deviceInfo.containerId, sizeof(GUID), &request, 0 );
+    }
+
+    {
+        // GameInputDeviceInfo::displayName
+        if ( SetupDiGetDevicePropertyW( impl->hidInfo, &impl->hidData, &DEVPKEY_Device_FriendlyName, 
+            &propType, (PBYTE)nameBuf, sizeof(nameBuf), &request, 0 ) ) 
+        {
+            impl->deviceInfo.displayName = nameBuf;
+        }
+    }
+
+    impl->previousDeviceStatus = impl->deviceStatus;
+
+_CLEANUP:
+    if ( FAILED( status ) )
+    {
+        free( impl->pnpPath );
+        SetupDiDeleteDeviceInterfaceData( impl->hidInfo, &interfaceData );
+        SetupDiDestroyDeviceInfoList( impl->hidInfo );
+    }
+    if ( interfaceDetail )
+        free( interfaceDetail );
+    if ( deviceFileHandle && deviceFileHandle != INVALID_HANDLE_VALUE )
+        CloseHandle( deviceFileHandle );
+    return status;
+}
+
+HRESULT game_input_device_OpenDevice( IN v2_IGameInputDevice *iface )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+
+    NTSTATUS status;
+    HIDP_CAPS caps;
+
+    TRACE( "iface %p\n", iface );
+
+    impl->deviceHandle = CreateFileW( impl->pnpPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL );
+    if ( impl->deviceHandle == INVALID_HANDLE_VALUE )
+        return HRESULT_FROM_WIN32( GetLastError() );
+
+    status = HidP_GetCaps( impl->preparsed, &caps );
+    if ( status != HIDP_STATUS_SUCCESS ) return HRESULT_FROM_NT( status );
+
+    impl->readBuffer = VirtualAlloc( NULL, caps.InputReportByteLength,
+                                MEM_COMMIT | MEM_RESERVE,
+                                PAGE_READWRITE );
+    impl->readBufferLen = caps.InputReportByteLength;
+
+    return S_OK;
+}
+
+HRESULT game_input_device_CloseDevice( IN v2_IGameInputDevice *iface )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+
+    TRACE( "iface %p\n", iface );
+
+    if ( !CloseHandle( impl->deviceHandle ) )
+        return HRESULT_FROM_WIN32( GetLastError() );
+
+    VirtualFree( impl->readBuffer, impl->readBufferLen, MEM_DECOMMIT );
+
+    return S_OK;
+}
+
+HRESULT game_input_device_QueryGameHIDButtonCaps( IN v2_IGameInputDevice *iface, OUT HIDP_BUTTON_CAPS **btnCaps, OUT USHORT *nBtnCaps )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+
+    HIDP_BUTTON_CAPS *buttons;
+    HIDP_CAPS caps;
+    NTSTATUS status;
+    USHORT got;
+
+    TRACE( "iface %p, btnCaps %p, nBtnCaps %p.\n", iface, btnCaps, nBtnCaps );
+
+    if ( !btnCaps || !nBtnCaps )
+        return E_POINTER;
+
+    status = HidP_GetCaps( impl->preparsed, &caps );
+    if ( status != HIDP_STATUS_SUCCESS ) return HRESULT_FROM_NT( status );
+    
+    got = caps.NumberInputButtonCaps;
+    buttons = (HIDP_BUTTON_CAPS *)malloc( got * sizeof(HIDP_BUTTON_CAPS) );
+
+    status = HidP_GetButtonCaps( HidP_Input, buttons, &got, impl->preparsed );
+    if ( status != HIDP_STATUS_SUCCESS ) return HRESULT_FROM_NT( status );
+
+    *btnCaps = buttons;
+    *nBtnCaps = got;
+
+    return S_OK;
+}
+
+HRESULT game_input_device_QueryGameHIDValueCaps( IN v2_IGameInputDevice *iface, OUT HIDP_VALUE_CAPS **valueCaps, OUT USHORT *nValueCaps )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+
+    HIDP_VALUE_CAPS *values;
+    HIDP_CAPS caps;
+    NTSTATUS status;
+    USHORT got;
+
+    TRACE( "iface %p, valueCaps %p, nValueCaps %p.\n", iface, valueCaps, nValueCaps );
+
+    if ( !valueCaps || !nValueCaps )
+        return E_POINTER;
+
+    status = HidP_GetCaps( impl->preparsed, &caps );
+    if ( status != HIDP_STATUS_SUCCESS ) return HRESULT_FROM_NT( status );
+    
+    got = caps.NumberInputValueCaps;
+    values = (HIDP_VALUE_CAPS *)malloc( got * sizeof(HIDP_VALUE_CAPS) );
+
+    status = HidP_GetValueCaps( HidP_Input, values, &got, impl->preparsed );
+    if ( status != HIDP_STATUS_SUCCESS ) return HRESULT_FROM_NT( status );
+
+    *valueCaps = values;
+    *nValueCaps = got;
+
+    return S_OK;
+}
+
+HRESULT game_input_device_PollHIDDevice( IN v2_IGameInputDevice *iface )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+
+    HIDP_CAPS caps;
+    NTSTATUS status;
+    DWORD bytesRead;
+    DWORD lastError;
+
+    TRACE( "iface %p.\n", iface );
+
+    status = HidP_GetCaps( impl->preparsed, &caps );
+    if ( status != HIDP_STATUS_SUCCESS ) return HRESULT_FROM_NT( status );
+
+    if ( !impl->deviceHandle || impl->deviceHandle == INVALID_HANDLE_VALUE )
+    {
+        ERR( "Device %s is not opened yet!\n", debugstr_w(impl->pnpPath) );
+        return E_HANDLE;
+    }
+
+    EnterCriticalSection( &impl->readLock );
+
+    if ( !impl->readPending )
+    {
+        ZeroMemory( &impl->readOv, sizeof(impl->readOv) );
+
+        if ( !ReadFile( impl->deviceHandle, impl->readBuffer, impl->readBufferLen, &bytesRead, &impl->readOv ) )
+        {
+            lastError = GetLastError();
+            if ( lastError == ERROR_IO_PENDING )
+            {
+                // Pending read, don't block and forward IO.
+                impl->readPending = TRUE;
+                LeaveCriticalSection( &impl->readLock );
+                return E_PENDING;
+            }
+
+            LeaveCriticalSection( &impl->readLock );
+            if ( lastError == ERROR_DEVICE_NOT_CONNECTED || lastError == ERROR_OPERATION_ABORTED ) {
+                ERR( "device %s is lost!\n", debugstr_w( impl->pnpPath ) );
+                return E_PENDING;
+            }
+            ERR( "last error was %lu\n", lastError );
+            return HRESULT_FROM_WIN32( lastError );
+        }
+
+        impl->readPending = FALSE;
+    }
+    else
+    {
+        // IO read is in progress. just check if it's completed or not.
+        if ( !GetOverlappedResult( impl->deviceHandle, &impl->readOv, &bytesRead, FALSE ) )
+        {
+            lastError = GetLastError();
+            if ( lastError == ERROR_IO_INCOMPLETE || lastError == ERROR_IO_PENDING )
+            {
+                LeaveCriticalSection(&impl->readLock);
+                return E_PENDING;
+            }
+
+            LeaveCriticalSection(&impl->readLock);
+            if ( lastError == ERROR_DEVICE_NOT_CONNECTED || lastError == ERROR_OPERATION_ABORTED ) {
+                ERR( "device %s is lost!\n", debugstr_w( impl->pnpPath ) );
+                return E_PENDING;
+            }
+            return HRESULT_FROM_WIN32( lastError );
+        }
+
+        impl->readPending = FALSE;
+    }
+
+    ZeroMemory( &impl->readOv, sizeof(impl->readOv) );
+
+    if ( !ReadFile( impl->deviceHandle, impl->readBuffer, impl->readBufferLen, &bytesRead, &impl->readOv ) )
+    {
+        lastError = GetLastError();
+        if ( lastError == ERROR_IO_PENDING )
+        {
+            impl->readPending = TRUE;
+        }
+        else
+        {
+            TRACE( "ReadFile re-issue failed with error %lu.\n", lastError );
+        }
+    }
+    else
+    {
+        impl->readPending = FALSE;
+    }
+    
+    LeaveCriticalSection(&impl->readLock);
+    return S_OK;
+}
+
+HRESULT game_input_device_CurrentButtons( IN v2_IGameInputDevice *iface, OUT USAGE usageList[128], OUT ULONG *usageLength )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+
+    HIDP_CAPS caps;
+    NTSTATUS status;
+
+    TRACE( "iface %p.\n", iface );
+
+    status = HidP_GetCaps( impl->preparsed, &caps );
+    if ( status != HIDP_STATUS_SUCCESS ) return HRESULT_FROM_NT( status );
+
+    status = HidP_GetUsages( HidP_Input, HID_USAGE_PAGE_BUTTON, 0, usageList, usageLength, impl->preparsed, impl->readBuffer, impl->readBufferLen );
+    if ( status != HIDP_STATUS_SUCCESS ) return HRESULT_FROM_NT( status );
+
+    return S_OK;
+}
+
+HRESULT game_input_device_CurrentValue( IN v2_IGameInputDevice *iface, IN USAGE usagePage, IN USAGE usage, OUT PLONG value )
+{
+    struct game_input_device *impl = impl_from_IGameInputDevice( iface );
+
+    HIDP_CAPS caps;
+    NTSTATUS status;
+
+    TRACE( "iface %p.\n", iface );
+
+    status = HidP_GetCaps( impl->preparsed, &caps );
+    if ( status != HIDP_STATUS_SUCCESS ) return HRESULT_FROM_NT( status );
+
+    status = HidP_GetScaledUsageValue( HidP_Input, usagePage, 0, usage, value, impl->preparsed, impl->readBuffer, impl->readBufferLen );
+    if ( status != HIDP_STATUS_SUCCESS ) return HRESULT_FROM_NT( status );
+
+    return S_OK;
+}
+
+static const struct v2_IGameInputDeviceVtbl game_input_device_vtbl =
+{
+    /* IUnknown methods */
+    game_input_device_QueryInterface,
+    game_input_device_AddRef,
+    game_input_device_Release,
+    /* v2_IGameInputDevice methods */
+    game_input_device_GetDeviceInfo,
+    game_input_device_GetHapticInfo,
+    game_input_device_GetDeviceStatus,
+    game_input_device_CreateForceFeedbackEffect,
+    game_input_device_IsForceFeedbackMotorPoweredOn,
+    game_input_device_SetForceFeedbackMotorGain,
+    game_input_device_SetRumbleState,
+    game_input_device_DirectInputEscape
+};
+
+static HRESULT device_provider_create( LPWSTR device_path )
+{
+    HRESULT status;
+
+    IDirectInputDevice8W *dinput_device;
+    v2_IGameInputDevice *addedDevice;
+    IDirectInput8W *dinput;
+    BOOLEAN found;
+    GUID guid = device_path_guid;
+
+    struct game_input_device *impl, *entry;
+    struct device_callback *callback;
+
+    TRACE("device_path is %s\n", debugstr_w(device_path));
+
+    *(LPCWSTR *)&guid = device_path;
+    status = DirectInput8Create( game_input, DIRECTINPUT_VERSION, &IID_IDirectInput8W, (void **)&dinput, NULL );
+    if ( FAILED( status ) ) return status;
+
+    status = game_input_device_Create( &addedDevice );
+    if ( FAILED( status ) ) goto _CLEANUP;
+
+    status = IDirectInput8_CreateDevice( dinput, &guid, &dinput_device, NULL );
+    IDirectInput8_Release( dinput );
+    // HACK: Mouse device is manually set at mouinput.c
+    if ( SUCCEEDED( status ) )
+    {
+        if ( FAILED(status = IDirectInputDevice8_SetCooperativeLevel( dinput_device, 0, DISCL_BACKGROUND | DISCL_NONEXCLUSIVE ) ) ) goto _CLEANUP;
+        if ( FAILED(status = IDirectInputDevice8_SetDataFormat( dinput_device, &data_format ) ) ) goto _CLEANUP;
+        if ( FAILED(status = IDirectInputDevice8_Acquire( dinput_device ) ) ) goto _CLEANUP;
+        status = game_input_device_SetDInputDevice( addedDevice, dinput_device );
+        if ( FAILED( status ) ) goto _CLEANUP;
+    }
+
+    impl = impl_from_IGameInputDevice( addedDevice );
+
+    status = game_input_device_AddGameHID( addedDevice, device_path );
+    if ( FAILED( status ) ) goto _CLEANUP;
+
+    list_init( &impl->entry );
+
+    EnterCriticalSection( &provider_cs );
+    LIST_FOR_EACH_ENTRY( entry, &device_list, struct game_input_device, entry )
+    {
+        // avoid registering 2 mouse devices at once.
+        if ( (entry->deviceInfo.supportedInput & GameInputKindMouse) && (impl->deviceInfo.supportedInput & GameInputKindMouse) )
+        {
+            found = TRUE;
+            break;
+        }
+        if ( (found = !wcscmp( entry->pnpPath, device_path ) ) ) break;
+    }
+    if ( !found ) list_add_tail( &device_list, &impl->entry );
+
+    LIST_FOR_EACH_ENTRY( callback, &callback_list, struct device_callback, entry )
+    {
+        if ( impl->deviceInfo.supportedInput & callback->kind )
+            if ( impl->deviceStatus & callback->filter )
+            {
+                callback->callback( callback->token, callback->context, addedDevice, time(NULL), impl->deviceStatus, impl->previousDeviceStatus );
+            }
+    }
+    LeaveCriticalSection( &provider_cs );
+
+_CLEANUP:
+    if ( FAILED( status ) )
+    {
+        if ( dinput_device ) IDirectInputDevice_Release( dinput_device );
+        if ( addedDevice ) v2_IGameInputDevice_Release( addedDevice );
+    }
+
+    return status;
+}
+
+static LRESULT CALLBACK DeviceNotifyWndProc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
+{
+    DEV_BROADCAST_DEVICEINTERFACE_W *iface;
+
+    TRACE( "hwnd %p, msg %#x, wparam %#Ix, lparam %#Ix\n", hwnd, msg, wparam, lparam );
+
+    if (msg == WM_DEVICECHANGE)
+    { 
+        switch (wparam)
+        {
+        case DBT_DEVICEARRIVAL:
+            iface = (DEV_BROADCAST_DEVICEINTERFACE_W *)lparam;
+            device_provider_create( iface->dbcc_name );
+            break;
+        case DBT_DEVICEREMOVECOMPLETE:
+            iface = (DEV_BROADCAST_DEVICEINTERFACE_W *)lparam;
+            //provider_remove( iface->dbcc_name );
+            break;
+        default: break;
+        }
+    }
+
+    return DefWindowProcW( hwnd, msg, wparam, lparam );
+}
+
+static void initialize_devices( void )
+{
+    char buffer[offsetof( SP_DEVICE_INTERFACE_DETAIL_DATA_W, DevicePath[MAX_PATH] )];
+    SP_DEVICE_INTERFACE_DETAIL_DATA_W *detail = (void *)buffer;
+    SP_DEVICE_INTERFACE_DATA iface = { .cbSize = sizeof(iface) };
+    HRESULT status;
+    HDEVINFO set;
+    DWORD i = 0;
+    GUID hidGuid;
+
+    TRACE("initializing devices...\n");
+
+    set = SetupDiGetClassDevsW( &hidGuid, NULL, NULL, DIGCF_ALLCLASSES | DIGCF_DEVICEINTERFACE | DIGCF_PRESENT );
+
+    while ( SetupDiEnumDeviceInterfaces( set, NULL, &hidGuid, i++, &iface ) )
+    {
+        detail->cbSize = sizeof(*detail);
+        if ( !SetupDiGetDeviceInterfaceDetailW( set, &iface, detail, sizeof(buffer), NULL, NULL ) ) continue;
+        device_provider_create( detail->DevicePath );
+    }
+
+    HidD_GetHidGuid( &hidGuid );
+
+    while ( SetupDiEnumDeviceInterfaces( set, NULL, &hidGuid, i++, &iface ) )
+    {
+        detail->cbSize = sizeof(*detail);
+        if ( !SetupDiGetDeviceInterfaceDetailW( set, &iface, detail, sizeof(buffer), NULL, NULL ) ) continue;
+        status = device_provider_create( detail->DevicePath );
+    }
+
+    SetupDiDestroyDeviceInfoList( set );
+}
+
+DWORD WINAPI DeviceMonitorThread( LPVOID lpParam )
+{
+    DEV_BROADCAST_DEVICEINTERFACE_W filter =
+    {
+        .dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE_W),
+        .dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE,
+    };
+    WNDCLASSEXW wndclass =
+    {
+        .cbSize = sizeof(WNDCLASSEXW),
+        .lpszClassName = L"__wine_game_input_devnotify",
+        .lpfnWndProc = DeviceNotifyWndProc,
+    };
+
+    HDEVNOTIFY devnotify;
+    HMODULE module;
+    HANDLE start_event = (HANDLE)lpParam;
+    HWND hwnd;
+    MSG msg;
+
+    TRACE( "lpParam %p.\n", lpParam );
+
+    SetThreadDescription( GetCurrentThread(), L"wine_game_input_worker" );
+
+    GetModuleHandleExW( GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, (PVOID)game_input, &module );
+    RegisterClassExW( &wndclass );
+
+    hwnd = CreateWindowExW( 0, wndclass.lpszClassName, NULL, 0, 0, 0, 0, 0, HWND_MESSAGE, NULL, NULL, NULL );
+    devnotify = RegisterDeviceNotificationW( hwnd, &filter, DEVICE_NOTIFY_ALL_INTERFACE_CLASSES );
+
+    initialize_devices();
+    SetEvent( start_event );
+
+    do
+    {
+        while ( PeekMessageW( &msg, hwnd, 0, 0, PM_REMOVE ) )
+        {
+            TranslateMessage( &msg );
+            DispatchMessageW( &msg );
+        }
+    } while ( !MsgWaitForMultipleObjectsEx( 0, NULL, INFINITE, QS_ALLINPUT, MWMO_ALERTABLE ) );
+
+    UnregisterDeviceNotification( devnotify );
+    DestroyWindow( hwnd );
+    UnregisterClassW( wndclass.lpszClassName, NULL );
+
+    FreeLibraryAndExitThread( module, 0 );
+    return 0;
+}
+
+HRESULT WINAPI RegisterDeviceCallback( v2_IGameInputDevice *device, GameInputKind kind, GameInputDeviceStatus filter, void *context, v2_GameInputDeviceCallback callback, GameInputCallbackToken *token )
+{
+    struct device_callback *entry;
+    struct game_input_device *input_device;
+
+    TRACE( "device %p, kind %#x, filter %#x, context %p, callback %p, token %p.\n", device, kind, filter, context, callback, token );
+
+    if ( !token )
+        return E_POINTER;
+
+    if (!(entry = calloc( 1, sizeof(*entry) ))) return E_OUTOFMEMORY;
+
+    entry->device = device;
+    entry->callback = callback;
+    entry->context = context;
+    entry->filter = filter;
+    entry->kind = kind;
+
+    list_init( &entry->entry );
+
+    if ( !device )
+    {
+        EnterCriticalSection( &provider_cs );
+        nextId++;
+        entry->token = nextId;
+        *token = nextId;
+        list_add_tail( &callback_list, &entry->entry );
+
+        LIST_FOR_EACH_ENTRY( input_device, &device_list, struct game_input_device, entry )
+        {
+            if ( input_device->deviceInfo.supportedInput & kind )
+                if ( input_device->deviceStatus & filter )
+                {
+                    callback( *token, context, &input_device->v2_IGameInputDevice_iface, time(NULL), input_device->deviceStatus, input_device->previousDeviceStatus );
+                }
+        }
+        LeaveCriticalSection( &provider_cs );
+    }
+
+    return S_OK;
+}
+
+HRESULT game_input_device_Create( v2_IGameInputDevice **device )
+{
+    struct game_input_device *impl;
+
+    TRACE( "device %p\n", device );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+
+    impl->v2_IGameInputDevice_iface.lpVtbl = &game_input_device_vtbl;
+    impl->ref = 1;
+
+    InitializeCriticalSection( &impl->readLock );
+
+    *device = &impl->v2_IGameInputDevice_iface;
+    TRACE( "created v2_IGameInputDevice %p\n", &impl->v2_IGameInputDevice_iface );
+
+    return S_OK;
+}
\ No newline at end of file
diff --git a/dlls/gameinput/inputdevice.h b/dlls/gameinput/inputdevice.h
new file mode 100644
index 00000000000..1548bf5465d
--- /dev/null
+++ b/dlls/gameinput/inputdevice.h
@@ -0,0 +1,83 @@
+/*
+ * Game Input Library
+ *  -> Game Input Devices
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef INPUT_DEVICE_H
+#define INPUT_DEVICE_H
+
+#include "private.h"
+
+struct device_callback
+{
+    v2_GameInputDeviceCallback callback;
+    GameInputDeviceStatus filter;
+    GameInputKind kind;
+    v2_IGameInputDevice *device;
+    PVOID context;
+    GameInputCallbackToken token;
+    struct list entry;
+};
+
+struct game_input_device
+{
+    v2_IGameInputDevice v2_IGameInputDevice_iface;
+    v2_GameInputDeviceInfo deviceInfo;
+
+    GameInputHapticInfo hapticInfo;
+    GameInputDeviceStatus previousDeviceStatus;
+    GameInputDeviceStatus deviceStatus;
+    GameInputRumbleParams rumbleState;
+
+    // Private members:
+    struct list entry;
+
+    HDEVINFO *hidInfo;
+    SP_DEVINFO_DATA hidData;
+    PHIDP_PREPARSED_DATA preparsed;
+    HANDLE deviceHandle;
+
+    OVERLAPPED readOv;
+    PCHAR readBuffer;
+    ULONG readBufferLen;
+    BOOLEAN readPending;
+    CRITICAL_SECTION readLock;
+    LPWSTR pnpPath;
+
+    LPDIRECTINPUTDEVICE8W pDevice;
+
+    LONG ref;
+};
+
+HRESULT game_input_device_AcquireDInputDevice( IN v2_IGameInputDevice *iface, OUT LPDIRECTINPUTDEVICE8W *device );
+HRESULT game_input_device_SetDInputDevice( IN v2_IGameInputDevice *iface, IN LPDIRECTINPUTDEVICE8W device );
+HRESULT game_input_device_Create( v2_IGameInputDevice **device );
+HRESULT game_input_device_AddGameHID( IN v2_IGameInputDevice *iface, IN LPWSTR devicePath );
+HRESULT game_input_device_OpenDevice( IN v2_IGameInputDevice *iface );
+HRESULT game_input_device_CloseDevice( IN v2_IGameInputDevice *iface );
+HRESULT game_input_device_QueryGameHIDButtonCaps( IN v2_IGameInputDevice *iface, OUT HIDP_BUTTON_CAPS **btnCaps, OUT USHORT *nBtnCaps );
+HRESULT game_input_device_QueryGameHIDValueCaps( IN v2_IGameInputDevice *iface, OUT HIDP_VALUE_CAPS **valueCaps, OUT USHORT *nValueCaps );
+HRESULT game_input_device_PollHIDDevice( IN v2_IGameInputDevice *iface );
+HRESULT game_input_device_CurrentButtons( IN v2_IGameInputDevice *iface, OUT USAGE usageList[128], OUT ULONG *usageLength );
+HRESULT game_input_device_CurrentValue( IN v2_IGameInputDevice *iface, IN USAGE usagePage, IN USAGE usage, OUT PLONG value );
+
+HRESULT WINAPI RegisterDeviceCallback( v2_IGameInputDevice *device, GameInputKind kind, GameInputDeviceStatus filter, void *context, v2_GameInputDeviceCallback callback, GameInputCallbackToken *token );
+DWORD WINAPI DeviceMonitorThread( PVOID lpParam );
+
+#endif
\ No newline at end of file
diff --git a/dlls/gameinput/inputreading.c b/dlls/gameinput/inputreading.c
new file mode 100644
index 00000000000..cf890fa2c3e
--- /dev/null
+++ b/dlls/gameinput/inputreading.c
@@ -0,0 +1,324 @@
+/*
+ * Game Input Library
+ *  -> Game Input Reading
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "inputreading.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(ginput);
+
+static inline struct game_input_reading *impl_from_IGameInputReading( v2_IGameInputReading *iface )
+{
+    return CONTAINING_RECORD( iface, struct game_input_reading, v2_IGameInputReading_iface );
+}
+
+static HRESULT WINAPI game_input_reading_QueryInterface( v2_IGameInputReading *iface, REFIID iid, void **out )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_v2_IGameInputReading ))
+    {
+        *out = &impl->v2_IGameInputReading_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI game_input_reading_AddRef( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI game_input_reading_Release( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+};
+
+static GameInputKind WINAPI game_input_reading_GetInputKind( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+
+    HRESULT status;
+    const v2_GameInputDeviceInfo *device_info;
+
+    TRACE( "iface %p.\n", iface );
+
+    status = v2_IGameInputDevice_GetDeviceInfo( impl->device, &device_info );
+    if ( FAILED( status ) ) return 0;
+
+    return device_info->supportedInput;
+}
+
+static uint64_t WINAPI game_input_reading_GetTimestamp( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    TRACE( "iface %p.\n", iface );
+    return impl->timestamp;
+}
+
+static void WINAPI game_input_reading_GetDevice( v2_IGameInputReading *iface, v2_IGameInputDevice **device )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    TRACE( "iface %p, device %p.\n", iface, device );
+    if ( device )
+        v2_IGameInputDevice_QueryInterface( impl->device, &IID_v2_IGameInputDevice, (void **)device );
+    return;
+}
+
+static uint32_t WINAPI game_input_reading_GetControllerAxisCount( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+
+    HRESULT status;
+    const v2_GameInputDeviceInfo *device_info;
+
+    TRACE( "iface %p.\n", iface );
+
+    status = v2_IGameInputDevice_GetDeviceInfo( impl->device, &device_info );
+    if ( FAILED( status ) ) return 0;
+
+    return device_info->controllerAxisCount;
+}
+
+static uint32_t WINAPI game_input_reading_GetControllerAxisState( v2_IGameInputReading *iface, uint32_t count, float *state )
+{
+    uint32_t copy;
+    uint32_t numAxes;
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    
+    TRACE( "iface %p, count %d, state %p!\n", iface, count, state );
+
+    numAxes = v2_IGameInputReading_GetControllerAxisCount( iface );
+    copy = ( count < numAxes ) ? count : numAxes;
+
+    memcpy( state, impl->controllerAxisState, copy * sizeof( float ) );
+
+    return copy;
+}
+
+static uint32_t WINAPI game_input_reading_GetControllerButtonCount( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+
+    HRESULT status;
+    const v2_GameInputDeviceInfo *device_info;
+
+    TRACE( "iface %p.\n", iface );
+
+    status = v2_IGameInputDevice_GetDeviceInfo( impl->device, &device_info );
+    if ( FAILED( status ) ) return 0;
+
+    return device_info->controllerButtonCount;
+}
+
+static uint32_t WINAPI game_input_reading_GetControllerButtonState( v2_IGameInputReading *iface, uint32_t count, bool *state )
+{
+    uint32_t copy;
+    uint32_t numButtons;
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    
+    TRACE( "iface %p, count %d, state %p!\n", iface, count, state );
+
+    numButtons = v2_IGameInputReading_GetControllerButtonCount( iface );
+    copy = ( count < numButtons ) ? count : numButtons;
+
+    memcpy( state, impl->controllerButtonState, copy * sizeof( bool ) );
+
+    return copy;
+}
+
+static uint32_t WINAPI game_input_reading_GetControllerSwitchCount( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+
+    HRESULT status;
+    const v2_GameInputDeviceInfo *device_info;
+
+    TRACE( "iface %p.\n", iface );
+
+    status = v2_IGameInputDevice_GetDeviceInfo( impl->device, &device_info );
+    if ( FAILED( status ) ) return 0;
+
+    return device_info->controllerSwitchCount;
+}
+
+static uint32_t WINAPI game_input_reading_GetControllerSwitchState( v2_IGameInputReading *iface, uint32_t count, GameInputSwitchPosition *state )
+{
+    uint32_t copy;
+    uint32_t numSwitches;
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    
+    TRACE( "iface %p, count %d, state %p!\n", iface, count, state );
+
+    numSwitches = v2_IGameInputReading_GetControllerSwitchCount( iface );
+    copy = ( count < numSwitches ) ? count : numSwitches;
+
+    memcpy( state, impl->switchState, copy * sizeof( GameInputSwitchPosition ) );
+
+    return copy;
+}
+
+// MSDN Error: GetKeyCount API is for Keyboards, not Game Controllers!
+// Reference: https://learn.microsoft.com/en-us/gaming/gdk/docs/reference/input/gameinput-v2/interfaces/igameinputreading/methods/igameinputreading_getkeycount-v2
+static uint32_t WINAPI game_input_reading_GetKeyCount( v2_IGameInputReading *iface )
+{
+    FIXME( "iface %p stub!\n", iface );
+    return 0;
+}
+
+static uint32_t WINAPI game_input_reading_GetKeyState( v2_IGameInputReading *iface, uint32_t count, GameInputKeyState *state )
+{
+    FIXME( "iface %p, count %d, state %p stub!\n", iface, count, state );
+    return 0;
+}
+
+static bool WINAPI game_input_reading_GetMouseState( v2_IGameInputReading *iface, v2_GameInputMouseState *state )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    TRACE( "iface %p, state %p.\n", iface, state );
+    if( state ) *state = impl->mouseState;
+    return !!state;
+}
+
+static bool WINAPI game_input_reading_GetSensorsState( v2_IGameInputReading *iface, GameInputSensorsState *state )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    TRACE( "iface %p, state %p.\n", iface, state );
+    if( state ) *state = impl->sensorsState;
+    return !!state;
+}
+
+static bool WINAPI game_input_reading_GetArcadeStickState( v2_IGameInputReading *iface, GameInputArcadeStickState *state )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    TRACE( "iface %p, state %p.\n", iface, state );
+    if( state ) *state = impl->arcadeStickState;
+    return !!state;
+}
+
+static bool WINAPI game_input_reading_GetFlightStickState( v2_IGameInputReading *iface, GameInputFlightStickState *state )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    TRACE( "iface %p, state %p.\n", iface, state );
+    if( state ) *state = impl->flightStickState;
+    return !!state;
+}
+
+static bool WINAPI game_input_reading_GetGamepadState( v2_IGameInputReading *iface, GameInputGamepadState *state )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    TRACE( "iface %p, state %p.\n", iface, state );
+    if( state ) *state = impl->gamepadState;
+    return !!state;
+}
+
+static bool WINAPI game_input_reading_GetRacingWheelState( v2_IGameInputReading *iface, GameInputRacingWheelState *state )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    TRACE( "iface %p, state %p.\n", iface, state );
+    if( state ) *state = impl->racingWheelState;
+    return !!state;
+}
+
+static bool WINAPI game_input_reading_GetUiNavigationState( v2_IGameInputReading *iface, GameInputUiNavigationState *state )
+{
+    struct game_input_reading *impl = impl_from_IGameInputReading( iface );
+    TRACE( "iface %p, state %p.\n", iface, state );
+    if( state ) *state = impl->uiNavigationState;
+    return !!state;
+}
+
+const struct v2_IGameInputReadingVtbl game_input_reading_vtbl =
+{
+    /* IUnknown methods */
+    game_input_reading_QueryInterface,
+    game_input_reading_AddRef,
+    game_input_reading_Release,
+    /* v2_IGameInputReading */
+    game_input_reading_GetInputKind,
+    game_input_reading_GetTimestamp,
+    game_input_reading_GetDevice,
+    game_input_reading_GetControllerAxisCount,
+    game_input_reading_GetControllerAxisState,
+    game_input_reading_GetControllerButtonCount,
+    game_input_reading_GetControllerButtonState,
+    game_input_reading_GetControllerSwitchCount,
+    game_input_reading_GetControllerSwitchState,
+    game_input_reading_GetKeyCount,
+    game_input_reading_GetKeyState,
+    game_input_reading_GetMouseState,
+    game_input_reading_GetSensorsState,
+    game_input_reading_GetArcadeStickState,
+    game_input_reading_GetFlightStickState,
+    game_input_reading_GetGamepadState,
+    game_input_reading_GetRacingWheelState,
+    game_input_reading_GetUiNavigationState
+};
+
+HRESULT game_input_reading_CreateForMouseDevice( v2_IGameInputDevice *device, v2_GameInputMouseState state, uint64_t timestamp, v2_IGameInputReading **out )
+{
+    struct game_input_reading *impl;
+
+    TRACE( "device %p\n", device );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+
+    impl->v2_IGameInputReading_iface.lpVtbl = &game_input_reading_vtbl;
+    impl->mouseState = state;
+    impl->device = device;
+    impl->ref = 1;
+
+    *out = &impl->v2_IGameInputReading_iface;
+    TRACE( "created v2_IGameInputReading %p\n", &impl->v2_IGameInputReading_iface );
+
+    return S_OK;
+}
+
+HRESULT game_input_reading_CreateForGamepadDevice( v2_IGameInputDevice *device, GameInputGamepadState state, uint64_t timestamp, v2_IGameInputReading **out )
+{
+    struct game_input_reading *impl;
+
+    TRACE( "device %p\n", device );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+
+    impl->v2_IGameInputReading_iface.lpVtbl = &game_input_reading_vtbl;
+    impl->gamepadState = state;
+    impl->device = device;
+    impl->ref = 1;
+
+    *out = &impl->v2_IGameInputReading_iface;
+    TRACE( "created v2_IGameInputReading %p\n", &impl->v2_IGameInputReading_iface );
+
+    return S_OK;
+}
\ No newline at end of file
diff --git a/dlls/gameinput/inputreading.h b/dlls/gameinput/inputreading.h
new file mode 100644
index 00000000000..39d27c64fe0
--- /dev/null
+++ b/dlls/gameinput/inputreading.h
@@ -0,0 +1,52 @@
+/*
+ * Game Input Library
+ *  -> Game Input Reading
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef INPUT_READING_H
+#define INPUT_READING_H
+
+#include "private.h"
+
+struct game_input_reading
+{
+    v2_IGameInputReading v2_IGameInputReading_iface;
+    v2_IGameInputDevice *device;
+
+    v2_GameInputMouseState mouseState;
+    GameInputSensorsState sensorsState;
+    GameInputArcadeStickState arcadeStickState;
+    GameInputFlightStickState flightStickState;
+    GameInputGamepadState gamepadState;
+    GameInputRacingWheelState racingWheelState;
+    GameInputUiNavigationState uiNavigationState;
+    GameInputSwitchPosition *switchState;
+    GameInputKeyState *keyState;
+    FLOAT *controllerAxisState;
+    BOOL *controllerButtonState;
+
+    uint64_t timestamp;
+
+    LONG ref;
+};
+
+HRESULT game_input_reading_CreateForMouseDevice( v2_IGameInputDevice *device, v2_GameInputMouseState state, uint64_t timestamp, v2_IGameInputReading **out );
+HRESULT game_input_reading_CreateForGamepadDevice( v2_IGameInputDevice *device, GameInputGamepadState state, uint64_t timestamp, v2_IGameInputReading **out );
+
+#endif
\ No newline at end of file
diff --git a/dlls/gameinput/mouinput.c b/dlls/gameinput/mouinput.c
new file mode 100644
index 00000000000..21d7bf0087f
--- /dev/null
+++ b/dlls/gameinput/mouinput.c
@@ -0,0 +1,319 @@
+/*
+ * Game Input Library
+ *  -> Keyboard Input Events
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "mouinput.h"
+#include "inputdevice.h"
+#include "inputreading.h"
+
+#include <time.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(ginput);
+
+extern HINSTANCE game_input;
+
+static GameInputMouseButtons storedButtons = GameInputMouseNone;
+static POINT relativePositionStore = {.x = 0, .y = 0};
+static LONG relativeWheelStore = 0;
+
+static VOID append_supported_mouse_buttons( GameInputMouseButtons *buttons, HIDP_BUTTON_CAPS *caps, USHORT nCaps )
+{
+    GameInputMouseButtons currentButtons = *buttons;
+    HIDP_BUTTON_CAPS currentCap;
+    USHORT capsIterator;
+
+    TRACE( "buttons %p, caps %p, nCaps %d.\n", buttons, caps, nCaps );
+
+    for ( capsIterator = 0; capsIterator < nCaps; capsIterator++ )
+    {
+        currentCap = caps[capsIterator];
+
+        if ( currentCap.UsagePage != HID_USAGE_PAGE_BUTTON )
+            continue;
+
+        if ( currentCap.IsRange )
+        {
+            if ( 0x01 >= currentCap.Range.UsageMin && 0x01 <= currentCap.Range.UsageMax )
+                currentButtons |= GameInputMouseLeftButton;
+            if ( 0x02 >= currentCap.Range.UsageMin && 0x02 <= currentCap.Range.UsageMax )
+                currentButtons |= GameInputMouseRightButton;
+            if ( 0x03 >= currentCap.Range.UsageMin && 0x03 <= currentCap.Range.UsageMax )
+                currentButtons |= GameInputMouseMiddleButton;
+            if ( 0x04 >= currentCap.Range.UsageMin && 0x04 <= currentCap.Range.UsageMax )
+                currentButtons |= GameInputMouseButton4;
+            if ( 0x05 >= currentCap.Range.UsageMin && 0x05 <= currentCap.Range.UsageMax )
+                currentButtons |= GameInputMouseButton5;
+        }
+        else
+        {
+            if ( 0x01 == currentCap.NotRange.Usage )
+                currentButtons |= GameInputMouseLeftButton;
+            if ( 0x02 == currentCap.NotRange.Usage )
+                currentButtons |= GameInputMouseRightButton;
+            if ( 0x03 == currentCap.NotRange.Usage )
+                currentButtons |= GameInputMouseMiddleButton;
+            if ( 0x04 == currentCap.NotRange.Usage )
+                currentButtons |= GameInputMouseButton4;
+            if ( 0x05 == currentCap.NotRange.Usage )
+                currentButtons |= GameInputMouseButton5;
+        }
+    }
+
+    *buttons = currentButtons;
+}
+
+static VOID append_supported_mouse_values( GameInputMouseButtons *buttons, v2_GameInputMouseInfo *mouse_info, HIDP_VALUE_CAPS *caps, USHORT nCaps )
+{
+    GameInputMouseButtons currentButtons = *buttons;
+    HIDP_VALUE_CAPS currentCap;
+    USHORT capsIterator;
+
+    TRACE( "buttons %p, mouse_info %p, caps %p, nCaps %d.\n", buttons, mouse_info, caps, nCaps );
+
+    for ( capsIterator = 0; capsIterator < nCaps; capsIterator++ )
+    {
+        currentCap = caps[capsIterator];
+
+        if ( currentCap.UsagePage == HID_USAGE_PAGE_BUTTON && ( currentCap.IsRange ? (currentCap.Range.UsageMin <= 0x38 && currentCap.Range.UsageMax >= 0x38)
+                                : currentCap.NotRange.Usage == 0x38 ) )
+        {
+            mouse_info->hasWheelX = TRUE;
+            currentButtons |= GameInputMouseWheelTiltLeft;
+            currentButtons |= GameInputMouseWheelTiltRight;
+        }
+        
+        if ( currentCap.UsagePage == HID_USAGE_PAGE_CONSUMER && ( currentCap.IsRange ? (currentCap.Range.UsageMin <= 0x238 && currentCap.Range.UsageMax >= 0x238)
+                                : currentCap.NotRange.Usage == 0x238 ) )
+        {
+            mouse_info->hasWheelY = TRUE;
+        }
+    }
+
+    *buttons = currentButtons;
+}
+
+HRESULT mouse_input_device_InitDInput8Device( IN v2_IGameInputDevice *device )
+{
+    HRESULT hr;
+    HWND hwnd;
+    LPDIRECTINPUT8W g_pDI = NULL;
+    LPDIRECTINPUTDEVICE8W g_pDevice;
+
+    TRACE( "device %p.\n", device );
+
+    hwnd = GetForegroundWindow();
+    if ( !hwnd ) return E_FAIL;
+                
+    hr = DirectInput8Create( game_input, DIRECTINPUT_VERSION, &IID_IDirectInput8W, (void**)&g_pDI, NULL );
+    if ( FAILED( hr ) ) return hr;
+
+    hr = g_pDI->lpVtbl->CreateDevice( g_pDI, &GUID_SysMouse, &g_pDevice, NULL );
+    if ( FAILED( hr ) ) return hr;
+
+    hr = g_pDevice->lpVtbl->SetDataFormat( g_pDevice, &c_dfDIMouse2 );
+    if ( FAILED( hr ) ) return hr;
+
+    hr = g_pDevice->lpVtbl->SetCooperativeLevel( g_pDevice, hwnd, DISCL_FOREGROUND | DISCL_NONEXCLUSIVE );
+    if ( FAILED( hr ) ) return hr;
+
+    // Acquire device
+    hr = g_pDevice->lpVtbl->Acquire( g_pDevice );
+
+    game_input_device_SetDInputDevice( device, g_pDevice );
+
+    return hr;
+}
+
+HRESULT mouse_input_device_InitDevice( IN v2_IGameInputDevice *device )
+{
+    USHORT nCaps;
+    HRESULT hr = S_OK;
+    HIDP_BUTTON_CAPS *buttonCaps = NULL;
+    HIDP_VALUE_CAPS *valueCaps = NULL;
+
+    v2_IGameInputDevice *dev = NULL;
+    v2_GameInputMouseInfo mouse_info;
+    v2_GameInputDeviceInfo *device_info;
+    GameInputMouseButtons buttons = GameInputMouseNone;
+
+    TRACE( "device %p.\n", device );
+
+    if ( !device )
+        return E_INVALIDARG;
+
+    hr = game_input_device_OpenDevice( device );
+    if ( FAILED( hr ) ) goto _CLEANUP;
+
+    hr = game_input_device_QueryGameHIDButtonCaps( device, &buttonCaps, &nCaps );
+    if ( FAILED( hr ) ) goto _CLEANUP;
+    append_supported_mouse_buttons( &buttons, buttonCaps, nCaps );
+
+    // BUG: QueryGameHIDValueCaps for mouse devices don't work within wine!!
+    //hr = game_input_device_QueryGameHIDValueCaps( device, &valueCaps, &nCaps);
+    //if ( FAILED( hr ) ) goto _CLEANUP;
+    //append_supported_mouse_values( &buttons, &mouse_info, valueCaps, nCaps );
+
+    // It is not possible to obtain sample rates from a HID device.
+    // So we'll use a safe sample rate of 500 hz.
+    mouse_info.sampleRate = 500;
+    mouse_info.supportedButtons = buttons;
+
+    // const override here!
+    v2_IGameInputDevice_GetDeviceInfo( device, (const v2_GameInputDeviceInfo **)&device_info );
+    device_info->mouseInfo = &mouse_info;
+
+    // DInput device for mouse devices are manually acquired
+    hr = mouse_input_device_InitDInput8Device( device );
+    if ( FAILED( hr ) ) return hr;
+
+_CLEANUP:
+    if ( FAILED( hr ) )
+    {
+        if ( dev ) v2_IGameInputDevice_Release( dev );
+    }
+    if ( buttonCaps ) free( buttonCaps );
+    if ( valueCaps ) free( valueCaps );
+
+    return hr;
+}
+
+HRESULT mouse_input_device_ReadCurrentStateFromHID( IN v2_IGameInputDevice *device, IN uint64_t timestamp, OUT v2_IGameInputReading **reading )
+{
+    HRESULT hr = S_OK;
+    USAGE usages[128];
+    ULONG usageLength = sizeof(usages);
+    ULONG usageIterator;
+    POINT posStore;
+    POINT absolutePos;
+    LONG wheelStore;
+
+    const v2_GameInputDeviceInfo *device_info;
+    v2_GameInputMouseState state;
+
+    TRACE( "device %p, timestamp %lld, reading %p.\n", device, timestamp, reading );
+
+    state.buttons = GameInputMouseNone;
+
+    v2_IGameInputDevice_GetDeviceInfo( device, &device_info );
+
+    GetCursorPos( &absolutePos );
+
+    hr = game_input_device_PollHIDDevice( device );
+    if ( hr == E_PENDING )
+    {
+        // Pending call. consider previous buttons being pressed.
+    }
+    else if ( SUCCEEDED( hr ) )
+    {
+        storedButtons = GameInputMouseNone;
+        game_input_device_CurrentValue( device, device_info->usage.page, 0x30, &posStore.x );
+        game_input_device_CurrentValue( device, device_info->usage.page, 0x31 , &posStore.y );
+        game_input_device_CurrentValue( device, device_info->usage.page, 0x38 , &wheelStore );
+
+        game_input_device_CurrentButtons( device, usages, &usageLength );
+        for ( usageIterator = 0; usageIterator < usageLength; usageIterator++ )
+        {
+            if ( usages[usageIterator] == 1 )
+                storedButtons |= GameInputMouseLeftButton;
+            if ( usages[usageIterator] == 2 )
+                storedButtons |= GameInputMouseRightButton;
+            if ( usages[usageIterator] == 3 )
+                storedButtons |= GameInputMouseMiddleButton;
+            if ( usages[usageIterator] == 4 )
+                storedButtons |= GameInputMouseButton4;
+            if ( usages[usageIterator] == 5 )
+                storedButtons |= GameInputMouseButton5;
+        }
+
+        relativePositionStore.x += posStore.x;
+        relativePositionStore.y += posStore.y;
+        relativeWheelStore += wheelStore;
+    } else
+    {
+        // Failed somewhere...
+        return hr;
+    }
+
+    state.positionX = relativePositionStore.x * 5;
+    state.positionY = relativePositionStore.y * 5;
+    state.wheelY = relativeWheelStore * 100;
+
+    state.buttons = storedButtons;
+    state.positions = GameInputMouseRelativePosition;
+    state.absolutePositionX = absolutePos.x;
+    state.absolutePositionY = absolutePos.y;
+
+    hr = game_input_reading_CreateForMouseDevice( device, state, timestamp, reading );
+
+    return hr;
+}
+
+HRESULT mouse_input_device_ReadCurrentStateFromDInput8( IN v2_IGameInputDevice *device, IN uint64_t timestamp, OUT v2_IGameInputReading **reading )
+{
+    POINT absoluteP;
+    HRESULT hr;
+    DIMOUSESTATE2 state;
+    LPDIRECTINPUTDEVICE8W g_pDevice;
+
+    v2_GameInputMouseState mouseState;
+
+    TRACE( "device %p, timestamp %lld, reading %p.\n", device, timestamp, reading );
+
+    GetCursorPos( &absoluteP );
+
+    hr = game_input_device_AcquireDInputDevice( device, &g_pDevice );
+    if ( FAILED( hr ) ) return hr;
+
+    hr = g_pDevice->lpVtbl->GetDeviceState( g_pDevice, sizeof(state), &state );
+    if ( FAILED( hr ) ) 
+    {
+        if ( ( hr == DIERR_INPUTLOST ) || ( hr == DIERR_NOTACQUIRED ) ) {
+            // Try to reacquire
+            hr = g_pDevice->lpVtbl->Acquire( g_pDevice );
+        }
+    }
+    else
+    {
+        mouseState.positions = GameInputMouseRelativePosition;
+        mouseState.absolutePositionX = absoluteP.x;
+        mouseState.absolutePositionY = absoluteP.y;
+        relativePositionStore.x += state.lX;
+        relativePositionStore.y += state.lY;
+        relativeWheelStore += state.lZ;
+        mouseState.positionX = relativePositionStore.x;
+        mouseState.positionY = relativePositionStore.y;
+        mouseState.wheelY = relativeWheelStore;
+    }
+
+    if ( GetAsyncKeyState( VK_LBUTTON ) & 0x8000 )
+        mouseState.buttons |= GameInputMouseLeftButton;
+    if ( GetAsyncKeyState( VK_RBUTTON ) & 0x8000 )
+        mouseState.buttons |= GameInputMouseRightButton;
+    if ( GetAsyncKeyState( VK_MBUTTON ) & 0x8000 )
+        mouseState.buttons |= GameInputMouseMiddleButton;
+    if ( GetAsyncKeyState( VK_XBUTTON1 ) & 0x8000 )
+        mouseState.buttons |= GameInputMouseButton4;
+    if ( GetAsyncKeyState( VK_XBUTTON2 ) & 0x8000 )
+        mouseState.buttons |= GameInputMouseButton5;
+
+    hr = game_input_reading_CreateForMouseDevice( device, mouseState, timestamp, reading );
+
+    return hr;
+}
diff --git a/dlls/gameinput/mouinput.h b/dlls/gameinput/mouinput.h
new file mode 100644
index 00000000000..6d154519f58
--- /dev/null
+++ b/dlls/gameinput/mouinput.h
@@ -0,0 +1,32 @@
+/*
+ * Game Input Library
+ *  -> Keyboard Input Events
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef _MOUINPUT_H
+#define _MOUINPUT_H
+
+#include "private.h"
+
+HRESULT mouse_input_device_InitDevice( IN v2_IGameInputDevice *device );
+HRESULT mouse_input_device_InitDInput8Device( IN v2_IGameInputDevice *device );
+HRESULT mouse_input_device_ReadCurrentStateFromHID( IN v2_IGameInputDevice *device, IN uint64_t timestamp, OUT v2_IGameInputReading **reading );
+HRESULT mouse_input_device_ReadCurrentStateFromDInput8( IN v2_IGameInputDevice *device, IN uint64_t timestamp, OUT v2_IGameInputReading **reading );
+
+#endif
\ No newline at end of file
diff --git a/dlls/gameinput/padinput.c b/dlls/gameinput/padinput.c
new file mode 100644
index 00000000000..fd33ce2b265
--- /dev/null
+++ b/dlls/gameinput/padinput.c
@@ -0,0 +1,352 @@
+/*
+ * Game Input Library
+ *  -> Game Pad Input Events
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "mouinput.h"
+
+#include <time.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(ginput);
+
+HRESULT WINAPI gamepad_input2_device_QueryDeviceInformation( v2_GameInputDeviceInfo *info )
+{
+    v2_GameInputControllerAxisInfo *axis_info;
+    v2_GameInputControllerButtonInfo *button_info;
+    GameInputGamepadInfo *gamePadInfo;
+    v2_GameInputDeviceInfo device_info;
+
+    if (!(gamePadInfo = calloc( 1, sizeof(*gamePadInfo) ))) return E_OUTOFMEMORY;
+
+    mouse_info->supportedButtons = 0x7F;
+    mouse_info->sampleRate = 500;
+    mouse_info->hasWheelX = TRUE;
+    mouse_info->hasWheelY = TRUE;
+
+    device_info.supportedInput = GameInputKindMouse;
+    device_info.mouseInfo = mouse_info;
+    device_info.deviceFamily = GameInputFamilyHid;
+
+    *info = device_info;
+
+    return S_OK;
+}
+
+static inline struct game_input_device *impl_from_v2_IGameInputDevice( v2_IGameInputDevice *iface )
+{
+    return CONTAINING_RECORD( iface, struct game_input_device, v2_IGameInputDevice_iface );
+}
+
+static HRESULT WINAPI gamepad_input2_device_QueryInterface( v2_IGameInputDevice *iface, REFIID iid, void **out )
+{
+    struct game_input_device *impl = impl_from_v2_IGameInputDevice( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_v2_IGameInputDevice ))
+    {
+        *out = &impl->v2_IGameInputDevice_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI gamepad_input2_device_AddRef( v2_IGameInputDevice *iface )
+{
+    struct game_input_device *impl = impl_from_v2_IGameInputDevice( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI gamepad_input2_device_Release( v2_IGameInputDevice *iface )
+{
+    struct game_input_device *impl = impl_from_v2_IGameInputDevice( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+};
+
+static HRESULT WINAPI gamepad_input2_device_GetDeviceInfo( v2_IGameInputDevice *iface, const v2_GameInputDeviceInfo **info )
+{
+    struct game_input_device *impl = impl_from_v2_IGameInputDevice( iface );
+    TRACE( "iface %p, info %p.\n", iface, info );
+    *info = &impl->device_info_v2;
+    return S_OK;
+}
+
+static HRESULT WINAPI gamepad_input2_device_GetHapticInfo( v2_IGameInputDevice *iface, GameInputHapticInfo *info )
+{
+    FIXME( "iface %p, info %p stub!\n", iface, info );
+    return E_NOTIMPL;
+}
+
+static GameInputDeviceStatus WINAPI gamepad_input2_device_GetDeviceStatus( v2_IGameInputDevice *iface )
+{
+    FIXME( "iface %p, stub!\n", iface );
+    return 0;
+}
+
+static HRESULT WINAPI gamepad_input2_device_CreateForceFeedbackEffect( v2_IGameInputDevice *iface, uint32_t motor, const GameInputForceFeedbackParams *params, v2_IGameInputForceFeedbackEffect **effect )
+{
+    FIXME( "iface %p, motor %d, params %p, effect %p stub!\n", iface, motor, params, effect );
+    return E_NOTIMPL;
+}
+
+static bool WINAPI gamepad_input2_device_IsForceFeedbackMotorPoweredOn( v2_IGameInputDevice *iface, uint32_t motor )
+{
+    FIXME( "iface %p, motor %d stub!\n", iface, motor );
+    return FALSE;
+}
+
+static VOID WINAPI gamepad_input2_device_SetForceFeedbackMotorGain( v2_IGameInputDevice *iface, uint32_t motor, float gain )
+{
+    FIXME( "iface %p, motor %d, gain %f stub!\n", iface, motor, gain );
+    return;
+}
+
+static VOID WINAPI gamepad_input2_device_SetRumbleState( v2_IGameInputDevice *iface, const GameInputRumbleParams *params )
+{
+    FIXME( "iface %p, params %p stub!\n", iface, params );
+    return;
+}
+
+static HRESULT WINAPI gamepad_input2_device_DirectInputEscape( v2_IGameInputDevice *iface, uint32_t command, const void *input, uint32_t in_size, void *output, uint32_t out_size, uint32_t *size )
+{
+    FIXME( "iface %p, stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+const struct v2_IGameInputDeviceVtbl gamepad_input2_device_vtbl =
+{
+    /* IUnknown methods */
+    gamepad_input2_device_QueryInterface,
+    gamepad_input2_device_AddRef,
+    gamepad_input2_device_Release,
+    /* v2_IGameInputDevice methods */
+    gamepad_input2_device_GetDeviceInfo,
+    gamepad_input2_device_GetHapticInfo,
+    gamepad_input2_device_GetDeviceStatus,
+    gamepad_input2_device_CreateForceFeedbackEffect,
+    gamepad_input2_device_IsForceFeedbackMotorPoweredOn,
+    gamepad_input2_device_SetForceFeedbackMotorGain,
+    gamepad_input2_device_SetRumbleState,
+    gamepad_input2_device_DirectInputEscape
+};
+
+static inline struct game_input_reading *impl_from_v2_IGameInputReading( v2_IGameInputReading *iface )
+{
+    return CONTAINING_RECORD( iface, struct game_input_reading, v2_IGameInputReading_iface );
+}
+
+static HRESULT WINAPI mouse_input2_reading_QueryInterface( v2_IGameInputReading *iface, REFIID iid, void **out )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_v2_IGameInputReading ))
+    {
+        *out = &impl->v2_IGameInputReading_iface;
+        impl->ref++;
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI mouse_input2_reading_AddRef( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI mouse_input2_reading_Release( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+};
+
+static GameInputKind WINAPI mouse_input2_reading_GetInputKind( v2_IGameInputReading *iface )
+{
+    TRACE( "iface %p.\n", iface );
+    return GameInputKindGamepad;
+}
+
+static uint64_t WINAPI mouse_input2_reading_GetTimestamp( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    TRACE( "iface %p.\n", iface );
+    return impl->timestamp;
+}
+
+static void WINAPI mouse_input2_reading_GetDevice( v2_IGameInputReading *iface, v2_IGameInputDevice **device )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    TRACE( "iface %p, device %p.\n", iface, device );
+    if (device) *device = impl->device;
+    return;
+}
+
+static uint32_t WINAPI mouse_input2_reading_GetControllerAxisCount( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return 0;
+}
+
+static uint32_t WINAPI mouse_input2_reading_GetControllerAxisState( v2_IGameInputReading *iface, uint32_t count, float *state )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return 0;
+}
+
+static uint32_t WINAPI mouse_input2_reading_GetControllerButtonCount( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return 0;
+}
+
+static uint32_t WINAPI mouse_input2_reading_GetControllerButtonState( v2_IGameInputReading *iface, uint32_t count, bool *state )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return 0;
+}
+
+static uint32_t WINAPI mouse_input2_reading_GetControllerSwitchCount( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return 0;
+}
+
+static uint32_t WINAPI mouse_input2_reading_GetControllerSwitchState( v2_IGameInputReading *iface, uint32_t count, GameInputSwitchPosition *state )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return 0;
+}
+
+static uint32_t WINAPI mouse_input2_reading_GetKeyCount( v2_IGameInputReading *iface )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return 0;
+}
+
+static uint32_t WINAPI mouse_input2_reading_GetKeyState( v2_IGameInputReading *iface, uint32_t count, GameInputKeyState *state )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return 0;
+}
+
+static bool WINAPI mouse_input2_reading_GetMouseState( v2_IGameInputReading *iface, v2_GameInputMouseState *state )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    TRACE( "iface %p, state %p.\n", iface, state );
+    *state = impl->mouseState;
+    return true;
+}
+
+static bool WINAPI mouse_input2_reading_GetSensorsState( v2_IGameInputReading *iface, GameInputSensorsState *state )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return false;
+}
+
+static bool WINAPI mouse_input2_reading_GetArcadeStickState( v2_IGameInputReading *iface, GameInputArcadeStickState *state )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return false;
+}
+
+static bool WINAPI mouse_input2_reading_GetFlightStickState( v2_IGameInputReading *iface, GameInputFlightStickState *state )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return false;
+}
+
+static bool WINAPI mouse_input2_reading_GetGamepadState( v2_IGameInputReading *iface, GameInputGamepadState *state )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return false;
+}
+
+static bool WINAPI mouse_input2_reading_GetRacingWheelState( v2_IGameInputReading *iface, GameInputRacingWheelState *state )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return false;
+}
+
+static bool WINAPI mouse_input2_reading_GetUiNavigationState( v2_IGameInputReading *iface, GameInputUiNavigationState *state )
+{
+    struct game_input_reading *impl = impl_from_v2_IGameInputReading( iface );
+    ERR( "Not for this device %p!\n", impl->device );
+    return false;
+}
+
+const struct v2_IGameInputReadingVtbl mouse_input2_reading_vtbl =
+{
+    /* IUnknown methods */
+    mouse_input2_reading_QueryInterface,
+    mouse_input2_reading_AddRef,
+    mouse_input2_reading_Release,
+    /* v2_IGameInputReading */
+    mouse_input2_reading_GetInputKind,
+    mouse_input2_reading_GetTimestamp,
+    mouse_input2_reading_GetDevice,
+    mouse_input2_reading_GetControllerAxisCount,
+    mouse_input2_reading_GetControllerAxisState,
+    mouse_input2_reading_GetControllerButtonCount,
+    mouse_input2_reading_GetControllerButtonState,
+    mouse_input2_reading_GetControllerSwitchCount,
+    mouse_input2_reading_GetControllerSwitchState,
+    mouse_input2_reading_GetKeyCount,
+    mouse_input2_reading_GetKeyState,
+    mouse_input2_reading_GetMouseState,
+    mouse_input2_reading_GetSensorsState,
+    mouse_input2_reading_GetArcadeStickState,
+    mouse_input2_reading_GetFlightStickState,
+    mouse_input2_reading_GetGamepadState,
+    mouse_input2_reading_GetRacingWheelState,
+    mouse_input2_reading_GetUiNavigationState
+};
diff --git a/dlls/gameinput/private.h b/dlls/gameinput/private.h
new file mode 100644
index 00000000000..93c9e71afa7
--- /dev/null
+++ b/dlls/gameinput/private.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2024 Rmi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef _GAMEINPUT_PRIVATE_H
+#define _GAMEINPUT_PRIVATE_H
+
+#include <stddef.h>
+#include <stdarg.h>
+
+#define COBJMACROS
+#include "roapi.h"
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+
+#include "unknwn.h"
+#include "objidlbase.h"
+#include "gameinput.h"
+#include "setupapi.h"
+#include "dbt.h"
+#include "ddk/hidclass.h"
+#include "ddk/hidsdi.h"
+#include "devpkey.h"
+#include "dinput.h"
+#include "objbase.h"
+
+#ifdef HAVE_SDL_H
+# include <SDL.h>
+#endif
+
+#include "wine/debug.h"
+#include "wine/list.h"
+
+#define DEFINE_ASYNC_COMPLETED_HANDLER( name, iface_type, async_type )                              \
+    struct name                                                                                     \
+    {                                                                                               \
+        iface_type iface_type##_iface;                                                              \
+        LONG refcount;                                                                              \
+        BOOL invoked;                                                                               \
+        HANDLE event;                                                                               \
+    };                                                                                              \
+                                                                                                    \
+    static HRESULT WINAPI name##_QueryInterface( iface_type *iface, REFIID iid, void **out )        \
+    {                                                                                               \
+        if (IsEqualGUID( iid, &IID_IUnknown ) || IsEqualGUID( iid, &IID_IAgileObject ) ||           \
+            IsEqualGUID( iid, &IID_##iface_type ))                                                  \
+        {                                                                                           \
+            IInspectable_AddRef( (IInspectable *)iface );                                           \
+            *out = iface;                                                                           \
+            return S_OK;                                                                            \
+        }                                                                                           \
+                                                                                                    \
+        *out = NULL;                                                                                \
+        return E_NOINTERFACE;                                                                       \
+    }                                                                                               \
+                                                                                                    \
+    static ULONG WINAPI name##_AddRef( iface_type *iface )                                          \
+    {                                                                                               \
+        struct name *impl = CONTAINING_RECORD( iface, struct name, iface_type##_iface );            \
+        return InterlockedIncrement( &impl->refcount );                                             \
+    }                                                                                               \
+                                                                                                    \
+    static ULONG WINAPI name##_Release( iface_type *iface )                                         \
+    {                                                                                               \
+        struct name *impl = CONTAINING_RECORD( iface, struct name, iface_type##_iface );            \
+        ULONG ref = InterlockedDecrement( &impl->refcount );                                        \
+        if (!ref) free( impl );                                                                     \
+        return ref;                                                                                 \
+    }                                                                                               \
+                                                                                                    \
+    static HRESULT WINAPI name##_Invoke( iface_type *iface, async_type *async, AsyncStatus status ) \
+    {                                                                                               \
+        struct name *impl = CONTAINING_RECORD( iface, struct name, iface_type##_iface );            \
+        impl->invoked = TRUE;                                                                       \
+        if (impl->event) SetEvent( impl->event );                                                   \
+        return S_OK;                                                                                \
+    }                                                                                               \
+                                                                                                    \
+    static iface_type##Vtbl name##_vtbl =                                                           \
+    {                                                                                               \
+        name##_QueryInterface,                                                                      \
+        name##_AddRef,                                                                              \
+        name##_Release,                                                                             \
+        name##_Invoke,                                                                              \
+    };                                                                                              \
+                                                                                                    \
+    static iface_type *name##_create( HANDLE event )                                                \
+    {                                                                                               \
+        struct name *impl;                                                                          \
+                                                                                                    \
+        if (!(impl = calloc( 1, sizeof(*impl) ))) return NULL;                                      \
+        impl->iface_type##_iface.lpVtbl = &name##_vtbl;                                             \
+        impl->event = event;                                                                        \
+        impl->refcount = 1;                                                                         \
+                                                                                                    \
+        return &impl->iface_type##_iface;                                                           \
+    }                                                                                               \
+                                                                                                    \
+    static DWORD await_##async_type( async_type *async, DWORD timeout )                             \
+    {                                                                                               \
+        iface_type *handler;                                                                        \
+        HANDLE event;                                                                               \
+        DWORD ret;                                                                                  \
+                                                                                                    \
+        event = CreateEventW( NULL, FALSE, FALSE, NULL );                                           \
+        handler = name##_create( event );                                                           \
+        async_type##_put_Completed( async, handler );                                               \
+        ret = WaitForSingleObject( event, timeout );                                                \
+        CloseHandle( event );                                                                       \
+        iface_type##_Release( handler );                                                            \
+                                                                                                    \
+        return ret;                                                                                 \
+    }
+
+
+#endif
\ No newline at end of file
diff --git a/dlls/propsys/propsys_main.c b/dlls/propsys/propsys_main.c
index 011c05eca96..b8e800fbbc4 100644
--- a/dlls/propsys/propsys_main.c
+++ b/dlls/propsys/propsys_main.c
@@ -855,6 +855,8 @@ static struct system_property_description system_properties[] =
     {L"System.Devices.Aep.DeviceAddress", &PKEY_Devices_Aep_DeviceAddress, VT_LPWSTR},
     {L"System.Devices.AepContainer.IsPaired", &PKEY_Devices_AepContainer_IsPaired, VT_BOOL},
     {L"System.Devices.AepService.ProtocolId", &PKEY_Devices_AepService_ProtocolId, VT_CLSID},
+    {L"System.Devices.ModelName", &PKEY_Devices_ModelName, VT_LPWSTR},
+    {L"System.Devices.Manufacturer", &PKEY_Devices_Manufacturer, VT_LPWSTR},
 };
 
 static HRESULT propdesc_from_system_property( const struct system_property_description *desc, IPropertyDescription **out )
diff --git a/dlls/twinapi.appcore/Makefile.in b/dlls/twinapi.appcore/Makefile.in
index c8228475016..48bb4ce78f5 100644
--- a/dlls/twinapi.appcore/Makefile.in
+++ b/dlls/twinapi.appcore/Makefile.in
@@ -8,5 +8,6 @@ SOURCES = \
 	application_view.c \
 	classes.idl \
 	client_device_information.c \
+	data_transfer.c \
 	core_application.c \
 	main.c
diff --git a/dlls/twinapi.appcore/classes.idl b/dlls/twinapi.appcore/classes.idl
index 83aba1c4133..c020bdeb330 100644
--- a/dlls/twinapi.appcore/classes.idl
+++ b/dlls/twinapi.appcore/classes.idl
@@ -31,6 +31,7 @@ import "windows.security.exchangeactivesyncprovisioning.idl";
 import "windows.system.profile.idl";
 import "windows.system.userprofile.idl";
 import "windows.ui.viewmanagement.idl";
+import "windows.applicationmodel.datatransfer.idl";
 import "windows.applicationmodel.core.idl";
 
 namespace Windows.Security.ExchangeActiveSyncProvisioning {
@@ -45,6 +46,11 @@ namespace Windows.System.UserProfile {
 namespace Windows.UI.ViewManagement {
     runtimeclass ApplicationView;
 }
+
+namespace Windows.ApplicationModel.DataTransfer {
+    runtimeclass DataTransferManager;
+}
+
 namespace Windows.ApplicationModel.Core {
     runtimeclass CoreApplication;
 }
diff --git a/dlls/twinapi.appcore/data_transfer.c b/dlls/twinapi.appcore/data_transfer.c
new file mode 100644
index 00000000000..048ef657cae
--- /dev/null
+++ b/dlls/twinapi.appcore/data_transfer.c
@@ -0,0 +1,279 @@
+/*
+ * Copyright 2023 Rmi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(twinapi);
+
+struct data_transfer_manager_statics
+{
+    IActivationFactory IActivationFactory_iface;
+    IDataTransferManagerStatics IDataTransferManagerStatics_iface;
+    IDataTransferManagerInterop IDataTransferManagerInterop_iface;
+    LONG ref;
+};
+
+static inline struct data_transfer_manager_statics *impl_from_IActivationFactory( IActivationFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct data_transfer_manager_statics, IActivationFactory_iface );
+}
+
+static HRESULT WINAPI factory_QueryInterface( IActivationFactory *iface, REFIID iid, void **out )
+{
+    struct data_transfer_manager_statics *impl = impl_from_IActivationFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IActivationFactory ))
+    {
+        *out = &impl->IActivationFactory_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_IDataTransferManagerStatics ))
+    {
+        IInspectable_AddRef( (*out = &impl->IDataTransferManagerStatics_iface) );
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_IDataTransferManagerInterop ))
+    {
+        IInspectable_AddRef( (*out = &impl->IDataTransferManagerInterop_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI factory_AddRef( IActivationFactory *iface )
+{
+    struct data_transfer_manager_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI factory_Release( IActivationFactory *iface )
+{
+    struct data_transfer_manager_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI factory_GetIids( IActivationFactory *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetRuntimeClassName( IActivationFactory *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetTrustLevel( IActivationFactory *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_ActivateInstance( IActivationFactory *iface, IInspectable **instance )
+{
+    FIXME( "iface %p, instance %p stub!\n", iface, instance );
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl factory_vtbl =
+{
+    factory_QueryInterface,
+    factory_AddRef,
+    factory_Release,
+    /* IInspectable methods */
+    factory_GetIids,
+    factory_GetRuntimeClassName,
+    factory_GetTrustLevel,
+    /* IActivationFactory methods */
+    factory_ActivateInstance,
+};
+
+static inline struct data_transfer_manager_statics *impl_from_IDataTransferManagerStatics( IDataTransferManagerStatics *iface )
+{
+    return CONTAINING_RECORD( iface, struct data_transfer_manager_statics, IDataTransferManagerStatics_iface );
+}
+
+static HRESULT WINAPI data_transfer_manager_statics_QueryInterface( IDataTransferManagerStatics *iface,
+                                                                REFIID iid, void **out )
+{
+    struct data_transfer_manager_statics *impl = impl_from_IDataTransferManagerStatics( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IDataTransferManagerStatics ))
+    {
+        IDataTransferManagerStatics_AddRef( (*out = &impl->IDataTransferManagerStatics_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI data_transfer_manager_statics_AddRef( IDataTransferManagerStatics *iface )
+{
+    struct data_transfer_manager_statics *impl = impl_from_IDataTransferManagerStatics( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI data_transfer_manager_statics_Release( IDataTransferManagerStatics *iface )
+{
+    struct data_transfer_manager_statics *impl = impl_from_IDataTransferManagerStatics( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    if (!ref) free( impl );
+    return ref;
+}
+
+static HRESULT WINAPI data_transfer_manager_statics_GetIids( IDataTransferManagerStatics *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI data_transfer_manager_statics_GetRuntimeClassName( IDataTransferManagerStatics *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI data_transfer_manager_statics_GetTrustLevel( IDataTransferManagerStatics *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI data_transfer_manager_statics_ShowShareUI( IDataTransferManagerStatics *iface )
+{
+    FIXME( "iface %p stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI data_transfer_manager_statics_GetForCurrentView( IDataTransferManagerStatics *iface, IDataTransferManager **result )
+{
+    FIXME( "iface %p, result %p stub!\n", iface, result );
+    return E_NOTIMPL;
+}
+
+static IDataTransferManagerStaticsVtbl data_transfer_manager_statics_vtbl =
+{
+    data_transfer_manager_statics_QueryInterface,
+    data_transfer_manager_statics_AddRef,
+    data_transfer_manager_statics_Release,
+    /* IInspectable methods */
+    data_transfer_manager_statics_GetIids,
+    data_transfer_manager_statics_GetRuntimeClassName,
+    data_transfer_manager_statics_GetTrustLevel,
+    /* IDataTransferManagerStatics methods */
+    data_transfer_manager_statics_ShowShareUI,
+    data_transfer_manager_statics_GetForCurrentView
+};
+
+static inline struct data_transfer_manager_statics *impl_from_IDataTransferManagerInterop( IDataTransferManagerInterop *iface )
+{
+    return CONTAINING_RECORD( iface, struct data_transfer_manager_statics, IDataTransferManagerInterop_iface );
+}
+
+static HRESULT WINAPI data_transfer_manager_interop_QueryInterface( IDataTransferManagerInterop *iface,
+                                                                REFIID iid, void **out )
+{
+    struct data_transfer_manager_statics *impl = impl_from_IDataTransferManagerInterop( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IDataTransferManagerInterop ))
+    {
+        IDataTransferManagerInterop_AddRef( (*out = &impl->IDataTransferManagerInterop_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI data_transfer_manager_interop_AddRef( IDataTransferManagerInterop *iface )
+{
+    struct data_transfer_manager_statics *impl = impl_from_IDataTransferManagerInterop( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI data_transfer_manager_interop_Release( IDataTransferManagerInterop *iface )
+{
+    struct data_transfer_manager_statics *impl = impl_from_IDataTransferManagerInterop( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    if (!ref) free( impl );
+    return ref;
+}
+
+static HRESULT WINAPI data_transfer_manager_interop_GetForWindow( IDataTransferManagerInterop *iface, HWND appWindow, REFIID iid, void **result )
+{
+    FIXME( "iface %p, appWindow %p, iid %s, result %p stub!\n", iface, appWindow, debugstr_guid( iid ), result );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI data_transfer_manager_interop_ShowShareUIForWindow( IDataTransferManagerInterop *iface, HWND appWindow )
+{
+    FIXME( "iface %p, appWindow %p stub!\n", iface, appWindow );
+    return E_NOTIMPL;
+}
+
+static IDataTransferManagerInteropVtbl data_transfer_manager_interop_vtbl =
+{
+    data_transfer_manager_interop_QueryInterface,
+    data_transfer_manager_interop_AddRef,
+    data_transfer_manager_interop_Release,
+    /* IDataTransferManagerInterop methods */
+    data_transfer_manager_interop_GetForWindow,
+    data_transfer_manager_interop_ShowShareUIForWindow
+};
+
+static struct data_transfer_manager_statics data_transfer_manager_statics =
+{
+    {&factory_vtbl},
+    {&data_transfer_manager_statics_vtbl},
+    {&data_transfer_manager_interop_vtbl},
+    0,
+};
+
+IActivationFactory *data_transfer_manager_statics_factory = &data_transfer_manager_statics.IActivationFactory_iface;
diff --git a/dlls/twinapi.appcore/main.c b/dlls/twinapi.appcore/main.c
index 0021499dfae..8ca3023e746 100644
--- a/dlls/twinapi.appcore/main.c
+++ b/dlls/twinapi.appcore/main.c
@@ -77,6 +77,9 @@ HRESULT WINAPI DllGetActivationFactory( HSTRING classid, IActivationFactory **fa
         IActivationFactory_QueryInterface( advertising_manager_factory, &IID_IActivationFactory, (void **)factory );
     else if (!wcscmp( buffer, RuntimeClass_Windows_UI_ViewManagement_ApplicationView ))
         IActivationFactory_QueryInterface( application_view_factory, &IID_IActivationFactory, (void **)factory );
+    else if (!wcscmp( buffer, RuntimeClass_Windows_ApplicationModel_DataTransfer_DataTransferManager ))
+        IActivationFactory_QueryInterface( data_transfer_manager_statics_factory, &IID_IActivationFactory, (void **)factory );
+
     else if (!wcscmp( buffer, RuntimeClass_Windows_ApplicationModel_Core_CoreApplication ))
         IActivationFactory_QueryInterface( core_application_factory, &IID_IActivationFactory, (void **)factory );
 
diff --git a/dlls/twinapi.appcore/private.h b/dlls/twinapi.appcore/private.h
index 8439c983cb5..72f1371b086 100644
--- a/dlls/twinapi.appcore/private.h
+++ b/dlls/twinapi.appcore/private.h
@@ -26,6 +26,7 @@
 #include "winstring.h"
 #include "appnotify.h"
 #include "activation.h"
+#include "shlobj.h"
 
 #define WIDL_using_Windows_Foundation
 #define WIDL_using_Windows_Foundation_Collections
@@ -38,6 +39,8 @@
 #include "windows.system.userprofile.h"
 #define WIDL_using_Windows_UI_ViewManagement
 #include "windows.ui.viewmanagement.h"
+#define WIDL_using_Windows_ApplicationModel_DataTransfer
+#include "windows.applicationmodel.datatransfer.h"
 #define WIDL_using_Windows_ApplicationModel_Core
 #include "windows.applicationmodel.core.h"
 
@@ -47,6 +50,7 @@ extern IActivationFactory *application_view_factory;
 extern IActivationFactory *client_device_information_factory;
 extern IActivationFactory *analytics_info_factory;
 extern IActivationFactory *advertising_manager_factory;
+extern IActivationFactory *data_transfer_manager_statics_factory;
 extern IActivationFactory *core_application_factory;
 
 #define DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from, iface_mem, expr )             \
diff --git a/dlls/windows.devices.enumeration/information.c b/dlls/windows.devices.enumeration/information.c
index 0620975e4cb..5b41c44c6f1 100644
--- a/dlls/windows.devices.enumeration/information.c
+++ b/dlls/windows.devices.enumeration/information.c
@@ -353,3 +353,15 @@ HRESULT device_information_create( const DEV_OBJECT *obj, IDeviceInformation **i
     TRACE( "created DeviceInformation %p\n", impl );
     return S_OK;
 }
+
+HRESULT async( IUnknown *invoker, IUnknown *param, PROPVARIANT *result, BOOL called_async )
+{
+    HRESULT hr;
+
+    TRACE( "invoker %p, param %p, result %p\n", invoker, param, result );
+
+    result->vt = VT_UNKNOWN;
+    result->punkVal = (IUnknown *)param;
+
+    return S_OK;
+}
\ No newline at end of file
diff --git a/dlls/windows.devices.enumeration/main.c b/dlls/windows.devices.enumeration/main.c
index 081260da759..7062e29091b 100644
--- a/dlls/windows.devices.enumeration/main.c
+++ b/dlls/windows.devices.enumeration/main.c
@@ -32,6 +32,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(enumeration);
 
+DEFINE_ASYNC_COMPLETED_HANDLER( async_iinspectable_handler, IAsyncOperationCompletedHandler_IInspectable, IAsyncOperation_IInspectable )
+
 struct devquery_params
 {
     IUnknown IUnknown_iface;
@@ -891,9 +893,52 @@ static HRESULT WINAPI device_statics2_CreateFromIdAsync( IDeviceInformationStati
                                                          IIterable_HSTRING *additional_properties, DeviceInformationKind kind,
                                                          IAsyncOperation_DeviceInformation **async_operation )
 {
-    FIXME( "iface %p, device_id %s, additional_properties %p, kind %u, async_operation %p stub!\n",
-            iface, debugstr_hstring( device_id ), additional_properties, kind, async_operation );
-    return E_NOTIMPL;
+    const DEVPROPCOMPKEY device_iface_default_props[] = {
+        { DEVPKEY_DeviceInterface_Enabled, DEVPROP_STORE_SYSTEM, NULL },
+        { DEVPKEY_Device_InstanceId, DEVPROP_STORE_SYSTEM, NULL },
+    };
+    DEVPROPCOMPKEY *prop_keys = NULL;
+    struct aqs_expr *expr = NULL;
+    ULONG prop_keys_len = 0;
+    IUnknown *params;
+    HSTRING filter;
+    HRESULT hr;
+    DWORD asyncRes;
+
+    IAsyncOperation_IInspectable *op = NULL;
+    IVectorView_DeviceInformation *vec = NULL;
+    IDeviceInformation *dev = NULL;
+
+    WindowsCreateString( L"", wcslen( L""), &filter );
+
+    TRACE( "iface %p, device_id %s, additional_properties %p, kind %d, async_operation %p\n", iface, debugstr_hstring(device_id), additional_properties, kind, async_operation );
+
+    if (FAILED(hr = devpropcompkeys_init( &prop_keys, &prop_keys_len, device_iface_default_props, ARRAY_SIZE( device_iface_default_props ) ))) goto failed;
+    if (additional_properties && FAILED(hr = devpropcompkeys_append_names( &prop_keys, &prop_keys_len, additional_properties ))) goto failed;
+    if (FAILED(hr = aqs_parse_query(WindowsGetStringRawBuffer( filter, NULL ), &expr, NULL ))) goto failed;
+    if (FAILED(hr = devquery_params_create( 8, expr, prop_keys, prop_keys_len, &params ))) goto failed;
+
+    hr = async_operation_inspectable_create( &IID_IAsyncOperation_DeviceInformationCollection, (IUnknown *)iface, params, find_all_async, &op );
+    IUnknown_Release( params );
+
+    asyncRes = await_IAsyncOperation_IInspectable( op, INFINITE );
+    if ( asyncRes )
+        return E_UNEXPECTED;
+
+    hr = IAsyncOperation_IInspectable_GetResults( op, (IInspectable **)&vec );
+    if (FAILED(hr)) return hr;
+
+    hr = IVectorView_DeviceInformation_GetAt( vec, 0, &dev );
+    if (FAILED(hr)) return hr;
+
+    hr = async_operation_inspectable_create( &IID_IAsyncOperation_DeviceInformation, (IUnknown *)iface, (IUnknown *)dev, async, (IAsyncOperation_IInspectable **)async_operation );
+
+    return hr;
+
+failed:
+    free( prop_keys );
+    free_aqs_expr( expr );
+    return hr;
 }
 
 static HRESULT WINAPI device_statics2_FindAllAsync( IDeviceInformationStatics2 *iface, HSTRING filter,
diff --git a/dlls/windows.devices.enumeration/private.h b/dlls/windows.devices.enumeration/private.h
index 033e866b506..ca2c1c30d0a 100644
--- a/dlls/windows.devices.enumeration/private.h
+++ b/dlls/windows.devices.enumeration/private.h
@@ -67,6 +67,7 @@ extern HRESULT async_action_create( IUnknown *invoker, async_operation_callback
 
 extern HRESULT vector_create( const struct vector_iids *iids, void **out );
 extern HRESULT device_information_create( const DEV_OBJECT *obj, IDeviceInformation **info );
+extern HRESULT async( IUnknown *invoker, IUnknown *param, PROPVARIANT *result, BOOL called_async );
 
 #define DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from, iface_mem, expr )             \
     static inline impl_type *impl_from( iface_type *iface )                                        \
@@ -108,4 +109,85 @@ extern HRESULT device_information_create( const DEV_OBJECT *obj, IDeviceInformat
 #define DEFINE_IINSPECTABLE_OUTER( pfx, iface_type, impl_type, outer_iface )                       \
     DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from_##iface_type, iface_type##_iface, impl->outer_iface )
 
+#define DEFINE_ASYNC_COMPLETED_HANDLER( name, iface_type, async_type )                              \
+    struct name                                                                                     \
+    {                                                                                               \
+        iface_type iface_type##_iface;                                                              \
+        LONG refcount;                                                                              \
+        BOOL invoked;                                                                               \
+        HANDLE event;                                                                               \
+    };                                                                                              \
+                                                                                                    \
+    static HRESULT WINAPI name##_QueryInterface( iface_type *iface, REFIID iid, void **out )        \
+    {                                                                                               \
+        if (IsEqualGUID( iid, &IID_IUnknown ) || IsEqualGUID( iid, &IID_IAgileObject ) ||           \
+            IsEqualGUID( iid, &IID_##iface_type ))                                                  \
+        {                                                                                           \
+            IUnknown_AddRef( iface );                                                               \
+            *out = iface;                                                                           \
+            return S_OK;                                                                            \
+        }                                                                                           \
+                                                                                                    \
+        *out = NULL;                                                                                \
+        return E_NOINTERFACE;                                                                       \
+    }                                                                                               \
+                                                                                                    \
+    static ULONG WINAPI name##_AddRef( iface_type *iface )                                          \
+    {                                                                                               \
+        struct name *impl = CONTAINING_RECORD( iface, struct name, iface_type##_iface );            \
+        return InterlockedIncrement( &impl->refcount );                                             \
+    }                                                                                               \
+                                                                                                    \
+    static ULONG WINAPI name##_Release( iface_type *iface )                                         \
+    {                                                                                               \
+        struct name *impl = CONTAINING_RECORD( iface, struct name, iface_type##_iface );            \
+        ULONG ref = InterlockedDecrement( &impl->refcount );                                        \
+        if (!ref) free( impl );                                                                     \
+        return ref;                                                                                 \
+    }                                                                                               \
+                                                                                                    \
+    static HRESULT WINAPI name##_Invoke( iface_type *iface, async_type *async, AsyncStatus status ) \
+    {                                                                                               \
+        struct name *impl = CONTAINING_RECORD( iface, struct name, iface_type##_iface );            \
+        impl->invoked = TRUE;                                                                       \
+        if (impl->event) SetEvent( impl->event );                                                   \
+        return S_OK;                                                                                \
+    }                                                                                               \
+                                                                                                    \
+    static iface_type##Vtbl name##_vtbl =                                                           \
+    {                                                                                               \
+        name##_QueryInterface,                                                                      \
+        name##_AddRef,                                                                              \
+        name##_Release,                                                                             \
+        name##_Invoke,                                                                              \
+    };                                                                                              \
+                                                                                                    \
+    static iface_type *name##_create( HANDLE event )                                                \
+    {                                                                                               \
+        struct name *impl;                                                                          \
+                                                                                                    \
+        if (!(impl = calloc( 1, sizeof(*impl) ))) return NULL;                                      \
+        impl->iface_type##_iface.lpVtbl = &name##_vtbl;                                             \
+        impl->event = event;                                                                        \
+        impl->refcount = 1;                                                                         \
+                                                                                                    \
+        return &impl->iface_type##_iface;                                                           \
+    }                                                                                               \
+                                                                                                    \
+    static DWORD await_##async_type( async_type *async, DWORD timeout )                             \
+    {                                                                                               \
+        iface_type *handler;                                                                        \
+        HANDLE event;                                                                               \
+        DWORD ret;                                                                                  \
+                                                                                                    \
+        event = CreateEventW( NULL, FALSE, FALSE, NULL );                                           \
+        handler = name##_create( event );                                                           \
+        async_type##_put_Completed( async, handler );                                               \
+        ret = WaitForSingleObject( event, timeout );                                                \
+        CloseHandle( event );                                                                       \
+        iface_type##_Release( handler );                                                            \
+                                                                                                    \
+        return ret;                                                                                 \
+    }
+
 #endif
diff --git a/dlls/windows.ui.core.textinput/Makefile.in b/dlls/windows.ui.core.textinput/Makefile.in
index 38d07a5a5c0..4ed9c6100a6 100644
--- a/dlls/windows.ui.core.textinput/Makefile.in
+++ b/dlls/windows.ui.core.textinput/Makefile.in
@@ -4,5 +4,8 @@ IMPORTS = combase
 SOURCES = \
 	classes.idl \
 	main.c \
+	services.c \
+	inputview.c \
+	weakref.c \
 	vector.c \
-	weakref.c
+	editcontext.c
diff --git a/dlls/windows.ui.core.textinput/classes.idl b/dlls/windows.ui.core.textinput/classes.idl
index 71c1bf98634..720eaafa8a7 100644
--- a/dlls/windows.ui.core.textinput/classes.idl
+++ b/dlls/windows.ui.core.textinput/classes.idl
@@ -1,7 +1,7 @@
 /*
  * Runtime Classes for windows.ui.core.textinput.dll
  *
- * Copyright 2025 Zhiyi Zhang for CodeWeavers
+ * Written by Weather
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -21,8 +21,19 @@
 #pragma makedep register
 #pragma winrt ns_prefix
 
+import "inspectable.idl";
+import "asyncinfo.idl";
+import "eventtoken.idl";
+import "windows.foundation.idl";
+import "windowscontracts.idl";
+import "windows.system.idl";
+import "windows.ui.text.core.idl";
 import "windows.ui.viewmanagement.core.idl";
 
 namespace Windows.UI.ViewManagement.Core {
     runtimeclass CoreInputView;
 }
+
+namespace Windows.UI.Text.Core {
+    runtimeclass CoreTextServicesManager;
+}
diff --git a/dlls/windows.ui.core.textinput/editcontext.c b/dlls/windows.ui.core.textinput/editcontext.c
new file mode 100644
index 00000000000..ef2932677da
--- /dev/null
+++ b/dlls/windows.ui.core.textinput/editcontext.c
@@ -0,0 +1,325 @@
+/* WinRT Windows.UI.Text.Core.CoreTextEditContext Implementation
+ *
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "editcontext.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(textinput);
+
+static inline struct core_text_edit_context *impl_from_ICoreTextEditContext( ICoreTextEditContext *iface )
+{
+    return CONTAINING_RECORD( iface, struct core_text_edit_context, ICoreTextEditContext_iface );
+}
+
+static HRESULT WINAPI core_text_edit_context_QueryInterface( ICoreTextEditContext *iface, REFIID iid, void **out )
+{
+    struct core_text_edit_context *impl = impl_from_ICoreTextEditContext( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_ICoreTextEditContext ))
+    {
+        *out = &impl->ICoreTextEditContext_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI core_text_edit_context_AddRef( ICoreTextEditContext *iface )
+{
+    struct core_text_edit_context *impl = impl_from_ICoreTextEditContext( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI core_text_edit_context_Release( ICoreTextEditContext *iface )
+{
+    struct core_text_edit_context *impl = impl_from_ICoreTextEditContext( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI core_text_edit_context_GetIids( ICoreTextEditContext *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_edit_context_GetRuntimeClassName( ICoreTextEditContext *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_edit_context_GetTrustLevel( ICoreTextEditContext *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p not stub!\n", iface, trust_level );
+    *trust_level = FullTrust;
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_get_Name(ICoreTextEditContext *iface, HSTRING *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_edit_context_put_Name(ICoreTextEditContext *iface, HSTRING value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, (void*)value);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_edit_context_get_InputScope(ICoreTextEditContext *iface, CoreTextInputScope *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_edit_context_put_InputScope(ICoreTextEditContext *iface, CoreTextInputScope value)
+{
+    FIXME("iface %p, value %d stub!\n", iface, (int)value);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_edit_context_get_IsReadOnly(ICoreTextEditContext *iface, boolean *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_edit_context_put_IsReadOnly(ICoreTextEditContext *iface, boolean value)
+{
+    FIXME("iface %p, value %d stub!\n", iface, (int)value);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_edit_context_get_InputPaneDisplayPolicy(ICoreTextEditContext *iface, CoreTextInputPaneDisplayPolicy *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_edit_context_put_InputPaneDisplayPolicy(ICoreTextEditContext *iface, CoreTextInputPaneDisplayPolicy value)
+{
+    FIXME("iface %p, value %d stub!\n", iface, (int)value);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_add_TextRequested(ICoreTextEditContext *iface, ITypedEventHandler_CoreTextEditContext_CoreTextTextRequestedEventArgs *handler, EventRegistrationToken *cookie)
+{
+    FIXME("iface %p, handler %p, cookie %p stub!\n", iface, handler, cookie);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_remove_TextRequested(ICoreTextEditContext *iface, EventRegistrationToken cookie)
+{
+    FIXME("iface %p, cookie %p stub!\n", iface, (void*)&cookie);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_add_SelectionRequested(ICoreTextEditContext *iface, ITypedEventHandler_CoreTextEditContext_CoreTextSelectionRequestedEventArgs *handler, EventRegistrationToken *cookie)
+{
+    FIXME("iface %p, handler %p, cookie %p stub!\n", iface, handler, cookie);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_remove_SelectionRequested(ICoreTextEditContext *iface, EventRegistrationToken cookie)
+{
+    FIXME("iface %p, cookie %p stub!\n", iface, (void*)&cookie);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_add_LayoutRequested(ICoreTextEditContext *iface, ITypedEventHandler_CoreTextEditContext_CoreTextLayoutRequestedEventArgs *handler, EventRegistrationToken *cookie)
+{
+    FIXME("iface %p, handler %p, cookie %p stub!\n", iface, handler, cookie);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_remove_LayoutRequested(ICoreTextEditContext *iface, EventRegistrationToken cookie)
+{
+    FIXME("iface %p, cookie %p stub!\n", iface, (void*)&cookie);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_add_TextUpdating(ICoreTextEditContext *iface, ITypedEventHandler_CoreTextEditContext_CoreTextTextUpdatingEventArgs *handler, EventRegistrationToken *cookie)
+{
+    FIXME("iface %p, handler %p, cookie %p stub!\n", iface, handler, cookie);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_remove_TextUpdating(ICoreTextEditContext *iface, EventRegistrationToken cookie)
+{
+    FIXME("iface %p, cookie %p stub!\n", iface, (void*)&cookie);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_add_SelectionUpdating(ICoreTextEditContext *iface, ITypedEventHandler_CoreTextEditContext_CoreTextSelectionUpdatingEventArgs *handler, EventRegistrationToken *cookie)
+{
+    FIXME("iface %p, handler %p, cookie %p stub!\n", iface, handler, cookie);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_remove_SelectionUpdating(ICoreTextEditContext *iface, EventRegistrationToken cookie)
+{
+    FIXME("iface %p, cookie %p stub!\n", iface, (void*)&cookie);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_add_FormatUpdating(ICoreTextEditContext *iface, ITypedEventHandler_CoreTextEditContext_CoreTextFormatUpdatingEventArgs *handler, EventRegistrationToken *cookie)
+{
+    FIXME("iface %p, FormatUpdating add stub!\n", iface);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_remove_FormatUpdating(ICoreTextEditContext *iface, EventRegistrationToken cookie)
+{
+    FIXME("iface %p, FormatUpdating remove stub!\n", iface);
+    return S_OK;
+}
+
+/* CompositionStarted (flattened form) */
+static HRESULT WINAPI core_text_edit_context_add_CompositionStarted(ICoreTextEditContext *iface, ITypedEventHandler_CoreTextEditContext_CoreTextCompositionStartedEventArgs *handler, EventRegistrationToken *cookie)
+{
+    FIXME("iface %p, CompositionStarted add stub!\n", iface);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_remove_CompositionStarted(ICoreTextEditContext *iface, EventRegistrationToken cookie)
+{
+    FIXME("iface %p, CompositionStarted remove stub!\n", iface);
+    return S_OK;
+}
+
+/* CompositionCompleted (flattened form) */
+static HRESULT WINAPI core_text_edit_context_add_CompositionCompleted(ICoreTextEditContext *iface, ITypedEventHandler_CoreTextEditContext_CoreTextCompositionCompletedEventArgs *handler, EventRegistrationToken *cookie)
+{
+    FIXME("iface %p, CompositionCompleted add stub!\n", iface);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_remove_CompositionCompleted(ICoreTextEditContext *iface, EventRegistrationToken cookie)
+{
+    FIXME("iface %p, CompositionCompleted remove stub!\n", iface);
+    return S_OK;
+}
+
+/* FocusRemoved (flattened form) */
+static HRESULT WINAPI core_text_edit_context_add_FocusRemoved(ICoreTextEditContext *iface, ITypedEventHandler_CoreTextEditContext_IInspectable *handler, EventRegistrationToken *cookie)
+{
+    FIXME("iface %p, FocusRemoved add stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_edit_context_remove_FocusRemoved(ICoreTextEditContext *iface, EventRegistrationToken cookie)
+{
+    FIXME("iface %p, FocusRemoved remove stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+/* Notifications */
+static HRESULT WINAPI core_text_edit_context_NotifyFocusEnter(ICoreTextEditContext *iface)
+{
+    FIXME("iface %p, NotifyFocusEnter stub!\n", iface);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_NotifyFocusLeave(ICoreTextEditContext *iface)
+{
+    FIXME("iface %p, NotifyFocusLeave stub!\n", iface);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_NotifyTextChanged(ICoreTextEditContext *iface,
+                                                               CoreTextRange modifiedRange,
+                                                               INT32 newLength,
+                                                               CoreTextRange newSelection)
+{
+    FIXME("iface %p, modifiedRange %p, newLength %d, newSelection %p stub!\n",
+          iface, (void*)&modifiedRange, (int)newLength, (void*)&newSelection);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_NotifySelectionChanged(ICoreTextEditContext *iface,
+                                                                    CoreTextRange selection)
+{
+    FIXME("iface %p, selection %p stub!\n", iface, (void*)&selection);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_text_edit_context_NotifyLayoutChanged(ICoreTextEditContext *iface)
+{
+    FIXME("iface %p, NotifyLayoutChanged stub!\n", iface);
+    return S_OK;
+}
+
+struct ICoreTextEditContextVtbl core_text_edit_context_vtbl =
+{
+    /* IUnknown */
+    core_text_edit_context_QueryInterface,
+    core_text_edit_context_AddRef,
+    core_text_edit_context_Release,
+
+    /* IInspectable */
+    core_text_edit_context_GetIids,
+    core_text_edit_context_GetRuntimeClassName,
+    core_text_edit_context_GetTrustLevel,
+
+    /* ICoreTextEditContext (in IDL order) */
+    core_text_edit_context_get_Name,                      /* propget Name */
+    core_text_edit_context_put_Name,                      /* propput Name */
+    core_text_edit_context_get_InputScope,                /* propget InputScope */
+    core_text_edit_context_put_InputScope,                /* propput InputScope */
+    core_text_edit_context_get_IsReadOnly,                /* propget IsReadOnly */
+    core_text_edit_context_put_IsReadOnly,                /* propput IsReadOnly */
+    core_text_edit_context_get_InputPaneDisplayPolicy,    /* propget InputPaneDisplayPolicy */
+    core_text_edit_context_put_InputPaneDisplayPolicy,    /* propput InputPaneDisplayPolicy */
+
+    core_text_edit_context_add_TextRequested,             /* eventadd TextRequested */
+    core_text_edit_context_remove_TextRequested,          /* eventremove TextRequested */
+    core_text_edit_context_add_SelectionRequested,        /* eventadd SelectionRequested */
+    core_text_edit_context_remove_SelectionRequested,     /* eventremove SelectionRequested */
+    core_text_edit_context_add_LayoutRequested,           /* eventadd LayoutRequested */
+    core_text_edit_context_remove_LayoutRequested,        /* eventremove LayoutRequested */
+    core_text_edit_context_add_TextUpdating,              /* eventadd TextUpdating */
+    core_text_edit_context_remove_TextUpdating,           /* eventremove TextUpdating */
+    core_text_edit_context_add_SelectionUpdating,         /* eventadd SelectionUpdating */
+    core_text_edit_context_remove_SelectionUpdating,      /* eventremove SelectionUpdating */
+    core_text_edit_context_add_FormatUpdating,            /* eventadd FormatUpdating */
+    core_text_edit_context_remove_FormatUpdating,         /* eventremove FormatUpdating */
+    core_text_edit_context_add_CompositionStarted,        /* eventadd CompositionStarted */
+    core_text_edit_context_remove_CompositionStarted,     /* eventremove CompositionStarted */
+    core_text_edit_context_add_CompositionCompleted,      /* eventadd CompositionCompleted */
+    core_text_edit_context_remove_CompositionCompleted,   /* eventremove CompositionCompleted */
+    core_text_edit_context_add_FocusRemoved,              /* eventadd FocusRemoved */
+    core_text_edit_context_remove_FocusRemoved,           /* eventremove FocusRemoved */
+    core_text_edit_context_NotifyFocusEnter,              /* NotifyFocusEnter */
+    core_text_edit_context_NotifyFocusLeave,              /* NotifyFocusLeave */
+    core_text_edit_context_NotifyTextChanged,             /* NotifyTextChanged */
+    core_text_edit_context_NotifySelectionChanged,        /* NotifySelectionChanged */
+    core_text_edit_context_NotifyLayoutChanged            /* NotifyLayoutChanged */
+};
diff --git a/dlls/windows.ui.core.textinput/editcontext.h b/dlls/windows.ui.core.textinput/editcontext.h
new file mode 100644
index 00000000000..b08c0afce26
--- /dev/null
+++ b/dlls/windows.ui.core.textinput/editcontext.h
@@ -0,0 +1,31 @@
+/* WinRT Windows.UI.Text.Core.CoreTextEditContext Implementation
+ *
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef EDITCONTEXT_H
+#define EDITCONTEXT_H
+
+#include "private.h"
+
+struct core_text_edit_context
+{
+    ICoreTextEditContext ICoreTextEditContext_iface;
+    LONG ref;
+};
+
+#endif
\ No newline at end of file
diff --git a/dlls/windows.ui.core.textinput/inputview.c b/dlls/windows.ui.core.textinput/inputview.c
new file mode 100644
index 00000000000..a38c2f95735
--- /dev/null
+++ b/dlls/windows.ui.core.textinput/inputview.c
@@ -0,0 +1,482 @@
+/* WinRT Windows.UI.ViewManagement.Core.CoreInputView Implementation
+ *
+ * Copyright 2025 Zhiyi Zhang for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+#include "weakref.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(coreinputview);
+
+struct core_input_view
+{
+    ICoreInputView ICoreInputView_iface;
+    ICoreInputView2 ICoreInputView2_iface;
+    ICoreInputView3 ICoreInputView3_iface;
+    ICoreInputView4 ICoreInputView4_iface;
+    struct weak_reference_source weak_reference_source;
+};
+
+static inline struct core_input_view *impl_from_ICoreInputView(ICoreInputView *iface)
+{
+    return CONTAINING_RECORD(iface, struct core_input_view, ICoreInputView_iface);
+}
+
+static HRESULT WINAPI core_input_view_QueryInterface(ICoreInputView *iface, REFIID iid, void **out)
+{
+    struct core_input_view *impl = impl_from_ICoreInputView(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    *out = NULL;
+
+    if (IsEqualGUID(iid, &IID_IUnknown)
+        || IsEqualGUID(iid, &IID_IInspectable)
+        || IsEqualGUID(iid, &IID_IAgileObject)
+        || IsEqualGUID(iid, &IID_ICoreInputView))
+    {
+        *out = &impl->ICoreInputView_iface;
+    }
+    else if (IsEqualGUID(iid, &IID_ICoreInputView2))
+    {
+        *out = &impl->ICoreInputView2_iface;
+    }
+    else if (IsEqualGUID(iid, &IID_ICoreInputView3))
+    {
+        *out = &impl->ICoreInputView3_iface;
+    }
+    else if (IsEqualGUID(iid, &IID_ICoreInputView4))
+    {
+        *out = &impl->ICoreInputView4_iface;
+    }
+    else if (IsEqualGUID(iid, &IID_IWeakReferenceSource))
+    {
+        *out = &impl->weak_reference_source.IWeakReferenceSource_iface;
+    }
+
+    if (*out)
+    {
+        IUnknown_AddRef((IUnknown *)*out);
+        return S_OK;
+    }
+
+    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI core_input_view_AddRef(ICoreInputView *iface)
+{
+    struct core_input_view *impl = impl_from_ICoreInputView(iface);
+    ULONG ref = weak_reference_strong_add_ref(&impl->weak_reference_source);
+    TRACE("iface %p, ref %lu.\n", iface, ref);
+    return ref;
+}
+
+static ULONG WINAPI core_input_view_Release(ICoreInputView *iface)
+{
+    struct core_input_view *impl = impl_from_ICoreInputView(iface);
+    ULONG ref = weak_reference_strong_release(&impl->weak_reference_source);
+
+    TRACE("iface %p, ref %lu.\n", iface, ref);
+
+    if (!ref)
+        free(impl);
+    return ref;
+}
+
+static HRESULT WINAPI core_input_view_GetIids(ICoreInputView *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_input_view_GetRuntimeClassName(ICoreInputView *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_input_view_GetTrustLevel(ICoreInputView *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_input_view_add_OcclusionsChanged(ICoreInputView *iface,
+                                                            ITypedEventHandler_CoreInputView_CoreInputViewOcclusionsChangedEventArgs *handler,
+                                                            EventRegistrationToken *token)
+{
+    FIXME("iface %p, handler %p, token %p stub!\n", iface, handler, token);
+    token->value = 0xdeadbeef;
+    return S_OK;
+}
+
+static HRESULT WINAPI core_input_view_remove_OcclusionsChanged(ICoreInputView *iface,
+                                                               EventRegistrationToken token)
+{
+    FIXME("iface %p, token %I64x stub!\n", iface, token.value);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_input_view_GetCoreInputViewOcclusions(ICoreInputView *iface,
+                                                                 IVectorView_CoreInputViewOcclusion **result)
+{
+    static const struct vector_iids iids =
+    {
+        .vector = &IID_IVector_CoreInputViewOcclusion,
+        .view = &IID_IVectorView_CoreInputViewOcclusion,
+        .iterable = &IID_IIterable_CoreInputViewOcclusion,
+        .iterator = &IID_IIterator_CoreInputViewOcclusion,
+    };
+    IVector_CoreInputViewOcclusion *vector;
+    HRESULT hr;
+
+    FIXME("iface %p, result %p stub!\n", iface, result);
+
+    if (SUCCEEDED(hr = vector_create(&iids, (void **)&vector)))
+    {
+        hr = IVector_CoreInputViewOcclusion_GetView(vector, result);
+        IVector_CoreInputViewOcclusion_Release(vector);
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI core_input_view_TryShowPrimaryView(ICoreInputView *iface, boolean *result)
+{
+    FIXME("iface %p, boolean %p stub!\n", iface, result);
+    *result = TRUE;
+    return S_OK;
+}
+
+static HRESULT WINAPI core_input_view_TryHidePrimaryView(ICoreInputView *iface, boolean *result)
+{
+    FIXME("iface %p, boolean %p stub!\n", iface, result);
+    *result = TRUE;
+    return S_OK;
+}
+
+static const struct ICoreInputViewVtbl core_input_view_vtbl =
+{
+    core_input_view_QueryInterface,
+    core_input_view_AddRef,
+    core_input_view_Release,
+    /* IInspectable methods */
+    core_input_view_GetIids,
+    core_input_view_GetRuntimeClassName,
+    core_input_view_GetTrustLevel,
+    /* ICoreInputView methods */
+    core_input_view_add_OcclusionsChanged,
+    core_input_view_remove_OcclusionsChanged,
+    core_input_view_GetCoreInputViewOcclusions,
+    core_input_view_TryShowPrimaryView,
+    core_input_view_TryHidePrimaryView,
+};
+
+DEFINE_IINSPECTABLE(core_input_view2, ICoreInputView2, struct core_input_view, ICoreInputView_iface)
+
+static HRESULT WINAPI core_input_view2_add_XYFocusTransferringFromPrimaryView(ICoreInputView2 *iface,
+                                                                              ITypedEventHandler_CoreInputView_CoreInputViewTransferringXYFocusEventArgs *handler,
+                                                                              EventRegistrationToken *token)
+{
+    FIXME("iface %p, handler %p, token %p stub!\n", iface, handler, token);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_input_view2_remove_XYFocusTransferringFromPrimaryView(ICoreInputView2 *iface,
+                                                                                 EventRegistrationToken token)
+{
+    FIXME("iface %p, token %I64x stub!\n", iface, token.value);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_input_view2_add_XYFocusTransferredToPrimaryView(ICoreInputView2 *iface,
+                                                                           ITypedEventHandler_CoreInputView_IInspectable *handler,
+                                                                           EventRegistrationToken *token)
+{
+    FIXME("iface %p, handler %p, token %p stub!\n", iface, handler, token);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_input_view2_remove_XYFocusTransferredToPrimaryView(ICoreInputView2 *iface,
+                                                                              EventRegistrationToken token)
+{
+    FIXME("iface %p, token %I64x stub!\n", iface, token.value);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_input_view2_TryTransferXYFocusToPrimaryView(ICoreInputView2 *iface,
+                                                                       Rect origin,
+                                                                       CoreInputViewXYFocusTransferDirection direction,
+                                                                       boolean *result)
+{
+    FIXME("iface %p, origin (%f,%f %fx%f), direction %d, result %p stub!\n", iface, origin.X,
+          origin.Y, origin.Width, origin.Height, direction, result);
+    return E_NOTIMPL;
+}
+
+static const struct ICoreInputView2Vtbl core_input_view2_vtbl =
+{
+    core_input_view2_QueryInterface,
+    core_input_view2_AddRef,
+    core_input_view2_Release,
+    /* IInspectable methods */
+    core_input_view2_GetIids,
+    core_input_view2_GetRuntimeClassName,
+    core_input_view2_GetTrustLevel,
+    /* ICoreInputView2 methods */
+    core_input_view2_add_XYFocusTransferringFromPrimaryView,
+    core_input_view2_remove_XYFocusTransferringFromPrimaryView,
+    core_input_view2_add_XYFocusTransferredToPrimaryView,
+    core_input_view2_remove_XYFocusTransferredToPrimaryView,
+    core_input_view2_TryTransferXYFocusToPrimaryView,
+};
+
+DEFINE_IINSPECTABLE(core_input_view3, ICoreInputView3, struct core_input_view, ICoreInputView_iface)
+
+static HRESULT WINAPI core_input_view3_TryShow(ICoreInputView3 *iface, boolean *result)
+{
+    FIXME("iface %p, result %p stub!\n", iface, result);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_input_view3_TryShowWithKind(ICoreInputView3 *iface,
+                                                       CoreInputViewKind type,
+                                                       boolean *result)
+{
+    FIXME("iface %p, type %d, result %p stub!\n", iface, type, result);
+    if ( result ) *result = TRUE;
+    return S_OK;
+}
+
+static HRESULT WINAPI core_input_view3_TryHide(ICoreInputView3 *iface, boolean *result)
+{
+    FIXME("iface %p, result %p stub!\n", iface, result);
+    if ( result ) *result = TRUE;
+    return S_OK;
+}
+
+static const struct ICoreInputView3Vtbl core_input_view3_vtbl =
+{
+    core_input_view3_QueryInterface,
+    core_input_view3_AddRef,
+    core_input_view3_Release,
+    /* IInspectable methods */
+    core_input_view3_GetIids,
+    core_input_view3_GetRuntimeClassName,
+    core_input_view3_GetTrustLevel,
+    /* ICoreInputView3 methods */
+    core_input_view3_TryShow,
+    core_input_view3_TryShowWithKind,
+    core_input_view3_TryHide,
+};
+
+DEFINE_IINSPECTABLE(core_input_view4, ICoreInputView4, struct core_input_view, ICoreInputView_iface)
+
+static HRESULT WINAPI core_input_view4_add_PrimaryViewShowing(ICoreInputView4 *iface,
+                                                              ITypedEventHandler_CoreInputView_CoreInputViewShowingEventArgs *handler,
+                                                              EventRegistrationToken *token)
+{
+    FIXME("iface %p, handler %p, token %p stub!\n", iface, handler, token);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_input_view4_remove_PrimaryViewShowing(ICoreInputView4 *iface,
+                                                                 EventRegistrationToken token)
+{
+    FIXME("iface %p, token %I64x stub!\n", iface, token.value);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_input_view4_add_PrimaryViewHiding(ICoreInputView4 *iface,
+                                                             ITypedEventHandler_CoreInputView_CoreInputViewHidingEventArgs *handler,
+                                                             EventRegistrationToken *token)
+{
+    FIXME("iface %p, handler %p, token %p stub!\n", iface, handler, token);
+    return S_OK;
+}
+
+static HRESULT WINAPI core_input_view4_remove_PrimaryViewHiding(ICoreInputView4 *iface,
+                                                                EventRegistrationToken token)
+{
+    FIXME("iface %p, token %I64x stub!\n", iface, token.value);
+    return E_NOTIMPL;
+}
+
+static const struct ICoreInputView4Vtbl core_input_view4_vtbl =
+{
+    core_input_view4_QueryInterface,
+    core_input_view4_AddRef,
+    core_input_view4_Release,
+    /* IInspectable methods */
+    core_input_view4_GetIids,
+    core_input_view4_GetRuntimeClassName,
+    core_input_view4_GetTrustLevel,
+    /* ICoreInputView4 methods */
+    core_input_view4_add_PrimaryViewShowing,
+    core_input_view4_remove_PrimaryViewShowing,
+    core_input_view4_add_PrimaryViewHiding,
+    core_input_view4_remove_PrimaryViewHiding,
+};
+
+struct core_input_view_statics
+{
+    IActivationFactory IActivationFactory_iface;
+    ICoreInputViewStatics ICoreInputViewStatics_iface;
+    LONG ref;
+};
+
+static inline struct core_input_view_statics *impl_from_IActivationFactory(IActivationFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct core_input_view_statics, IActivationFactory_iface);
+}
+
+static HRESULT WINAPI factory_QueryInterface(IActivationFactory *iface, REFIID iid, void **out)
+{
+    struct core_input_view_statics *impl = impl_from_IActivationFactory(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown)
+        || IsEqualGUID(iid, &IID_IInspectable)
+        || IsEqualGUID(iid, &IID_IActivationFactory))
+    {
+        *out = &impl->IActivationFactory_iface;
+        IActivationFactory_AddRef(*out);
+        return S_OK;
+    }
+
+    if (IsEqualGUID(iid, &IID_ICoreInputViewStatics))
+    {
+        *out = &impl->ICoreInputViewStatics_iface;
+        ICoreInputViewStatics_AddRef(*out);
+        return S_OK;
+    }
+
+    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI factory_AddRef(IActivationFactory *iface)
+{
+    struct core_input_view_statics *impl = impl_from_IActivationFactory(iface);
+    ULONG ref = InterlockedIncrement(&impl->ref);
+    TRACE("iface %p, ref %lu.\n", iface, ref);
+    return ref;
+}
+
+static ULONG WINAPI factory_Release(IActivationFactory *iface)
+{
+    struct core_input_view_statics *impl = impl_from_IActivationFactory(iface);
+    ULONG ref = InterlockedDecrement(&impl->ref);
+    TRACE("iface %p, ref %lu.\n", iface, ref);
+    return ref;
+}
+
+static HRESULT WINAPI factory_GetIids(IActivationFactory *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetRuntimeClassName(IActivationFactory *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetTrustLevel(IActivationFactory *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_ActivateInstance(IActivationFactory *iface, IInspectable **instance)
+{
+    FIXME("iface %p, instance %p stub!\n", iface, instance);
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl factory_vtbl =
+{
+    factory_QueryInterface,
+    factory_AddRef,
+    factory_Release,
+    /* IInspectable methods */
+    factory_GetIids,
+    factory_GetRuntimeClassName,
+    factory_GetTrustLevel,
+    /* IActivationFactory methods */
+    factory_ActivateInstance,
+};
+
+DEFINE_IINSPECTABLE(core_input_view_statics, ICoreInputViewStatics, struct core_input_view_statics,
+                    IActivationFactory_iface)
+
+static HRESULT WINAPI core_input_view_statics_GetForCurrentView(ICoreInputViewStatics *iface,
+                                                                ICoreInputView **result)
+{
+    struct core_input_view *view;
+    HRESULT hr;
+
+    FIXME("iface %p, result %p semi-stub.\n", iface, result);
+
+    if (!(view = calloc(1, sizeof(*view))))
+    {
+        *result = NULL;
+        return E_OUTOFMEMORY;
+    }
+
+    view->ICoreInputView_iface.lpVtbl = &core_input_view_vtbl;
+    view->ICoreInputView2_iface.lpVtbl = &core_input_view2_vtbl;
+    view->ICoreInputView3_iface.lpVtbl = &core_input_view3_vtbl;
+    view->ICoreInputView4_iface.lpVtbl = &core_input_view4_vtbl;
+
+    if (FAILED(hr = weak_reference_source_init(&view->weak_reference_source,
+                                               (IUnknown *)&view->ICoreInputView_iface)))
+    {
+        *result = NULL;
+        free(view);
+        return hr;
+    }
+
+    *result = &view->ICoreInputView_iface;
+    return S_OK;
+}
+
+static const struct ICoreInputViewStaticsVtbl core_input_view_statics_vtbl =
+{
+    core_input_view_statics_QueryInterface,
+    core_input_view_statics_AddRef,
+    core_input_view_statics_Release,
+    /* IInspectable methods */
+    core_input_view_statics_GetIids,
+    core_input_view_statics_GetRuntimeClassName,
+    core_input_view_statics_GetTrustLevel,
+    /* ICoreInputViewStatics methods */
+    core_input_view_statics_GetForCurrentView,
+};
+
+static struct core_input_view_statics core_input_view_statics =
+{
+    {&factory_vtbl},
+    {&core_input_view_statics_vtbl},
+    1,
+};
+
+IActivationFactory *core_input_view_factory = &core_input_view_statics.IActivationFactory_iface;
diff --git a/dlls/windows.ui.core.textinput/main.c b/dlls/windows.ui.core.textinput/main.c
index 25110e09be9..44aaa8b87e9 100644
--- a/dlls/windows.ui.core.textinput/main.c
+++ b/dlls/windows.ui.core.textinput/main.c
@@ -1,6 +1,6 @@
-/* WinRT Windows.UI.ViewManagement.Core.CoreInputView Implementation
+/* WinRT Windows.UI.Core.TextInput Implementation
  *
- * Copyright 2025 Zhiyi Zhang for CodeWeavers
+ * Written by Weather
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -19,481 +19,29 @@
 
 #include "initguid.h"
 #include "private.h"
-#include "weakref.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(coreinputview);
+WINE_DEFAULT_DEBUG_CHANNEL(textinput);
 
-struct core_input_view
+HRESULT WINAPI DllGetClassObject( REFCLSID clsid, REFIID riid, void **out )
 {
-    ICoreInputView ICoreInputView_iface;
-    ICoreInputView2 ICoreInputView2_iface;
-    ICoreInputView3 ICoreInputView3_iface;
-    ICoreInputView4 ICoreInputView4_iface;
-    struct weak_reference_source weak_reference_source;
-};
-
-static inline struct core_input_view *impl_from_ICoreInputView(ICoreInputView *iface)
-{
-    return CONTAINING_RECORD(iface, struct core_input_view, ICoreInputView_iface);
-}
-
-static HRESULT WINAPI core_input_view_QueryInterface(ICoreInputView *iface, REFIID iid, void **out)
-{
-    struct core_input_view *impl = impl_from_ICoreInputView(iface);
-
-    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
-
-    *out = NULL;
-
-    if (IsEqualGUID(iid, &IID_IUnknown)
-        || IsEqualGUID(iid, &IID_IInspectable)
-        || IsEqualGUID(iid, &IID_IAgileObject)
-        || IsEqualGUID(iid, &IID_ICoreInputView))
-    {
-        *out = &impl->ICoreInputView_iface;
-    }
-    else if (IsEqualGUID(iid, &IID_ICoreInputView2))
-    {
-        *out = &impl->ICoreInputView2_iface;
-    }
-    else if (IsEqualGUID(iid, &IID_ICoreInputView3))
-    {
-        *out = &impl->ICoreInputView3_iface;
-    }
-    else if (IsEqualGUID(iid, &IID_ICoreInputView4))
-    {
-        *out = &impl->ICoreInputView4_iface;
-    }
-    else if (IsEqualGUID(iid, &IID_IWeakReferenceSource))
-    {
-        *out = &impl->weak_reference_source.IWeakReferenceSource_iface;
-    }
-
-    if (*out)
-    {
-        IUnknown_AddRef((IUnknown *)*out);
-        return S_OK;
-    }
-
-    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
-    return E_NOINTERFACE;
-}
-
-static ULONG WINAPI core_input_view_AddRef(ICoreInputView *iface)
-{
-    struct core_input_view *impl = impl_from_ICoreInputView(iface);
-    ULONG ref = weak_reference_strong_add_ref(&impl->weak_reference_source);
-    TRACE("iface %p, ref %lu.\n", iface, ref);
-    return ref;
-}
-
-static ULONG WINAPI core_input_view_Release(ICoreInputView *iface)
-{
-    struct core_input_view *impl = impl_from_ICoreInputView(iface);
-    ULONG ref = weak_reference_strong_release(&impl->weak_reference_source);
-
-    TRACE("iface %p, ref %lu.\n", iface, ref);
-
-    if (!ref)
-        free(impl);
-    return ref;
-}
-
-static HRESULT WINAPI core_input_view_GetIids(ICoreInputView *iface, ULONG *iid_count, IID **iids)
-{
-    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view_GetRuntimeClassName(ICoreInputView *iface, HSTRING *class_name)
-{
-    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view_GetTrustLevel(ICoreInputView *iface, TrustLevel *trust_level)
-{
-    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view_add_OcclusionsChanged(ICoreInputView *iface,
-                                                            ITypedEventHandler_CoreInputView_CoreInputViewOcclusionsChangedEventArgs *handler,
-                                                            EventRegistrationToken *token)
-{
-    FIXME("iface %p, handler %p, token %p stub!\n", iface, handler, token);
-    token->value = 0xdeadbeef;
-    return S_OK;
-}
-
-static HRESULT WINAPI core_input_view_remove_OcclusionsChanged(ICoreInputView *iface,
-                                                               EventRegistrationToken token)
-{
-    FIXME("iface %p, token %I64x stub!\n", iface, token.value);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view_GetCoreInputViewOcclusions(ICoreInputView *iface,
-                                                                 IVectorView_CoreInputViewOcclusion **result)
-{
-    static const struct vector_iids iids =
-    {
-        .vector = &IID_IVector_CoreInputViewOcclusion,
-        .view = &IID_IVectorView_CoreInputViewOcclusion,
-        .iterable = &IID_IIterable_CoreInputViewOcclusion,
-        .iterator = &IID_IIterator_CoreInputViewOcclusion,
-    };
-    IVector_CoreInputViewOcclusion *vector;
-    HRESULT hr;
-
-    FIXME("iface %p, result %p stub!\n", iface, result);
-
-    if (SUCCEEDED(hr = vector_create(&iids, (void **)&vector)))
-    {
-        hr = IVector_CoreInputViewOcclusion_GetView(vector, result);
-        IVector_CoreInputViewOcclusion_Release(vector);
-    }
-
-    return hr;
-}
-
-static HRESULT WINAPI core_input_view_TryShowPrimaryView(ICoreInputView *iface, boolean *result)
-{
-    FIXME("iface %p, boolean %p stub!\n", iface, result);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view_TryHidePrimaryView(ICoreInputView *iface, boolean *result)
-{
-    FIXME("iface %p, boolean %p stub!\n", iface, result);
-    return E_NOTIMPL;
-}
-
-static const struct ICoreInputViewVtbl core_input_view_vtbl =
-{
-    core_input_view_QueryInterface,
-    core_input_view_AddRef,
-    core_input_view_Release,
-    /* IInspectable methods */
-    core_input_view_GetIids,
-    core_input_view_GetRuntimeClassName,
-    core_input_view_GetTrustLevel,
-    /* ICoreInputView methods */
-    core_input_view_add_OcclusionsChanged,
-    core_input_view_remove_OcclusionsChanged,
-    core_input_view_GetCoreInputViewOcclusions,
-    core_input_view_TryShowPrimaryView,
-    core_input_view_TryHidePrimaryView,
-};
-
-DEFINE_IINSPECTABLE(core_input_view2, ICoreInputView2, struct core_input_view, ICoreInputView_iface)
-
-static HRESULT WINAPI core_input_view2_add_XYFocusTransferringFromPrimaryView(ICoreInputView2 *iface,
-                                                                              ITypedEventHandler_CoreInputView_CoreInputViewTransferringXYFocusEventArgs *handler,
-                                                                              EventRegistrationToken *token)
-{
-    FIXME("iface %p, handler %p, token %p stub!\n", iface, handler, token);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view2_remove_XYFocusTransferringFromPrimaryView(ICoreInputView2 *iface,
-                                                                                 EventRegistrationToken token)
-{
-    FIXME("iface %p, token %I64x stub!\n", iface, token.value);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view2_add_XYFocusTransferredToPrimaryView(ICoreInputView2 *iface,
-                                                                           ITypedEventHandler_CoreInputView_IInspectable *handler,
-                                                                           EventRegistrationToken *token)
-{
-    FIXME("iface %p, handler %p, token %p stub!\n", iface, handler, token);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view2_remove_XYFocusTransferredToPrimaryView(ICoreInputView2 *iface,
-                                                                              EventRegistrationToken token)
-{
-    FIXME("iface %p, token %I64x stub!\n", iface, token.value);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view2_TryTransferXYFocusToPrimaryView(ICoreInputView2 *iface,
-                                                                       Rect origin,
-                                                                       CoreInputViewXYFocusTransferDirection direction,
-                                                                       boolean *result)
-{
-    FIXME("iface %p, origin (%f,%f %fx%f), direction %d, result %p stub!\n", iface, origin.X,
-          origin.Y, origin.Width, origin.Height, direction, result);
-    return E_NOTIMPL;
-}
-
-static const struct ICoreInputView2Vtbl core_input_view2_vtbl =
-{
-    core_input_view2_QueryInterface,
-    core_input_view2_AddRef,
-    core_input_view2_Release,
-    /* IInspectable methods */
-    core_input_view2_GetIids,
-    core_input_view2_GetRuntimeClassName,
-    core_input_view2_GetTrustLevel,
-    /* ICoreInputView2 methods */
-    core_input_view2_add_XYFocusTransferringFromPrimaryView,
-    core_input_view2_remove_XYFocusTransferringFromPrimaryView,
-    core_input_view2_add_XYFocusTransferredToPrimaryView,
-    core_input_view2_remove_XYFocusTransferredToPrimaryView,
-    core_input_view2_TryTransferXYFocusToPrimaryView,
-};
-
-DEFINE_IINSPECTABLE(core_input_view3, ICoreInputView3, struct core_input_view, ICoreInputView_iface)
-
-static HRESULT WINAPI core_input_view3_TryShow(ICoreInputView3 *iface, boolean *result)
-{
-    FIXME("iface %p, result %p stub!\n", iface, result);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view3_TryShowWithKind(ICoreInputView3 *iface,
-                                                       CoreInputViewKind type,
-                                                       boolean *result)
-{
-    FIXME("iface %p, type %d, result %p stub!\n", iface, type, result);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view3_TryHide(ICoreInputView3 *iface, boolean *result)
-{
-    FIXME("iface %p, result %p stub!\n", iface, result);
-    return E_NOTIMPL;
-}
-
-static const struct ICoreInputView3Vtbl core_input_view3_vtbl =
-{
-    core_input_view3_QueryInterface,
-    core_input_view3_AddRef,
-    core_input_view3_Release,
-    /* IInspectable methods */
-    core_input_view3_GetIids,
-    core_input_view3_GetRuntimeClassName,
-    core_input_view3_GetTrustLevel,
-    /* ICoreInputView3 methods */
-    core_input_view3_TryShow,
-    core_input_view3_TryShowWithKind,
-    core_input_view3_TryHide,
-};
-
-DEFINE_IINSPECTABLE(core_input_view4, ICoreInputView4, struct core_input_view, ICoreInputView_iface)
-
-static HRESULT WINAPI core_input_view4_add_PrimaryViewShowing(ICoreInputView4 *iface,
-                                                              ITypedEventHandler_CoreInputView_CoreInputViewShowingEventArgs *handler,
-                                                              EventRegistrationToken *token)
-{
-    FIXME("iface %p, handler %p, token %p stub!\n", iface, handler, token);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view4_remove_PrimaryViewShowing(ICoreInputView4 *iface,
-                                                                 EventRegistrationToken token)
-{
-    FIXME("iface %p, token %I64x stub!\n", iface, token.value);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view4_add_PrimaryViewHiding(ICoreInputView4 *iface,
-                                                             ITypedEventHandler_CoreInputView_CoreInputViewHidingEventArgs *handler,
-                                                             EventRegistrationToken *token)
-{
-    FIXME("iface %p, handler %p, token %p stub!\n", iface, handler, token);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI core_input_view4_remove_PrimaryViewHiding(ICoreInputView4 *iface,
-                                                                EventRegistrationToken token)
-{
-    FIXME("iface %p, token %I64x stub!\n", iface, token.value);
-    return E_NOTIMPL;
-}
-
-static const struct ICoreInputView4Vtbl core_input_view4_vtbl =
-{
-    core_input_view4_QueryInterface,
-    core_input_view4_AddRef,
-    core_input_view4_Release,
-    /* IInspectable methods */
-    core_input_view4_GetIids,
-    core_input_view4_GetRuntimeClassName,
-    core_input_view4_GetTrustLevel,
-    /* ICoreInputView4 methods */
-    core_input_view4_add_PrimaryViewShowing,
-    core_input_view4_remove_PrimaryViewShowing,
-    core_input_view4_add_PrimaryViewHiding,
-    core_input_view4_remove_PrimaryViewHiding,
-};
-
-struct core_input_view_statics
-{
-    IActivationFactory IActivationFactory_iface;
-    ICoreInputViewStatics ICoreInputViewStatics_iface;
-    LONG ref;
-};
-
-static inline struct core_input_view_statics *impl_from_IActivationFactory(IActivationFactory *iface)
-{
-    return CONTAINING_RECORD(iface, struct core_input_view_statics, IActivationFactory_iface);
-}
-
-static HRESULT WINAPI factory_QueryInterface(IActivationFactory *iface, REFIID iid, void **out)
-{
-    struct core_input_view_statics *impl = impl_from_IActivationFactory(iface);
-
-    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
-
-    if (IsEqualGUID(iid, &IID_IUnknown)
-        || IsEqualGUID(iid, &IID_IInspectable)
-        || IsEqualGUID(iid, &IID_IActivationFactory))
-    {
-        *out = &impl->IActivationFactory_iface;
-        IActivationFactory_AddRef(*out);
-        return S_OK;
-    }
-
-    if (IsEqualGUID(iid, &IID_ICoreInputViewStatics))
-    {
-        *out = &impl->ICoreInputViewStatics_iface;
-        ICoreInputViewStatics_AddRef(*out);
-        return S_OK;
-    }
-
-    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
-    *out = NULL;
-    return E_NOINTERFACE;
-}
-
-static ULONG WINAPI factory_AddRef(IActivationFactory *iface)
-{
-    struct core_input_view_statics *impl = impl_from_IActivationFactory(iface);
-    ULONG ref = InterlockedIncrement(&impl->ref);
-    TRACE("iface %p, ref %lu.\n", iface, ref);
-    return ref;
-}
-
-static ULONG WINAPI factory_Release(IActivationFactory *iface)
-{
-    struct core_input_view_statics *impl = impl_from_IActivationFactory(iface);
-    ULONG ref = InterlockedDecrement(&impl->ref);
-    TRACE("iface %p, ref %lu.\n", iface, ref);
-    return ref;
-}
-
-static HRESULT WINAPI factory_GetIids(IActivationFactory *iface, ULONG *iid_count, IID **iids)
-{
-    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI factory_GetRuntimeClassName(IActivationFactory *iface, HSTRING *class_name)
-{
-    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI factory_GetTrustLevel(IActivationFactory *iface, TrustLevel *trust_level)
-{
-    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI factory_ActivateInstance(IActivationFactory *iface, IInspectable **instance)
-{
-    FIXME("iface %p, instance %p stub!\n", iface, instance);
-    return E_NOTIMPL;
-}
-
-static const struct IActivationFactoryVtbl factory_vtbl =
-{
-    factory_QueryInterface,
-    factory_AddRef,
-    factory_Release,
-    /* IInspectable methods */
-    factory_GetIids,
-    factory_GetRuntimeClassName,
-    factory_GetTrustLevel,
-    /* IActivationFactory methods */
-    factory_ActivateInstance,
-};
-
-DEFINE_IINSPECTABLE(core_input_view_statics, ICoreInputViewStatics, struct core_input_view_statics,
-                    IActivationFactory_iface)
-
-static HRESULT WINAPI core_input_view_statics_GetForCurrentView(ICoreInputViewStatics *iface,
-                                                                ICoreInputView **result)
-{
-    struct core_input_view *view;
-    HRESULT hr;
-
-    FIXME("iface %p, result %p semi-stub.\n", iface, result);
-
-    if (!(view = calloc(1, sizeof(*view))))
-    {
-        *result = NULL;
-        return E_OUTOFMEMORY;
-    }
-
-    view->ICoreInputView_iface.lpVtbl = &core_input_view_vtbl;
-    view->ICoreInputView2_iface.lpVtbl = &core_input_view2_vtbl;
-    view->ICoreInputView3_iface.lpVtbl = &core_input_view3_vtbl;
-    view->ICoreInputView4_iface.lpVtbl = &core_input_view4_vtbl;
-
-    if (FAILED(hr = weak_reference_source_init(&view->weak_reference_source,
-                                               (IUnknown *)&view->ICoreInputView_iface)))
-    {
-        *result = NULL;
-        free(view);
-        return hr;
-    }
-
-    *result = &view->ICoreInputView_iface;
-    return S_OK;
-}
-
-static const struct ICoreInputViewStaticsVtbl core_input_view_statics_vtbl =
-{
-    core_input_view_statics_QueryInterface,
-    core_input_view_statics_AddRef,
-    core_input_view_statics_Release,
-    /* IInspectable methods */
-    core_input_view_statics_GetIids,
-    core_input_view_statics_GetRuntimeClassName,
-    core_input_view_statics_GetTrustLevel,
-    /* ICoreInputViewStatics methods */
-    core_input_view_statics_GetForCurrentView,
-};
-
-static struct core_input_view_statics core_input_view_statics =
-{
-    {&factory_vtbl},
-    {&core_input_view_statics_vtbl},
-    1,
-};
-
-static IActivationFactory *core_input_view_factory = &core_input_view_statics.IActivationFactory_iface;
-
-HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID riid, void **out)
-{
-    FIXME("clsid %s, riid %s, out %p stub!\n", debugstr_guid(clsid), debugstr_guid(riid), out);
+    FIXME( "clsid %s, riid %s, out %p stub!\n", debugstr_guid( clsid ), debugstr_guid( riid ), out );
     return CLASS_E_CLASSNOTAVAILABLE;
 }
 
-HRESULT WINAPI DllGetActivationFactory(HSTRING classid, IActivationFactory **factory)
+HRESULT WINAPI DllGetActivationFactory( HSTRING classid, IActivationFactory **factory )
 {
-    const WCHAR *name = WindowsGetStringRawBuffer(classid, NULL);
+    const WCHAR *buffer = WindowsGetStringRawBuffer( classid, NULL );
 
-    TRACE("classid %s, factory %p.\n", debugstr_hstring(classid), factory);
+    TRACE( "class %s, factory %p.\n", debugstr_hstring( classid ), factory );
 
     *factory = NULL;
 
-    if (!wcscmp(name, RuntimeClass_Windows_UI_ViewManagement_Core_CoreInputView))
+    if (!wcscmp( buffer, RuntimeClass_Windows_UI_Text_Core_CoreTextServicesManager ))
+        IActivationFactory_QueryInterface( core_text_services_manager_factory, &IID_IActivationFactory, (void **)factory );
+
+    if (!wcscmp(buffer, RuntimeClass_Windows_UI_ViewManagement_Core_CoreInputView))
         IActivationFactory_QueryInterface(core_input_view_factory, &IID_IActivationFactory, (void **)factory);
 
-    return *factory ? S_OK : CLASS_E_CLASSNOTAVAILABLE;
+    if (*factory) return S_OK;
+    return CLASS_E_CLASSNOTAVAILABLE;
 }
diff --git a/dlls/windows.ui.core.textinput/private.h b/dlls/windows.ui.core.textinput/private.h
index 8b9e6419410..d6cbc041b1a 100644
--- a/dlls/windows.ui.core.textinput/private.h
+++ b/dlls/windows.ui.core.textinput/private.h
@@ -1,6 +1,6 @@
-/* WinRT Windows.UI.ViewManagement.Core.CoreInputView Implementation
+/* WinRT Windows.UI.Core.TextInput Implementation
  *
- * Copyright 2025 Zhiyi Zhang for CodeWeavers
+ * Written by Weather
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -17,21 +17,34 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#ifndef __WINE_WINDOWS_STORAGE_PRIVATE_H
+#define __WINE_WINDOWS_STORAGE_PRIVATE_H
+
 #include <stdarg.h>
-#include <stddef.h>
 
 #define COBJMACROS
 #include "windef.h"
 #include "winbase.h"
 #include "winstring.h"
+#include "weakreference.h"
+
 #include "activation.h"
+
 #include "wine/debug.h"
 
 #define WIDL_using_Windows_Foundation
 #define WIDL_using_Windows_Foundation_Collections
+#include "windows.foundation.h"
+#define WIDL_using_Windows_Globalization
+#include "windows.globalization.h"
+#define WIDL_using_Windows_UI_Text_Core
+#include "windows.ui.text.core.h"
 #define WIDL_using_Windows_UI_ViewManagement_Core
 #include "windows.ui.viewmanagement.core.h"
 
+extern IActivationFactory *core_text_services_manager_factory;
+extern IActivationFactory *core_input_view_factory;
+
 struct vector_iids
 {
     const GUID *vector;
@@ -41,41 +54,43 @@ struct vector_iids
 };
 extern HRESULT vector_create(const struct vector_iids *iids, void **out);
 
-#define DEFINE_IINSPECTABLE_(pfx, iface_type, impl_type, impl_from, iface_mem, expr)        \
-    static inline impl_type *impl_from(iface_type *iface)                                   \
-    {                                                                                       \
-        return CONTAINING_RECORD(iface, impl_type, iface_mem);                              \
-    }                                                                                       \
-    static HRESULT WINAPI pfx##_QueryInterface(iface_type *iface, REFIID iid, void **out)   \
-    {                                                                                       \
-        impl_type *impl = impl_from(iface);                                                 \
-        return IInspectable_QueryInterface((IInspectable *)(expr), iid, out);               \
-    }                                                                                       \
-    static ULONG WINAPI pfx##_AddRef(iface_type *iface)                                     \
-    {                                                                                       \
-        impl_type *impl = impl_from(iface);                                                 \
-        return IInspectable_AddRef((IInspectable *)(expr));                                 \
-    }                                                                                       \
-    static ULONG WINAPI pfx##_Release(iface_type *iface)                                    \
-    {                                                                                       \
-        impl_type *impl = impl_from(iface);                                                 \
-        return IInspectable_Release((IInspectable *)(expr));                                \
-    }                                                                                       \
-    static HRESULT WINAPI pfx##_GetIids(iface_type *iface, ULONG *iid_count, IID **iids)    \
-    {                                                                                       \
-        impl_type *impl = impl_from(iface);                                                 \
-        return IInspectable_GetIids((IInspectable *)(expr), iid_count, iids);               \
-    }                                                                                       \
-    static HRESULT WINAPI pfx##_GetRuntimeClassName(iface_type *iface, HSTRING *class_name) \
-    {                                                                                       \
-        impl_type *impl = impl_from(iface);                                                 \
-        return IInspectable_GetRuntimeClassName((IInspectable *)(expr), class_name);        \
-    }                                                                                       \
-    static HRESULT WINAPI pfx##_GetTrustLevel(iface_type *iface, TrustLevel *trust_level)   \
-    {                                                                                       \
-        impl_type *impl = impl_from(iface);                                                 \
-        return IInspectable_GetTrustLevel((IInspectable *)(expr), trust_level);             \
+
+#define DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from, iface_mem, expr )             \
+    static inline impl_type *impl_from( iface_type *iface )                                        \
+    {                                                                                              \
+        return CONTAINING_RECORD( iface, impl_type, iface_mem );                                   \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_QueryInterface( iface_type *iface, REFIID iid, void **out )        \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_QueryInterface( (IInspectable *)(expr), iid, out );                    \
+    }                                                                                              \
+    static ULONG WINAPI pfx##_AddRef( iface_type *iface )                                          \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_AddRef( (IInspectable *)(expr) );                                      \
+    }                                                                                              \
+    static ULONG WINAPI pfx##_Release( iface_type *iface )                                         \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_Release( (IInspectable *)(expr) );                                     \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetIids( iface_type *iface, ULONG *iid_count, IID **iids )         \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetIids( (IInspectable *)(expr), iid_count, iids );                    \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetRuntimeClassName( iface_type *iface, HSTRING *class_name )      \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetRuntimeClassName( (IInspectable *)(expr), class_name );             \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetTrustLevel( iface_type *iface, TrustLevel *trust_level )        \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetTrustLevel( (IInspectable *)(expr), trust_level );                  \
     }
+#define DEFINE_IINSPECTABLE( pfx, iface_type, impl_type, base_iface )                              \
+    DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from_##iface_type, iface_type##_iface, &impl->base_iface )
 
-#define DEFINE_IINSPECTABLE(pfx, iface_type, impl_type, base_iface) \
-    DEFINE_IINSPECTABLE_(pfx, iface_type, impl_type, impl_from_##iface_type, iface_type##_iface, &impl->base_iface)
+#endif
diff --git a/dlls/windows.ui.core.textinput/services.c b/dlls/windows.ui.core.textinput/services.c
new file mode 100644
index 00000000000..dc33639ba8e
--- /dev/null
+++ b/dlls/windows.ui.core.textinput/services.c
@@ -0,0 +1,275 @@
+/* WinRT Windows.UI.Text.Core.CoreTextServicesManager Implementation
+ *
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+#include "editcontext.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(textinput);
+
+extern const struct ICoreTextEditContextVtbl core_text_edit_context_vtbl;
+
+struct core_text_services_manager_statics
+{
+    IActivationFactory IActivationFactory_iface;
+    ICoreTextServicesManagerStatics ICoreTextServicesManagerStatics_iface;
+    LONG ref;
+};
+
+struct core_text_services_manager
+{
+    ICoreTextServicesManager ICoreTextServicesManager_iface;
+    LONG ref;
+};
+
+static inline struct core_text_services_manager_statics *impl_from_IActivationFactory( IActivationFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct core_text_services_manager_statics, IActivationFactory_iface );
+}
+
+static HRESULT WINAPI factory_QueryInterface( IActivationFactory *iface, REFIID iid, void **out )
+{
+    struct core_text_services_manager_statics *impl = impl_from_IActivationFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IActivationFactory ))
+    {
+        *out = &impl->IActivationFactory_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_ICoreTextServicesManagerStatics ))
+    {
+        *out = &impl->ICoreTextServicesManagerStatics_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI factory_AddRef( IActivationFactory *iface )
+{
+    struct core_text_services_manager_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI factory_Release( IActivationFactory *iface )
+{
+    struct core_text_services_manager_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI factory_GetIids( IActivationFactory *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetRuntimeClassName( IActivationFactory *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetTrustLevel( IActivationFactory *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_ActivateInstance( IActivationFactory *iface, IInspectable **instance )
+{
+    FIXME( "iface %p, instance %p stub!\n", iface, instance );
+    return S_OK;
+}
+
+static const struct IActivationFactoryVtbl factory_vtbl =
+{
+    factory_QueryInterface,
+    factory_AddRef,
+    factory_Release,
+    /* IInspectable methods */
+    factory_GetIids,
+    factory_GetRuntimeClassName,
+    factory_GetTrustLevel,
+    /* IActivationFactory methods */
+    factory_ActivateInstance,
+};
+
+
+static inline struct core_text_services_manager *impl_from_ICoreTextServicesManager( ICoreTextServicesManager *iface )
+{
+    return CONTAINING_RECORD( iface, struct core_text_services_manager, ICoreTextServicesManager_iface );
+}
+
+static HRESULT WINAPI core_text_services_manager_QueryInterface( ICoreTextServicesManager *iface, REFIID iid, void **out )
+{
+    struct core_text_services_manager *impl = impl_from_ICoreTextServicesManager( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_ICoreTextServicesManager ))
+    {
+        *out = &impl->ICoreTextServicesManager_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI core_text_services_manager_AddRef( ICoreTextServicesManager *iface )
+{
+    struct core_text_services_manager *impl = impl_from_ICoreTextServicesManager( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI core_text_services_manager_Release( ICoreTextServicesManager *iface )
+{
+    struct core_text_services_manager *impl = impl_from_ICoreTextServicesManager( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI core_text_services_manager_GetIids( ICoreTextServicesManager *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_services_manager_GetRuntimeClassName( ICoreTextServicesManager *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_services_manager_GetTrustLevel( ICoreTextServicesManager *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p not stub!\n", iface, trust_level );
+    *trust_level = FullTrust;
+    return S_OK;
+}
+static HRESULT WINAPI core_text_services_manager_get_InputLanguage( ICoreTextServicesManager *iface, ILanguage **value )
+{
+    FIXME( "iface %p, value %p stub!\n", iface, value );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_services_manager_add_InputLanguageChanged( ICoreTextServicesManager *iface, ITypedEventHandler_CoreTextServicesManager_IInspectable *handler, EventRegistrationToken* cookie )
+{
+    FIXME( "iface %p, handler %p, cookie %p stub!\n", iface, handler, cookie );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_services_manager_remove_InputLanguageChanged( ICoreTextServicesManager *iface, EventRegistrationToken cookie )
+{
+    FIXME( "iface %p stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI core_text_services_manager_CreateEditContext( ICoreTextServicesManager *iface, ICoreTextEditContext **value )
+{
+    struct core_text_edit_context *context;
+
+    TRACE( "iface %p out %p created\n", iface, value );
+
+    if (!(context = calloc( 1, sizeof(*context) ))) return E_OUTOFMEMORY;
+
+    context->ICoreTextEditContext_iface.lpVtbl = &core_text_edit_context_vtbl;
+    context->ref = 1;
+
+    *value = &context->ICoreTextEditContext_iface;
+
+    return S_OK;
+}
+
+static const struct ICoreTextServicesManagerVtbl core_text_services_manager_vtbl =
+{
+    core_text_services_manager_QueryInterface,
+    core_text_services_manager_AddRef,
+    core_text_services_manager_Release,
+    /* IInspectable methods */
+    core_text_services_manager_GetIids,
+    core_text_services_manager_GetRuntimeClassName,
+    core_text_services_manager_GetTrustLevel,
+    /* ICoreTextServicesManagerStatics methods */
+    core_text_services_manager_get_InputLanguage,
+    core_text_services_manager_add_InputLanguageChanged,
+    core_text_services_manager_remove_InputLanguageChanged,
+    core_text_services_manager_CreateEditContext
+};
+
+DEFINE_IINSPECTABLE( core_text_services_manager_statics, ICoreTextServicesManagerStatics, struct core_text_services_manager_statics, IActivationFactory_iface )
+
+static HRESULT WINAPI core_text_services_manager_statics_GetForCurrentView( ICoreTextServicesManagerStatics *iface, ICoreTextServicesManager **out )
+{
+    struct core_text_services_manager *manager;
+
+    TRACE( "iface %p out %p\n", iface, out );
+
+    if (!(manager = calloc( 1, sizeof(*manager) ))) return E_OUTOFMEMORY;
+
+    manager->ICoreTextServicesManager_iface.lpVtbl = &core_text_services_manager_vtbl;
+    manager->ref = 1;
+
+    *out = &manager->ICoreTextServicesManager_iface;
+
+    return S_OK;
+}
+
+static const struct ICoreTextServicesManagerStaticsVtbl core_text_services_manager_statics_vtbl =
+{
+    core_text_services_manager_statics_QueryInterface,
+    core_text_services_manager_statics_AddRef,
+    core_text_services_manager_statics_Release,
+    /* IInspectable methods */
+    core_text_services_manager_statics_GetIids,
+    core_text_services_manager_statics_GetRuntimeClassName,
+    core_text_services_manager_statics_GetTrustLevel,
+    /* ICoreTextServicesManagerStatics methods */
+    core_text_services_manager_statics_GetForCurrentView
+};
+
+static struct core_text_services_manager_statics core_text_services_manager_statics =
+{
+    {&factory_vtbl},
+    {&core_text_services_manager_statics_vtbl},
+    0,
+};
+
+IActivationFactory *core_text_services_manager_factory = &core_text_services_manager_statics.IActivationFactory_iface;
diff --git a/dlls/windows.ui.core.textinput/weakref.h b/dlls/windows.ui.core.textinput/weakref.h
index 7d4bc22b087..843bc0faf39 100644
--- a/dlls/windows.ui.core.textinput/weakref.h
+++ b/dlls/windows.ui.core.textinput/weakref.h
@@ -20,7 +20,7 @@
 #ifndef __WINE_WEAKREF_H
 #define __WINE_WEAKREF_H
 
-#include "weakreference.h"
+#include "private.h"
 
 struct weak_reference_source
 {
diff --git a/dlls/windows.ui.core.textinput/windows.ui.core.textinput.spec b/dlls/windows.ui.core.textinput/windows.ui.core.textinput.spec
index 31a5eafe950..1eef8ba134d 100644
--- a/dlls/windows.ui.core.textinput/windows.ui.core.textinput.spec
+++ b/dlls/windows.ui.core.textinput/windows.ui.core.textinput.spec
@@ -1,3 +1,6 @@
-@ stdcall -private DllGetActivationFactory(ptr ptr)
 @ stdcall -private DllCanUnloadNow()
+@ stdcall -private DllGetActivationFactory(ptr ptr)
 @ stdcall -private DllGetClassObject(ptr ptr ptr)
+@ stdcall -private DllMain(long long ptr)
+@ stdcall -private DllRegisterServer()
+@ stdcall -private DllUnregisterServer()
diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index 4e2227bb636..33c410b569c 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -531,9 +531,9 @@ static BOOL is_hidraw_enabled(WORD vid, WORD pid, const USAGE_AND_PAGE *usages,
         return FALSE;
     }
     if (usages->UsagePage != HID_USAGE_PAGE_GENERIC) return TRUE;
-    if (usages->Usage == HID_USAGE_GENERIC_MOUSE || usages->Usage == HID_USAGE_GENERIC_KEYBOARD)
+    if (usages->Usage == HID_USAGE_GENERIC_KEYBOARD)
     {
-        WARN("Ignoring unsupported %04X:%04X hidraw mouse/keyboard\n", vid, pid);
+        WARN("Ignoring unsupported %04X:%04X hidraw keyboard\n", vid, pid);
         return FALSE;
     }
     if (usages->Usage != HID_USAGE_GENERIC_GAMEPAD && usages->Usage != HID_USAGE_GENERIC_JOYSTICK) return TRUE;
diff --git a/dlls/wintypes/main.c b/dlls/wintypes/main.c
index 287e5992225..57dff9f5a7c 100644
--- a/dlls/wintypes/main.c
+++ b/dlls/wintypes/main.c
@@ -162,7 +162,7 @@ static HRESULT STDMETHODCALLTYPE api_information_statics_IsMethodPresent(
     if (!type_name)
         return E_INVALIDARG;
 
-    return E_NOTIMPL;
+    return S_OK;
 }
 
 static HRESULT STDMETHODCALLTYPE api_information_statics_IsMethodPresentWithArity(
diff --git a/dlls/xgameruntime/GDKComponent/InitInternalGDKC.c b/dlls/xgameruntime/GDKComponent/InitInternalGDKC.c
new file mode 100644
index 00000000000..9def3524b9a
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/InitInternalGDKC.c
@@ -0,0 +1,72 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: Internal Initialization
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "InitInternalGDKC.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(gdkc);
+
+static BOOLEAN WINAPI GDKCIgnoreVersionMismatch( void )
+{
+    LSTATUS result;
+    DWORD valueSize;
+    INT32 value;
+
+    result = RegGetValueW( HKEY_LOCAL_MACHINE,
+                           L"Software\\Microsoft\\GamingServices",
+                           L"IgnoreVersionMismatch",
+                           RRF_RT_REG_DWORD,
+                           NULL,
+                           &value,
+                           &valueSize );
+    
+    if ( FAILED( result ) ) return FALSE;
+    if ( value == 0 )
+        return FALSE;
+    else
+        return TRUE;
+}
+
+HRESULT WINAPI GDKC_InitAPI( 
+    ULONG gdkVer, 
+    ULONG gsVer, 
+    CHAR mode,
+    INITIALIZE_OPTIONS *options
+) {
+    HRESULT status = S_OK;
+
+    TRACE("gdkVer %ld, gsVer %ld, mode %d, options %p\n", gdkVer, gsVer, mode, options);
+
+    if ( !GDKCIgnoreVersionMismatch() && ( gdkVer >= GDKC_VERSION && gsVer > GAMING_SERVICES_VERSION ) )
+    {
+        ERR("GDKComponent version mismatch with the requested parameters!\n");
+        ERR("Target GDK Version: %ld, Current Version: %ld\n", gdkVer, GDKC_VERSION );
+        ERR("Target Gaming Services Version: %ld, Current Version: %ld\n", gsVer, GAMING_SERVICES_VERSION );
+
+        // Uncomment once MS Store Services has been implemented within Wine.
+        // ShellExecuteW( NULL, NULL, L"ms-windows-store://pdp?productId=9MWPM2CQNLHN", NULL, NULL, 1 );
+
+        return E_GAMERUNTIME_VERSION_MISMATCH;
+    }
+
+    return status;
+
+    // TODO: Game Specific Initialization
+}
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/InitInternalGDKC.h b/dlls/xgameruntime/GDKComponent/InitInternalGDKC.h
new file mode 100644
index 00000000000..a1594764030
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/InitInternalGDKC.h
@@ -0,0 +1,29 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: Internal Initialization Header
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef GDKC_INIT
+#define GDKC_INIT
+
+#include "../private.h"
+
+HRESULT WINAPI GDKC_InitAPI( ULONG gdkVer, ULONG gsVer, CHAR mode, INITIALIZE_OPTIONS *options );
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Networking/HTTPClient.c b/dlls/xgameruntime/GDKComponent/System/Networking/HTTPClient.c
new file mode 100644
index 00000000000..bdcae8241b5
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Networking/HTTPClient.c
@@ -0,0 +1,313 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XSystem
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "HTTPClient.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(gdkc);
+
+static HRESULT httpclient_SendRequest( URL_COMPONENTS uc, HINTERNET *inetRequest )
+{
+    DWORD reqFlags;
+    LPWSTR hostName = NULL;
+    LPWSTR urlPath = NULL;
+    HRESULT status = S_OK;
+    HINTERNET inetSession = NULL;
+    HINTERNET inetConnect = NULL;
+
+    if (inetRequest) *inetRequest = NULL;
+
+    TRACE( "uc %p, inetRequest %p\n", &uc, inetRequest );
+
+    hostName = HeapAlloc( GetProcessHeap(), 0, (uc.dwHostNameLength + 1) * sizeof(WCHAR) );
+    if ( !hostName ) 
+    { 
+        status = E_OUTOFMEMORY; goto _CLEANUP; 
+    }
+    wcsncpy_s( hostName, uc.dwHostNameLength + 1, uc.lpszHostName, uc.dwHostNameLength );
+    hostName[uc.dwHostNameLength] = L'\0';
+
+    if ( uc.dwUrlPathLength == 0 ) 
+    {
+        urlPath = HeapAlloc( GetProcessHeap(), 0, 2 * sizeof(WCHAR) );
+        if ( !urlPath ) 
+        { 
+            status = E_OUTOFMEMORY; 
+            goto _CLEANUP; 
+        }
+        wcscpy_s( urlPath, 2, L"/" );
+    } else 
+    {
+        urlPath = HeapAlloc( GetProcessHeap(), 0, (uc.dwUrlPathLength + 1) * sizeof(WCHAR) );
+        if ( !urlPath ) 
+        { 
+            status = E_OUTOFMEMORY; 
+            goto _CLEANUP; 
+        }
+        wcsncpy_s( urlPath, uc.dwUrlPathLength + 1, uc.lpszUrlPath, uc.dwUrlPathLength );
+        urlPath[uc.dwUrlPathLength] = L'\0';
+    }
+
+    inetSession = WinHttpOpen( L"curl/1.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0 );
+    if ( !inetSession )
+    {
+        status = HRESULT_FROM_WIN32( GetLastError() );
+        goto _CLEANUP;
+    }
+
+    inetConnect = WinHttpConnect( inetSession, hostName, uc.nPort, 0 );
+    if ( !inetConnect )
+    {
+        status = HRESULT_FROM_WIN32( GetLastError() );
+        goto _CLEANUP;
+    }
+
+    reqFlags = ( uc.nScheme == INTERNET_SCHEME_HTTPS ) ? WINHTTP_FLAG_SECURE : 0;
+    *inetRequest = WinHttpOpenRequest( inetConnect, L"GET",urlPath, NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, reqFlags );
+    if ( !*inetRequest )
+    {
+        status = HRESULT_FROM_WIN32( GetLastError() );
+        goto _CLEANUP;
+    }
+
+    if ( !WinHttpSendRequest( *inetRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0 ) ||
+         !WinHttpReceiveResponse( *inetRequest, NULL ) )
+    {
+        status = HRESULT_FROM_WIN32( GetLastError() );
+        goto _CLEANUP;
+    }
+
+_CLEANUP:
+    if ( FAILED( status ) )
+    {
+        if ( *inetRequest ) WinHttpCloseHandle( *inetRequest );
+        *inetRequest = NULL;
+    }
+    if ( inetSession ) WinHttpCloseHandle( inetSession );
+    if ( inetConnect ) WinHttpCloseHandle( inetConnect );
+    if ( hostName ) HeapFree( GetProcessHeap(), 0, hostName );
+    if ( urlPath ) HeapFree( GetProcessHeap(), 0, urlPath );
+    return status;
+}
+
+static HRESULT httpclient_ObtainSecurityProtocolFlags( HINTERNET inetRequest, UINT32 *flags )
+{
+    DWORD secInfoSize = sizeof( WINHTTP_SECURITY_INFO );
+    HRESULT status = S_OK;
+    PWINHTTP_SECURITY_INFO securityInfo = ( PWINHTTP_SECURITY_INFO )CoTaskMemAlloc( secInfoSize );
+
+    TRACE( "inetRequest %p, flags %p\n", inetRequest, flags );
+
+    if ( !WinHttpQueryOption( inetRequest, WINHTTP_OPTION_SECURITY_INFO, securityInfo, &secInfoSize ) )
+    {
+        status = HRESULT_FROM_WIN32( GetLastError() );
+        goto _CLEANUP;
+    }
+
+    *flags = securityInfo->ConnectionInfo.dwProtocol;
+
+_CLEANUP:
+    CoTaskMemFree( securityInfo );
+    return status;
+}
+
+static HRESULT httpclient_ObtainServerCertificate( HINTERNET inetRequest, PCERT_CONTEXT *context )
+{
+    DWORD certContextSize = sizeof( PCCERT_CONTEXT );
+    HRESULT status = S_OK;
+
+    TRACE( "inetRequest %p, context %p\n", inetRequest, context );
+
+    if ( !WinHttpQueryOption( inetRequest, WINHTTP_OPTION_SERVER_CERT_CONTEXT, context, &certContextSize ) )
+    {
+        status = HRESULT_FROM_WIN32( GetLastError() );
+        goto _CLEANUP;
+    }
+
+_CLEANUP:
+    return status;
+}
+
+static HRESULT httpclient_ObtainThumbprints( HINTERNET inetRequest, SIZE_T *thumbprintCount, XNetworkingThumbprint **out )
+{
+    SIZE_T idx = 0;
+    HRESULT status = S_OK;
+    PCERT_CONTEXT certContext;
+    CERT_CHAIN_PARA chainPara = { .cbSize = sizeof(CERT_CHAIN_PARA) };
+    PCCERT_CHAIN_CONTEXT chainContext;
+    XNetworkingThumbprint *thumbprints;
+
+    TRACE( "inetRequest %p, thumbprintCount %p, out %p\n", inetRequest, thumbprintCount, out );
+
+    status = httpclient_ObtainServerCertificate( inetRequest, &certContext );
+    if ( FAILED( status ) ) goto _CLEANUP;
+
+    if ( !CertGetCertificateChain( NULL, certContext, NULL, certContext->hCertStore, &chainPara, 0, NULL, &chainContext ) )
+    {
+        status = HRESULT_FROM_WIN32( GetLastError() );
+        goto _CLEANUP;
+    }
+
+    thumbprints = (XNetworkingThumbprint *)calloc( 3, sizeof(XNetworkingThumbprint) );
+    if ( !thumbprints )
+    {
+        status = E_OUTOFMEMORY;
+        goto _CLEANUP;
+    }
+
+#define TRY_ADD_THUMBPRINT_FROM_CERT(pCertCtx, tp)                                                                  \
+    do {                                                                                                            \
+        if ( pCertCtx ) {                                                                                           \
+            DWORD cb = 0;                                                                                           \
+            /* Wine's WinHTTP only supports SHA1 */                                                                 \
+            if ( CertGetCertificateContextProperty( pCertCtx, CERT_SHA1_HASH_PROP_ID, NULL, &cb ) )                 \
+            {                                                                                                       \
+                UINT8* buf = (UINT8*)malloc( cb );                                                                  \
+                if ( buf && CertGetCertificateContextProperty( pCertCtx, CERT_SHA1_HASH_PROP_ID, buf, &cb ) )       \
+                {                                                                                                   \
+                    thumbprints[idx].thumbprintType = (tp);                                                         \
+                    thumbprints[idx].thumbprintBufferByteCount = (SIZE_T)cb;                                        \
+                    thumbprints[idx].thumbprintBuffer = buf;                                                        \
+                    idx++;                                                                                          \
+                } else { free( buf ); }                                                                             \
+            }                                                                                                       \
+        }                                                                                                           \
+    } while( FALSE )
+
+    if ( chainContext && chainContext->cChain > 0 && chainContext->rgpChain[0] ) 
+    {
+        PCERT_SIMPLE_CHAIN simple = chainContext->rgpChain[0];
+        DWORD numElements = simple->cElement;
+        if ( numElements >= 1 ) 
+        {
+            // leaf = element[0]
+            TRY_ADD_THUMBPRINT_FROM_CERT( simple->rgpElement[0]->pCertContext, ThumbprintType_Leaf );
+        }
+        if ( numElements >= 2 ) 
+        {
+            // issuer = element[1] (immediate issuer of leaf)
+            TRY_ADD_THUMBPRINT_FROM_CERT( simple->rgpElement[1]->pCertContext, ThumbprintType_Issuer );
+        }
+        if ( numElements >= 1 ) 
+        {
+            // root = last element
+            TRY_ADD_THUMBPRINT_FROM_CERT( simple->rgpElement[numElements - 1]->pCertContext, ThumbprintType_Root );
+        }
+    } else 
+    {
+        // chain not available: at least try server cert (leaf)
+        TRY_ADD_THUMBPRINT_FROM_CERT( certContext, ThumbprintType_Leaf );
+    }
+
+    if (idx > 0) 
+    {
+        *out = ( XNetworkingThumbprint* )realloc( thumbprints, idx * sizeof(XNetworkingThumbprint) );
+        *thumbprintCount = idx;
+    }
+
+#undef TRY_ADD_THUMBPRINT_FROM_CERT
+
+_CLEANUP:
+    if ( chainContext ) CertFreeCertificateChain( chainContext );
+    if ( certContext ) CertFreeCertificateContext( certContext );
+
+    return status;
+}
+
+HRESULT httpclient_ObtainSecurityInformationForUrl( LPCWSTR url, BYTE **outBuffer, SIZE_T *outBufferByteCount, XNetworkingSecurityInformation **securityInformation )
+{
+    LPBYTE buffer = NULL;
+    LPBYTE bufferLoc = NULL;
+    SIZE_T iterator;
+    SIZE_T totalBufferSize;
+    SIZE_T thumbprintBytes = 0;
+    HRESULT status = S_OK;
+    HINTERNET inetRequest;
+    URL_COMPONENTS uc = { .dwStructSize = sizeof(URL_COMPONENTS), 
+        .dwSchemeLength = (DWORD)-1, .dwHostNameLength = (DWORD)-1, .dwUrlPathLength = (DWORD)-1, .dwExtraInfoLength = (DWORD)-1 };
+    XNetworkingSecurityInformation *information = NULL;
+
+    FIXME( "url %s, securityInformation %p\n", debugstr_w( url ), securityInformation );
+
+    if ( !WinHttpCrackUrl( url, 0, 0, &uc ) )
+    {
+        status = HRESULT_FROM_WIN32( GetLastError() );
+        goto _CLEANUP;
+    }
+
+    status = httpclient_SendRequest( uc, &inetRequest );
+    if ( FAILED( status ) ) goto _CLEANUP;
+
+    information = (XNetworkingSecurityInformation *)malloc( sizeof(*information) );
+
+    status = httpclient_ObtainThumbprints( inetRequest, &information->thumbprintCount, &information->thumbprints );
+    if ( FAILED( status ) ) goto _CLEANUP;
+
+    // TODO: Security Protocol Flags are not supported by wine's WinHTTP
+    status = httpclient_ObtainSecurityProtocolFlags( inetRequest, &information->enabledHttpSecurityProtocolFlags );
+    if ( FAILED( status ) )
+    {
+        information->enabledHttpSecurityProtocolFlags = WINHTTP_FLAG_SECURE_PROTOCOL_ALL | WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_1 | WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_2 | WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_3;
+        status = S_OK;
+    }
+
+    for ( iterator = 0; iterator < information->thumbprintCount; iterator++ )
+        thumbprintBytes += information->thumbprints[iterator].thumbprintBufferByteCount;
+
+    totalBufferSize = sizeof(XNetworkingSecurityInformation) + (information->thumbprintCount * sizeof(XNetworkingThumbprint)) + thumbprintBytes;
+
+    buffer = (LPBYTE)malloc( totalBufferSize );
+    if ( !buffer )
+    {
+        status = E_OUTOFMEMORY;
+        goto _CLEANUP;
+    }
+
+    bufferLoc = buffer;
+
+    memcpy( bufferLoc, information, sizeof(XNetworkingSecurityInformation) );
+    bufferLoc += sizeof(XNetworkingSecurityInformation);
+
+    memcpy( bufferLoc, information->thumbprints, (information->thumbprintCount * sizeof(XNetworkingThumbprint)) );
+    bufferLoc += (information->thumbprintCount * sizeof(XNetworkingThumbprint));
+
+    for ( iterator = 0; iterator < information->thumbprintCount; iterator++ )
+    {
+        // guard against empty thumbprints
+        if ( information->thumbprints[iterator].thumbprintBuffer && information->thumbprints[iterator].thumbprintBufferByteCount > 0 )
+        {
+            memcpy( bufferLoc,
+                    information->thumbprints[iterator].thumbprintBuffer,
+                    (size_t)information->thumbprints[iterator].thumbprintBufferByteCount );
+            bufferLoc += information->thumbprints[iterator].thumbprintBufferByteCount;
+        }
+    }
+
+    *outBuffer = buffer;
+    *outBufferByteCount = totalBufferSize;
+
+_CLEANUP:
+    if ( FAILED( status ) )
+    {
+        free( buffer );
+    }
+    if ( inetRequest ) WinHttpCloseHandle( inetRequest );
+    return status;
+}
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Networking/HTTPClient.h b/dlls/xgameruntime/GDKComponent/System/Networking/HTTPClient.h
new file mode 100644
index 00000000000..9fba9cc855e
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Networking/HTTPClient.h
@@ -0,0 +1,34 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XNetworking
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef HTTPCLIENT_H
+#define HTTPCLIENT_H
+
+#include "../../../private.h"
+
+#include <string.h>
+#include <wincrypt.h>
+#include <schannel.h>
+#include <winhttp.h>
+
+HRESULT httpclient_ObtainSecurityInformationForUrl( LPCWSTR url, BYTE **outBuffer, SIZE_T *outBufferByteCount, XNetworkingSecurityInformation **securityInformation );
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Networking/XNetworking.c b/dlls/xgameruntime/GDKComponent/System/Networking/XNetworking.c
new file mode 100644
index 00000000000..bb8e36b042f
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Networking/XNetworking.c
@@ -0,0 +1,321 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XSystem
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "XNetworking.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(gdkc);
+
+static HRESULT CALLBACK HTTPClientProvider( XAsyncOp operation, const XAsyncProviderData *data )
+{
+    HRESULT status;
+    IXThreadingImpl *threadingImpl;
+
+    struct UrlSecurityInfoContext *context = (struct UrlSecurityInfoContext *)data->context;
+
+    // Threading module may be obtained from another binary.
+    TRACE( "operation %d, data %p\n", operation, data );
+
+    status = QueryApiImpl( &CLSID_XThreadingImpl, &IID_IXThreadingImpl, (void **)&threadingImpl );
+    if ( FAILED( status ) ) return status;
+
+    switch ( operation )
+    {
+        case Begin:
+        {
+            return IXThreadingImpl_XAsyncSchedule( threadingImpl, data->async, 100 );
+        }
+
+        case DoWork:
+        {
+            status = httpclient_ObtainSecurityInformationForUrl( context->url, &context->securityInformationBuffer, &context->securityInformationBufferCount, &context->securityInformation );
+
+            IXThreadingImpl_XAsyncComplete( threadingImpl, data->async, status, context->securityInformationBufferCount );
+
+            return status;
+        }
+
+        case GetResult:
+        {
+            if ( data->buffer && data->bufferSize >= context->securityInformationBufferCount )
+            {
+                memcpy( data->buffer, &context->securityInformationBuffer, context->securityInformationBufferCount );
+                return S_OK;
+            }
+            return E_BOUNDS;
+        }
+
+        case Cancel:
+        {
+            IXThreadingImpl_XAsyncComplete( threadingImpl, data->async, E_ABORT, 0 );
+            return S_OK;
+        }
+
+        case Cleanup:
+        {
+            free( context );
+            return S_OK;
+        }
+    }
+
+    return E_NOTIMPL;
+}
+
+static inline struct x_networking *impl_from_IXNetworkingImpl( IXNetworkingImpl *iface )
+{
+    return CONTAINING_RECORD( iface, struct x_networking, IXNetworkingImpl_iface );
+}
+
+static HRESULT WINAPI x_networking_QueryInterface( IXNetworkingImpl *iface, REFIID iid, void **out )
+{
+    struct x_networking *impl = impl_from_IXNetworkingImpl( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IXNetworkingImpl ))
+    {
+        *out = &impl->IXNetworkingImpl_iface;
+        impl->IXNetworkingImpl_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI x_networking_AddRef( IXNetworkingImpl *iface )
+{
+    struct x_networking *impl = impl_from_IXNetworkingImpl( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI x_networking_Release( IXNetworkingImpl *iface )
+{
+    struct x_networking *impl = impl_from_IXNetworkingImpl( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingQueryPreferredLocalUdpMultiplayerPort( IXNetworkingImpl *iface, UINT16 *preferredLocalUdpMultiplayerPort )
+{
+    FIXME( "iface %p, preferredLocalUdpMultiplayerPort %p stub!\n", iface, preferredLocalUdpMultiplayerPort );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingQueryPreferredLocalUdpMultiplayerPortAsync( IXNetworkingImpl *iface, XAsyncBlock *asyncBlock )
+{
+    FIXME( "iface %p, asyncBlock %p stub!\n", iface, asyncBlock );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingQueryPreferredLocalUdpMultiplayerPortAsyncResult( IXNetworkingImpl *iface, XAsyncBlock *asyncBlock, UINT16 *preferredLocalUdpMultiplayerPort )
+{
+    FIXME( "iface %p, asyncBlock %p, preferredLocalUdpMultiplayerPort %p stub!\n", iface, asyncBlock, preferredLocalUdpMultiplayerPort );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingRegisterPreferredLocalUdpMultiplayerPortChanged( IXNetworkingImpl *iface, XTaskQueueHandle queue, PVOID context, XNetworkingPreferredLocalUdpMultiplayerPortChangedCallback *callback, XTaskQueueRegistrationToken *token )
+{
+    FIXME( "iface %p, queue %p, context %p, callback %p, token %p stub!\n", iface, queue, context, callback, token );
+    return E_NOTIMPL;
+}
+
+static BOOLEAN WINAPI x_networking_XNetworkingUnregisterPreferredLocalUdpMultiplayerPortChanged( IXNetworkingImpl *iface, XTaskQueueRegistrationToken token, BOOLEAN wait )
+{
+    FIXME( "iface %p, token %p, wait %d stub!\n", iface, &token, wait );
+    return FALSE;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingQuerySecurityInformationForUrlAsync( IXNetworkingImpl *iface, LPCSTR url, XAsyncBlock *asyncBlock )
+{
+    FIXME( "iface %p, url %p, asyncBlock %p stub!\n", iface, url, asyncBlock );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingQuerySecurityInformationForUrlAsyncResultSize( IXNetworkingImpl *iface, XAsyncBlock *asyncBlock, SIZE_T *securityInformationBufferByteCount )
+{
+    FIXME( "iface %p, asyncBlock %p, securityInformationBufferByteCount %p stub!\n", iface, asyncBlock, securityInformationBufferByteCount );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingQuerySecurityInformationForUrlAsyncResult( IXNetworkingImpl *iface, XAsyncBlock *asyncBlock, SIZE_T securityInformationBufferByteCount, SIZE_T *securityInformationBufferByteCountUsed, UINT8 *securityInformationBuffer, XNetworkingSecurityInformation **securityInformation )
+{
+    FIXME( "iface %p, asyncBlock %p, securityInformationBufferByteCount %lld, securityInformationBufferByteCountUsed %p, securityInformationBuffer %p, securityInformation %p stub!\n", iface, asyncBlock, securityInformationBufferByteCount, securityInformationBufferByteCountUsed, securityInformationBuffer, securityInformation );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingQuerySecurityInformationForUrlUtf16Async( IXNetworkingImpl *iface, LPCWSTR url, XAsyncBlock *asyncBlock )
+{
+    HRESULT status;
+    IXThreadingImpl *threadingImpl;
+
+    TRACE( "iface %p, url %p, asyncBlock %p.\n", iface, url, asyncBlock );
+
+    // Threading module may be obtained from another binary.
+    status = QueryApiImpl( &CLSID_XThreadingImpl, &IID_IXThreadingImpl, (void **)&threadingImpl );
+    if ( FAILED( status ) ) return status;
+
+    struct UrlSecurityInfoContext *context = (struct UrlSecurityInfoContext *)malloc( sizeof( struct UrlSecurityInfoContext ) );
+    if ( !context ) return E_OUTOFMEMORY;
+
+    context->url = url;
+
+    status = IXThreadingImpl_XAsyncBegin( threadingImpl, asyncBlock, context, NULL, "XNetworkingQuerySecurityInformationForUrlUtf16Async", HTTPClientProvider );
+
+    if ( FAILED( status ) )
+    {
+        free( context );
+    }
+
+    return status;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingQuerySecurityInformationForUrlUtf16AsyncResultSize( IXNetworkingImpl *iface, XAsyncBlock *asyncBlock, SIZE_T *securityInformationBufferByteCount )
+{
+    HRESULT status;
+    IXThreadingImpl *threadingImpl;
+
+    TRACE( "iface %p, asyncBlock %p, securityInformationBufferByteCount %p.\n", iface, asyncBlock, securityInformationBufferByteCount );
+
+    // Threading module may be obtained from another binary.
+    status = QueryApiImpl( &CLSID_XThreadingImpl, &IID_IXThreadingImpl, (void **)&threadingImpl );
+    if ( FAILED( status ) ) return status;
+
+    status = IXThreadingImpl_XAsyncGetResultSize( threadingImpl, asyncBlock, securityInformationBufferByteCount );
+
+    return status;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingQuerySecurityInformationForUrlUtf16AsyncResult( IXNetworkingImpl *iface, XAsyncBlock *asyncBlock, SIZE_T securityInformationBufferByteCount, SIZE_T *securityInformationBufferByteCountUsed, UINT8 *securityInformationBuffer, XNetworkingSecurityInformation **securityInformation )
+{
+    HRESULT status;
+    IXThreadingImpl *threadingImpl;
+
+    TRACE( "iface %p, asyncBlock %p, securityInformationBufferByteCount %lld, securityInformationBufferByteCountUsed %p, securityInformationBuffer %p, securityInformation %p.\n", iface, asyncBlock, securityInformationBufferByteCount, securityInformationBufferByteCountUsed, securityInformationBuffer, securityInformation );
+    
+    // Threading module may be obtained from another binary.
+    status = QueryApiImpl( &CLSID_XThreadingImpl, &IID_IXThreadingImpl, (void **)&threadingImpl );
+    if ( FAILED( status ) ) return status;
+
+    status = IXThreadingImpl_XAsyncGetResult( threadingImpl, asyncBlock, NULL, securityInformationBufferByteCount, securityInformationBuffer, securityInformationBufferByteCountUsed );
+    if ( FAILED( status ) ) return status;
+
+    // Extract the XNetworkingSecurityInformation header from the buffer.
+    *securityInformation = (XNetworkingSecurityInformation *)securityInformationBuffer;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingVerifyServerCertificate( IXNetworkingImpl *iface, PVOID requestHandle, const XNetworkingSecurityInformation *securityInformation )
+{
+    FIXME( "iface %p, requestHandle %p, securityInformation %p stub!\n", iface, requestHandle, securityInformation );
+    return S_OK;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingGetConnectivityHint( IXNetworkingImpl *iface, XNetworkingConnectivityHint *connectivityHint )
+{
+    XNetworkingConnectivityHint hint;
+
+    TRACE( "iface %p, connectivityHint %p\n", iface, connectivityHint );
+
+    hint.ianaInterfaceType = 0; // There's no direct way to get NDIS interface type in userspace.
+    hint.roaming = FALSE;
+    hint.overDataLimit = FALSE;
+    hint.networkInitialized = TRUE;
+    hint.approachingDataLimit = FALSE;
+    hint.connectivityLevel = ConnectivityLevelHintInternetAccess;
+    hint.connectivityCost = ConnectivityCostHintUnrestricted;
+
+    *connectivityHint = hint;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingRegisterConnectivityHintChanged( IXNetworkingImpl *iface, XTaskQueueHandle queue, PVOID context, XNetworkingConnectivityHintChangedCallback *callback, XTaskQueueRegistrationToken *token )
+{
+    XNetworkingConnectivityHint hint;
+    FIXME( "iface %p, queue %p, context %p, callback %p, token %p stub!\n", iface, queue, context, callback, token );
+    x_networking_XNetworkingGetConnectivityHint( iface, &hint );
+    callback( context, &hint );
+    return S_OK;
+}
+
+static BOOLEAN WINAPI x_networking_XNetworkingUnregisterConnectivityHintChanged( IXNetworkingImpl *iface, XTaskQueueRegistrationToken token, BOOLEAN wait )
+{
+    FIXME( "iface %p, token %p, wait %d stub!\n", iface, &token, wait );
+    return FALSE;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingQueryConfigurationSetting( IXNetworkingImpl *iface, XNetworkingConfigurationSetting configurationSetting, UINT64 *value )
+{
+    FIXME( "iface %p, configurationSetting %d, value %p stub!\n", iface, configurationSetting, value );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingSetConfigurationSetting( IXNetworkingImpl *iface, XNetworkingConfigurationSetting configurationParameter, UINT64 value )
+{
+    FIXME( "iface %p, configurationParameter %d, value %llu stub!\n", iface, configurationParameter, value );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI x_networking_XNetworkingQueryStatistics( IXNetworkingImpl *iface, XNetworkingStatisticsBuffer *statisticsBuffer )
+{
+    FIXME( "iface %p, statisticsBuffer %p stub!\n", iface, statisticsBuffer );
+    return E_NOTIMPL;
+}
+
+static const struct IXNetworkingImplVtbl x_networking_vtbl =
+{
+    x_networking_QueryInterface,
+    x_networking_AddRef,
+    x_networking_Release,
+    /* IXNetworkingImpl methods */
+    x_networking_XNetworkingQueryPreferredLocalUdpMultiplayerPort,
+    x_networking_XNetworkingQueryPreferredLocalUdpMultiplayerPortAsync,
+    x_networking_XNetworkingQueryPreferredLocalUdpMultiplayerPortAsyncResult,
+    x_networking_XNetworkingRegisterPreferredLocalUdpMultiplayerPortChanged,
+    x_networking_XNetworkingUnregisterPreferredLocalUdpMultiplayerPortChanged,
+    x_networking_XNetworkingQuerySecurityInformationForUrlAsync,
+    x_networking_XNetworkingQuerySecurityInformationForUrlAsyncResultSize,
+    x_networking_XNetworkingQuerySecurityInformationForUrlAsyncResult,
+    x_networking_XNetworkingQuerySecurityInformationForUrlUtf16Async,
+    x_networking_XNetworkingQuerySecurityInformationForUrlUtf16AsyncResultSize,
+    x_networking_XNetworkingQuerySecurityInformationForUrlUtf16AsyncResult,
+    x_networking_XNetworkingVerifyServerCertificate,
+    x_networking_XNetworkingGetConnectivityHint,
+    x_networking_XNetworkingRegisterConnectivityHintChanged,
+    x_networking_XNetworkingUnregisterConnectivityHintChanged,
+    x_networking_XNetworkingQueryConfigurationSetting,
+    x_networking_XNetworkingSetConfigurationSetting,
+    x_networking_XNetworkingQueryStatistics,
+};
+
+static struct x_networking x_networking =
+{
+    {&x_networking_vtbl},
+    0,
+};
+
+IXNetworkingImpl *x_networking_impl = &x_networking.IXNetworkingImpl_iface;
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Networking/XNetworking.h b/dlls/xgameruntime/GDKComponent/System/Networking/XNetworking.h
new file mode 100644
index 00000000000..158394722c3
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Networking/XNetworking.h
@@ -0,0 +1,45 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XNetworking
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef XNETWORKING_H
+#define XNETWORKING_H
+
+#include "../../../private.h"
+#include "HTTPClient.h"
+
+#include <string.h>
+
+struct x_networking
+{
+    IXNetworkingImpl IXNetworkingImpl_iface;
+    LONG ref;
+};
+
+struct UrlSecurityInfoContext
+{
+    BYTE *securityInformationBuffer;
+    SIZE_T securityInformationBufferCount;
+    LPCWSTR url;
+    XNetworkingSecurityInformation *securityInformation;
+};
+
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Threading/AtomicVector.c b/dlls/xgameruntime/GDKComponent/System/Threading/AtomicVector.c
new file mode 100644
index 00000000000..d06b0f2311a
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Threading/AtomicVector.c
@@ -0,0 +1,187 @@
+/*
+ * Atomic Vector Implementation
+ *  From https://github.com/microsoft/libHttpClient
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "AtomicVector.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(xtaskqueue);
+
+static inline struct atomic_vector *impl_from_IAtomicVector( IAtomicVector *iface )
+{
+    return CONTAINING_RECORD( iface, struct atomic_vector, IAtomicVector_iface );
+}
+
+static HRESULT WINAPI atomic_vector_QueryInterface( IAtomicVector *iface, REFIID iid, void **out )
+{
+    struct atomic_vector *impl = impl_from_IAtomicVector( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IAtomicVector ))
+    {
+        *out = &impl->IAtomicVector_iface;
+        impl->IAtomicVector_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI atomic_vector_AddRef( IAtomicVector *iface )
+{
+    struct atomic_vector *impl = impl_from_IAtomicVector( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI atomic_vector_Release( IAtomicVector *iface )
+{
+    struct atomic_vector *impl = impl_from_IAtomicVector( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    if ( ref == 0 ) {
+        if ( impl->items ) 
+        {
+            free( impl->items );
+            impl->items = NULL;
+        }
+        free( impl );
+        return 0;
+    }
+    return ref;
+}
+
+static HRESULT STDMETHODCALLTYPE atomic_vector_Add( IAtomicVector* iface, PVOID value )
+{
+    SIZE_T newCapacity;
+    PVOID *newArray;
+
+    struct atomic_vector *impl = impl_from_IAtomicVector( iface );
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    AcquireSRWLockExclusive( &impl->lock );
+
+    if ( impl->size == impl->capacity ) 
+    {
+        newCapacity = impl->capacity == 0 ? 8 : impl->capacity * 2;
+        newArray = (PVOID *)realloc( impl->items, newCapacity * sizeof( PVOID ) );
+
+        if ( !newArray ) 
+        {
+            ReleaseSRWLockExclusive(&impl->lock);
+            return E_OUTOFMEMORY;
+        }
+
+        impl->items = newArray;
+        impl->capacity = newCapacity;
+    }
+
+    impl->items[impl->size++] = value;
+
+    ReleaseSRWLockExclusive( &impl->lock );
+
+    return S_OK;
+}
+
+static VOID STDMETHODCALLTYPE atomic_vector_Remove( IAtomicVector* iface, AtomicVector_Predicate predicate, PVOID predicateContext )
+{
+    SIZE_T write = 0;
+    SIZE_T read;
+    PVOID element;
+    BOOLEAN shouldRemove;
+
+    struct atomic_vector *impl = impl_from_IAtomicVector( iface );
+
+    TRACE( "iface %p, predicate %p, predicateContext %p.\n", iface, predicate, predicateContext );
+
+    AcquireSRWLockExclusive( &impl->lock );
+
+    for ( read = 0; read < impl->size; ++read ) 
+    {
+        element = impl->items[read];
+        shouldRemove = predicate( element, predicateContext );
+
+        if ( !shouldRemove ) 
+        {
+            if ( write != read ) 
+                impl->items[write] = impl->items[read];
+            write++;
+        } else 
+        {
+            // For now, do nothing.
+        }
+    }
+    impl->size = write;
+
+    ReleaseSRWLockExclusive( &impl->lock );
+}
+
+static VOID STDMETHODCALLTYPE atomic_vector_Visit( IAtomicVector* iface, AtomicVector_Visitor visitor ) 
+{
+    SIZE_T elementIterator;
+    PVOID element;
+    struct atomic_vector *impl = impl_from_IAtomicVector( iface );
+
+    TRACE( "iface %p, visitor %p, impl->size is %lld.\n", iface, visitor, impl->size );
+
+    AcquireSRWLockShared( &impl->lock );
+
+    for ( elementIterator = 0; elementIterator < impl->size; elementIterator++ ) 
+    {
+        element = impl->items[elementIterator];
+        /* call visitor with element pointer as ctx */
+        visitor( element );
+    }
+
+    ReleaseSRWLockShared( &impl->lock );
+}
+
+static const struct IAtomicVectorVtbl atomic_vector_vtbl =
+{
+    /* IUnknown methods */
+    atomic_vector_QueryInterface,
+    atomic_vector_AddRef,
+    atomic_vector_Release,
+    /* IAtomicVector methods */
+    atomic_vector_Add,
+    atomic_vector_Remove,
+    atomic_vector_Visit
+};
+
+HRESULT CreateAtomicVector( IAtomicVector **out )
+{
+    struct atomic_vector *impl;
+
+    TRACE( "out %p.\n", out );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+
+    impl->IAtomicVector_iface.lpVtbl = &atomic_vector_vtbl;
+    impl->ref = 1;
+    InitializeSRWLock( &impl->lock );
+    
+    *out = &impl->IAtomicVector_iface;
+    return S_OK;
+}
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Threading/AtomicVector.h b/dlls/xgameruntime/GDKComponent/System/Threading/AtomicVector.h
new file mode 100644
index 00000000000..b74a38419f1
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Threading/AtomicVector.h
@@ -0,0 +1,76 @@
+/*
+ * Atomic Vector Implementation
+ *  From https://github.com/microsoft/libHttpClient
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef ATOMIC_VECTOR_H
+#define ATOMIC_VECTOR_H
+
+#include "../../../private.h"
+
+typedef BOOLEAN CALLBACK (*AtomicVector_Predicate)( const void *element, void *ctx );
+typedef void CALLBACK (*AtomicVector_Visitor)(void *ctx);
+
+typedef struct IAtomicVector IAtomicVector;
+
+typedef struct IAtomicVectorVtbl {
+    /* IUnknown methods */
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IAtomicVector* This, 
+        REFIID riid, 
+        void** ppvObject);
+        
+    ULONG   (STDMETHODCALLTYPE *AddRef)(
+        IAtomicVector* This);
+
+    ULONG   (STDMETHODCALLTYPE *Release)(
+        IAtomicVector* This);
+
+    /* IAtomicVector Methods */
+    HRESULT (STDMETHODCALLTYPE *Add)(
+        IAtomicVector* This,
+        PVOID value);
+
+    VOID    (STDMETHODCALLTYPE *Remove)(
+        IAtomicVector* This,
+        AtomicVector_Predicate predicate,
+        PVOID predicateContext);
+
+    VOID    (STDMETHODCALLTYPE *Visit)(
+        IAtomicVector* This,
+        AtomicVector_Visitor visitor);
+
+} IAtomicVectorVtbl;
+
+struct IAtomicVector {
+    const IAtomicVectorVtbl* lpVtbl;
+};
+
+struct atomic_vector
+{
+    IAtomicVector IAtomicVector_iface;
+    SRWLOCK lock;
+    PVOID *items;
+    SIZE_T size, capacity;
+    LONG ref;
+};
+
+HRESULT CreateAtomicVector( IAtomicVector **out );
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Threading/ThreadPool.c b/dlls/xgameruntime/GDKComponent/System/Threading/ThreadPool.c
new file mode 100644
index 00000000000..e23166fe107
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Threading/ThreadPool.c
@@ -0,0 +1,219 @@
+/*
+ * Thread Pool Implementation
+ *  From https://github.com/microsoft/libHttpClient
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "ThreadPool.h"
+#include <winternl.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(xtaskqueue);
+
+static inline struct thread_pool *impl_from_IThreadPool( IThreadPool *iface )
+{
+    return CONTAINING_RECORD( iface, struct thread_pool, IThreadPool_iface );
+}
+
+static inline struct ThreadPoolActionStatus *impl_from_IActionStatus( IActionStatus *iface )
+{
+    return CONTAINING_RECORD( iface, struct ThreadPoolActionStatus, IActionStatus_iface );
+}
+
+static VOID WINAPI ThreadPoolActionStatus_Complete( IActionStatus *iface )
+{
+    struct ThreadPoolActionStatus *impl = impl_from_IActionStatus( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    impl->IsComplete = TRUE;
+    DisassociateCurrentThreadFromCallback( impl->instance );
+
+    return;
+}
+
+static VOID WINAPI ThreadPoolActionStatus_MayRunLong( IActionStatus *iface )
+{
+    struct ThreadPoolActionStatus *impl = impl_from_IActionStatus( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    if ( !impl->longRunning )
+    {
+        impl->longRunning = TRUE;
+        TpCallbackMayRunLong( impl->instance );
+    }
+
+    return;
+}
+
+const struct IActionStatusVtbl ThreadPoolActionStatus_vtbl =
+{
+    /* IActionStatus methods */
+    ThreadPoolActionStatus_Complete,
+    ThreadPoolActionStatus_MayRunLong
+};
+
+static void CALLBACK TPCallback( PTP_CALLBACK_INSTANCE instance, void* context, PTP_WORK work ) 
+{
+    struct thread_pool *impl = impl_from_IThreadPool( (IThreadPool *)context );
+    struct ThreadPoolActionStatus *status;
+
+    // ActionStatus offers a way for the call to
+    // provide the threadpool of its status. It
+    // can mark the call complete to indicate 
+    // all portions of the call have finished
+    // and it is safe to release the
+    // thread pool, even if the callback has
+    // not totally unwound.  This is neccessary
+    // to allow users to close a task queue from
+    // within a callback.  Task queue guards with an 
+    // extra ref to ensure a safe point where 
+    // member state is no longer accessed, but the
+    // final release does need to wait on outstanding
+    // calls.
+    //
+    // A call can also mark itself that it may run
+    // long, which is often the case for work callbacks
+    // in an async call.  This guides the thread pool
+    // to allow more threads to be created if needed.
+
+    //ActionStatusImpl status(pthis, instance);
+    if (!(status = calloc( 1, sizeof(*status) ))) return;
+
+    status->IActionStatus_iface.lpVtbl = &ThreadPoolActionStatus_vtbl;
+    status->owner = (IThreadPool *)context;
+    status->instance = instance;
+
+    impl->IThreadPool_iface.lpVtbl->AddRef( &impl->IThreadPool_iface );
+    impl->callback( impl->context, status );
+
+    if ( !status->IsComplete )
+    {
+        status->IActionStatus_iface.lpVtbl->Complete( &status->IActionStatus_iface );
+    }
+
+    impl->IThreadPool_iface.lpVtbl->Release( &impl->IThreadPool_iface ); // May delete this
+}
+
+static HRESULT WINAPI thread_pool_QueryInterface( IThreadPool *iface, REFIID iid, void **out )
+{
+    struct thread_pool *impl = impl_from_IThreadPool( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IThreadPool ))
+    {
+        *out = &impl->IThreadPool_iface;
+        impl->IThreadPool_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI thread_pool_AddRef( IThreadPool *iface )
+{
+    struct thread_pool *impl = impl_from_IThreadPool( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    if ( !ref )
+        free( impl );
+    return ref;
+}
+
+static ULONG WINAPI thread_pool_Release( IThreadPool *iface )
+{
+    struct thread_pool *impl = impl_from_IThreadPool( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI thread_pool_Initialize( IThreadPool *iface, PVOID context, ThreadPoolCallback callback )
+{
+    struct thread_pool *impl = impl_from_IThreadPool( iface );
+
+    TRACE( "iface %p, context %p, callback %p.\n", iface, context, callback );
+
+    impl->context = context;
+    impl->callback = callback;
+    impl->work = CreateThreadpoolWork( TPCallback, iface, NULL );
+
+    if ( !impl->work )
+        return HRESULT_FROM_WIN32( GetLastError() );
+
+    return S_OK;
+}
+
+static VOID WINAPI thread_pool_Terminate( IThreadPool *iface )
+{
+    struct thread_pool *impl = impl_from_IThreadPool( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    if ( !impl->work )
+    {
+        WaitForThreadpoolWorkCallbacks( impl->work, FALSE );
+        CloseThreadpoolWork( impl->work );
+        impl->work = NULL;
+    }
+
+    iface->lpVtbl->Release( iface );
+
+    return;
+}
+
+static VOID WINAPI thread_pool_Submit( IThreadPool *iface )
+{
+    struct thread_pool *impl = impl_from_IThreadPool( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    SubmitThreadpoolWork( impl->work );
+
+    return;
+}
+
+static const struct IThreadPoolVtbl thread_pool_vtbl =
+{
+    /* IUnknown methods */
+    thread_pool_QueryInterface,
+    thread_pool_AddRef,
+    thread_pool_Release,
+    thread_pool_Initialize,
+    thread_pool_Terminate,
+    thread_pool_Submit
+};
+
+HRESULT CreateIThreadPool( IThreadPool **out )
+{
+    struct thread_pool *impl;
+
+    TRACE( "out %p.\n", out );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+
+    impl->IThreadPool_iface.lpVtbl = &thread_pool_vtbl;
+    impl->ref = 1;
+    
+    *out = &impl->IThreadPool_iface;
+    return S_OK;
+}
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Threading/ThreadPool.h b/dlls/xgameruntime/GDKComponent/System/Threading/ThreadPool.h
new file mode 100644
index 00000000000..2157a28d370
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Threading/ThreadPool.h
@@ -0,0 +1,93 @@
+/*
+ * Thread Pool Implementation
+ *  From https://github.com/microsoft/libHttpClient
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef THREAD_POOL_H
+#define THREAD_POOL_H
+
+#include "../../../private.h"
+
+typedef struct IThreadPool IThreadPool;
+typedef struct IActionStatus IActionStatus;
+typedef struct IActionStatus IActionStatus;
+typedef struct ThreadPoolActionStatus ThreadPoolActionStatus;
+
+typedef void CALLBACK (*ThreadPoolCallback)(void* context, ThreadPoolActionStatus *status);
+
+typedef struct IActionStatusVtbl {
+    VOID (STDMETHODCALLTYPE *Complete)(IActionStatus *This);
+    VOID (STDMETHODCALLTYPE *MayRunLong)(IActionStatus *This);
+} IActionStatusVtbl;
+
+typedef struct IThreadPoolVtbl {
+    /* IUnknown methods */
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IThreadPool* This, 
+        REFIID riid, 
+        void** ppvObject);
+        
+    ULONG   (STDMETHODCALLTYPE *AddRef)(
+        IThreadPool* This);
+
+    ULONG   (STDMETHODCALLTYPE *Release)(
+        IThreadPool* This);
+
+    /* IThreadPool Methods */
+    HRESULT (STDMETHODCALLTYPE *Initialize)(
+        IThreadPool* This,
+        PVOID context,
+        ThreadPoolCallback callback);
+
+    VOID    (STDMETHODCALLTYPE *Terminate)(
+        IThreadPool* This);
+
+    VOID    (STDMETHODCALLTYPE *Submit)(
+        IThreadPool* This);
+} IThreadPoolVtbl;
+
+struct IThreadPool {
+    const IThreadPoolVtbl* lpVtbl;
+};
+
+struct IActionStatus {
+    const IActionStatusVtbl* lpVtbl;
+};
+
+struct ThreadPoolActionStatus {
+    IActionStatus IActionStatus_iface;
+    
+    IThreadPool* owner;
+    PTP_CALLBACK_INSTANCE instance;
+    BOOLEAN longRunning;
+    BOOLEAN IsComplete;
+};
+
+struct thread_pool {
+    IThreadPool IThreadPool_iface;
+
+    LONG ref;
+    PTP_WORK work;
+    PVOID context;
+    ThreadPoolCallback callback;
+};
+
+HRESULT CreateIThreadPool( IThreadPool **out );
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Threading/XAsync.c b/dlls/xgameruntime/GDKComponent/System/Threading/XAsync.c
new file mode 100644
index 00000000000..13c5a2e8ea9
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Threading/XAsync.c
@@ -0,0 +1,956 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XAsync
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "XAsync.h"
+#include "XTaskQueue.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(xtaskqueue);
+
+static inline struct x_async_block_guard *impl_from_IXAsyncBlockInternalGuard( IXAsyncBlockInternalGuard *iface )
+{
+    return CONTAINING_RECORD( iface, struct x_async_block_guard, IXAsyncBlockInternalGuard_iface );
+}
+
+static inline struct async_state *impl_from_IAsyncState( IAsyncState *iface )
+{
+    return CONTAINING_RECORD( iface, struct async_state, IAsyncState_iface );
+}
+
+static HRESULT WINAPI selfProviderOperation( XAsyncOp op, const XAsyncProviderData* data )
+{
+    XAsyncWork* work;
+    HRESULT hr;
+
+    switch ( op )
+    {
+        case Begin:
+            return XAsyncSchedule(data->async, 0);
+                
+        case DoWork:
+            work = (XAsyncWork *)data->context;
+            hr = work( data->async );
+            XAsyncComplete( data->async, hr, 0 );
+            break;
+
+        case Cancel:
+        case Cleanup:
+        case GetResult:
+            break;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI async_state_QueryInterface( IAsyncState *iface, REFIID iid, void **out )
+{
+    struct async_state *impl = impl_from_IAsyncState( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IAsyncState ))
+    {
+        *out = &impl->IAsyncState_iface;
+        impl->IAsyncState_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI async_state_AddRef( IAsyncState *iface )
+{
+    struct async_state *impl = impl_from_IAsyncState( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI async_state_Release( IAsyncState *iface )
+{
+    struct async_state *impl = impl_from_IAsyncState( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static const struct IAsyncStateVtbl async_state_vtbl =
+{
+    /* IUnknown methods */
+    async_state_QueryInterface,
+    async_state_AddRef,
+    async_state_Release
+};
+
+static HRESULT WINAPI x_async_block_guard_QueryInterface( IXAsyncBlockInternalGuard *iface, REFIID iid, void **out )
+{
+    struct x_async_block_guard *impl = impl_from_IXAsyncBlockInternalGuard( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IXAsyncBlockInternalGuard ))
+    {
+        *out = &impl->IXAsyncBlockInternalGuard_iface;
+        impl->IXAsyncBlockInternalGuard_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI x_async_block_guard_AddRef( IXAsyncBlockInternalGuard *iface )
+{
+    struct x_async_block_guard *impl = impl_from_IXAsyncBlockInternalGuard( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI x_async_block_guard_Release( IXAsyncBlockInternalGuard *iface )
+{
+    struct x_async_block_guard *impl = impl_from_IXAsyncBlockInternalGuard( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static IAsyncState* WINAPI x_async_block_guard_GetState( IXAsyncBlockInternalGuard *iface )
+{
+    struct x_async_block_guard *impl = impl_from_IXAsyncBlockInternalGuard( iface );
+    struct async_state *state = impl_from_IAsyncState( impl->internal->state );
+
+    TRACE( "iface %p, state is %p.\n", iface, impl->internal->state );
+
+    if ( impl->internal->state != NULL && state->signature != ASYNC_STATE_SIG )
+    {
+        return NULL;
+    }
+
+    if ( impl->internal->state != NULL )
+        impl->internal->state->lpVtbl->AddRef( impl->internal->state );
+
+    return impl->internal->state;
+}
+
+static IAsyncState* WINAPI x_async_block_guard_ExtractState( IXAsyncBlockInternalGuard *iface, BOOLEAN resultsRetrieved )
+{    
+    struct x_async_block_guard *impl = impl_from_IXAsyncBlockInternalGuard( iface );
+    struct async_state *state = impl_from_IAsyncState( impl->internal->state );
+
+    TRACE( "iface %p, resultsRetrieved %d.\n", iface, resultsRetrieved );
+
+    if ( impl->internal->state != NULL && state->signature != ASYNC_STATE_SIG )
+    {
+        return NULL;
+    }
+
+    if ( resultsRetrieved )
+    {
+        impl->internal->signature = ASYNC_BLOCK_RESULT_SIG;
+        impl->userInternal->signature = ASYNC_BLOCK_RESULT_SIG;
+    }
+    else
+    {
+        impl->internal->signature = 0;
+        impl->userInternal->signature = 0;
+    }
+
+    return impl->internal->state;
+}
+
+static HRESULT WINAPI x_async_block_guard_GetStatus( IXAsyncBlockInternalGuard *iface )
+{
+    struct x_async_block_guard *impl = impl_from_IXAsyncBlockInternalGuard( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return impl->internal->status;
+}
+
+static BOOLEAN WINAPI x_async_block_guard_GetResultsRetrieved( IXAsyncBlockInternalGuard *iface )
+{
+    struct x_async_block_guard *impl = impl_from_IXAsyncBlockInternalGuard( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return impl->internal->signature == ASYNC_BLOCK_RESULT_SIG;
+}
+
+static BOOLEAN WINAPI x_async_block_guard_TrySetTerminalStatus( IXAsyncBlockInternalGuard *iface, HRESULT status )
+{
+    struct x_async_block_guard *impl = impl_from_IXAsyncBlockInternalGuard( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    if ( impl->locked && impl->internal->status == E_PENDING )
+    {
+        impl->userInternal->status = status;
+        impl->internal->status = status;
+
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+}
+
+static AsyncBlockInternal* x_async_block_guard_DoLock( XAsyncBlock* asyncBlock )
+{
+    AsyncBlockInternal* lockedResult;
+    AsyncBlockInternal* stateAsyncBlockInternal;
+
+    struct async_state *state = NULL;
+
+    TRACE( "asyncBlock %p.\n", asyncBlock );
+
+    if ( !asyncBlock )
+        return NULL;
+
+    lockedResult = (AsyncBlockInternal *)asyncBlock->internal;
+
+    if ( lockedResult->signature != ASYNC_BLOCK_SIG )
+    {
+        lockedResult->state = NULL;
+        return NULL;
+    }
+
+    EnterCriticalSection( &lockedResult->lock );
+
+    state = impl_from_IAsyncState( lockedResult->state );
+
+    if ( lockedResult->state == NULL || asyncBlock == &state->providerAsyncBlock )
+        return lockedResult;
+
+    lockedResult->state->lpVtbl->AddRef( lockedResult->state );
+
+    LeaveCriticalSection( &lockedResult->lock );
+
+    stateAsyncBlockInternal = (AsyncBlockInternal *)state->providerAsyncBlock.internal;
+    if ( stateAsyncBlockInternal == NULL )
+    {
+        EnterCriticalSection( &lockedResult->lock );
+        lockedResult->state->lpVtbl->Release( lockedResult->state );
+        return lockedResult;
+    }
+
+    EnterCriticalSection( &stateAsyncBlockInternal->lock );
+
+    if ( stateAsyncBlockInternal->state == NULL )
+    {
+        LeaveCriticalSection( &stateAsyncBlockInternal->lock );
+        EnterCriticalSection( &lockedResult->lock );
+        lockedResult->state->lpVtbl->Release( lockedResult->state );
+        return lockedResult;
+    }
+
+    lockedResult->state->lpVtbl->Release( lockedResult->state );
+    return stateAsyncBlockInternal;
+}
+
+static const struct IXAsyncBlockInternalGuardVtbl x_async_block_guard_vtbl =
+{
+    /* IUnknown methods */
+    x_async_block_guard_QueryInterface,
+    x_async_block_guard_AddRef,
+    x_async_block_guard_Release,
+    /* IXAsyncBlockInternalGuard methods */
+    x_async_block_guard_GetState,
+    x_async_block_guard_ExtractState,
+    x_async_block_guard_GetStatus,
+    x_async_block_guard_GetResultsRetrieved,
+    x_async_block_guard_TrySetTerminalStatus,
+    x_async_block_guard_DoLock
+};
+
+static VOID InitInternalGuardFromBlock( IXAsyncBlockInternalGuard *iface, XAsyncBlock* asyncBlock )
+{   
+    struct async_state *state = NULL;
+    struct x_async_block_guard *impl = impl_from_IXAsyncBlockInternalGuard( iface );
+
+    TRACE( "iface %p, asyncBlock %p.\n", iface, asyncBlock );
+
+    impl->internal = iface->lpVtbl->DoLock( asyncBlock );
+    impl->locked = impl->internal != NULL;
+
+    if ( !impl->locked )
+    {
+        // We never locked because the block contains an invalid signature.  We still
+        // need the block for access though (although that access will be read only).
+        impl->internal = (AsyncBlockInternal *)asyncBlock->internal;
+    }
+
+    if ( impl->internal->state != NULL )
+    {
+        state = impl_from_IAsyncState( impl->internal->state );
+        impl->userInternal = (AsyncBlockInternal *)state->userAsyncBlock->internal;
+    }
+    else
+    {
+        impl->userInternal = impl->internal;
+    }
+
+    // If user internal != internal, we grab its lock.  Note that
+    // lock ordering here is critical.  It must always be 
+    // state lock, then user lock.  If state is not available, then
+    // it is just user lock.
+
+    /*
+    if ( impl->userInternal != impl->internal )
+    {
+        TRACE("got here!\n");
+        EnterCriticalSection( &impl->userInternal->lock );
+    }*/
+
+    return;
+}
+
+static HRESULT AllocStateNoCompletion( XAsyncBlock* asyncBlock, AsyncBlockInternal* internal, size_t contextSize )
+{
+    struct async_state* stateImpl; 
+
+    XTaskQueueHandle queue;
+
+    TRACE( "asyncBlock %p, internal %p, contextSize %lld.\n", asyncBlock, internal, contextSize );
+
+    if (!(stateImpl = calloc( 1, sizeof(*stateImpl) ))) return E_OUTOFMEMORY;
+
+    stateImpl->IAsyncState_iface.lpVtbl = &async_state_vtbl;
+    stateImpl->ref = 1;
+    InitializeConditionVariable( &stateImpl->cv );
+    InitializeCriticalSection( &stateImpl->cs );
+    stateImpl->signature = ASYNC_STATE_SIG;
+    stateImpl->providerCleanup = CleanupLocation_Destructor;
+    stateImpl->valid = TRUE;
+
+    if ( contextSize != 0 )
+    {
+        // User allocated additional context data.  This was allocated as extra bytes at the end of 
+        // async state.
+        stateImpl->providerData.context = (&stateImpl->IAsyncState_iface + 1);
+    }
+    
+    // Addref the task queue. We duplicate with "Reference" to prevent spamming
+    // the handle tracker with each async call (and to prevent a needless allocation of
+    // the task queue handle wrapper).
+
+    queue = asyncBlock->queue;
+    if ( queue == NULL )
+    {
+        if ( IXThreadingImpl_XTaskQueueGetCurrentProcessTaskQueue( x_threading_impl, &stateImpl->queue ) == FALSE )
+        {
+            return HRESULT_FROM_WIN32( ERROR_NO_TASK_QUEUE );
+        }
+    }
+    else
+    {
+        queue->headQueue->lpVtbl->AddRef( queue->headQueue );
+        stateImpl->queue = queue;
+    }
+
+    stateImpl->userAsyncBlock = asyncBlock;
+    stateImpl->providerData.async = &stateImpl->providerAsyncBlock;
+
+    // Note: needs to be the last failable thing we do.
+    //hr = XTaskQueueSuspendTermination( stateImpl->queue );
+
+    internal->state = &stateImpl->IAsyncState_iface;
+
+    // Duplicate the async block we've just configured
+    stateImpl->providerAsyncBlock = *asyncBlock;
+    stateImpl->providerAsyncBlock.queue = stateImpl->queue;
+
+    return S_OK;
+}
+
+static HRESULT AllocState( XAsyncBlock* asyncBlock, SIZE_T contextSize )
+{
+    UINT32 internalIterator;
+    HRESULT hr;
+    AsyncBlockInternal* internal;
+
+    TRACE( "asyncBlock %p, contextSize %lld.\n", asyncBlock, contextSize );
+
+    if ( !asyncBlock )
+        return E_INVALIDARG;
+
+    internal = (AsyncBlockInternal *)asyncBlock->internal;
+
+    // If the async block is already associated with another
+    // call, fail.
+
+    // We need to guard against use of an active async block.  We don't want
+    // to rely on the caller zeroing memory so we check a signature
+    // DWORD. This signature is cleared when the block can be reused.
+    if ( internal->signature == ASYNC_BLOCK_SIG )
+        return E_INVALIDARG;
+
+    // This could be a reused async block from a prior
+    // call, so zero everything.
+    for ( internalIterator = 0; internalIterator < sizeof( asyncBlock->internal ); internalIterator++ )
+    {
+        asyncBlock->internal[internalIterator] = 0;
+    }
+
+    // Construction is inherently single threaded
+    // (there is nothing we can do if the client tries to use the same
+    // XAsyncBlock in 2 calls at the same time)
+
+    internal->signature = ASYNC_BLOCK_SIG;
+    InitializeCriticalSection( &internal->lock );
+    
+    hr = AllocStateNoCompletion( asyncBlock, internal, contextSize );
+
+    if ( FAILED( hr ) )
+    {
+        internal->signature = 0;
+        internal->status = hr;
+    }
+
+    return hr;
+}
+
+static void CleanupProviderForLocation( IAsyncState *state, ProviderCleanupLocation location )
+{
+    struct async_state *stateImpl = impl_from_IAsyncState( state );
+
+    TRACE( "state %p, location %d.\n", state, location );
+    
+    if ( InterlockedCompareExchange( &stateImpl->providerCleanup, 0, 0 ) == InterlockedCompareExchange( &stateImpl->providerCleanup, location, CleanupLocation_CleanedUp ) )
+    {
+        stateImpl->providerCallback( Cleanup, &stateImpl->providerData );
+    }
+
+    return;
+}
+
+static BOOLEAN TrySetProviderCleanup( IAsyncState* state, ProviderCleanupLocation location )
+{
+    struct async_state *stateImpl = impl_from_IAsyncState( state );
+
+    ProviderCleanupLocation expected = CleanupLocation_Destructor;
+
+    TRACE( "state %p, location %d.\n", state, location );
+
+    return InterlockedCompareExchange( &stateImpl->providerCleanup, 0, 0 ) == InterlockedCompareExchange( &stateImpl->providerCleanup, expected, location );
+}
+
+static VOID RevertProviderCleanup( IAsyncState* state, _In_ ProviderCleanupLocation expected )
+{
+    struct async_state *stateImpl = impl_from_IAsyncState( state );
+
+    TRACE( "state %p, expected %d.\n", state, expected );
+    
+    InterlockedCompareExchange( &stateImpl->providerCleanup, expected, CleanupLocation_Destructor );
+
+    return;
+}
+
+static void SignalWait( IAsyncState* state )
+{
+    BOOLEAN newlySatisfied;
+
+    struct async_state *stateImpl = impl_from_IAsyncState( state );
+
+    TRACE( "state %p.\n", state );
+
+    EnterCriticalSection( &stateImpl->cs );
+    newlySatisfied = !stateImpl->waitSatisfied;
+    stateImpl->waitSatisfied = TRUE;
+    WakeAllConditionVariable( &stateImpl->cv );
+    LeaveCriticalSection( &stateImpl->cs );
+
+
+    // We should only come in here once, but we don't want
+    // to underflow task queue resumes and we already know
+    // from above if we're first marking this wait as
+    // satisfied, so use it.
+
+    if ( newlySatisfied )
+    {
+        XTaskQueueResumeTermination( stateImpl->queue );
+    }
+}
+
+static void CALLBACK CompletionCallback( void* context, BOOL canceled )
+{
+    IAsyncState *state = (IAsyncState *)context;
+    XAsyncBlock* asyncBlock;
+
+    struct async_state *stateImpl = impl_from_IAsyncState( state );
+
+    TRACE( "context %p, canceled %d.\n", context, canceled );
+
+    // We always pass the user async block into the 
+    // callback, but we don't trust it -- we check
+    // the callback field on our internal copy.
+    asyncBlock = stateImpl->userAsyncBlock;
+    if ( stateImpl->providerAsyncBlock.callback != NULL )
+    {
+        stateImpl->providerAsyncBlock.callback(asyncBlock);
+    }
+
+    SignalWait( state );
+}
+
+static HRESULT SignalCompletion( IAsyncState *state )
+{
+    HRESULT hr = S_OK;
+
+    struct async_state *stateImpl = impl_from_IAsyncState( state );
+
+    TRACE( "state %p.\n", state );
+
+    if ( stateImpl->providerData.async->callback != NULL )
+    {
+        state->lpVtbl->AddRef( state );
+        hr = XTaskQueueSubmitDelayedCallback( stateImpl->queue, Completion, 0, (PVOID)state, CompletionCallback );
+
+        if ( SUCCEEDED( hr ) )
+        {
+            state->lpVtbl->Release( state );
+        }
+    }
+    else
+    {
+        SignalWait( state );
+    }
+
+    return hr;
+}
+
+static void CleanupState( IAsyncState *state)
+{
+    struct async_state *stateImpl = impl_from_IAsyncState( state );
+
+    TRACE( "state %p.\n", state );
+
+    if ( state != NULL )
+    {
+        stateImpl->valid = FALSE;
+        state->lpVtbl->Release( state );
+    }
+}
+
+
+static void CALLBACK WorkerCallback( PVOID context, BOOL canceled )
+{
+    HRESULT callStatus;
+    IAsyncState *state = (IAsyncState *)context;
+
+    struct x_async_block_guard *impl;
+    struct async_state *stateImpl = impl_from_IAsyncState( state );
+
+    TRACE( "context %p, canceled %d.\n", context, canceled );
+
+    if ( !stateImpl->valid )
+        return;
+
+    stateImpl->workScheduled = FALSE;
+
+    // If the queue is canceling callbacks, simply cancel this work. Since no
+    // new work for this call will be scheduled, if the call didn't cancel
+    // immediately do it ourselves.
+
+    if ( canceled )
+    {
+        XAsyncCancel( stateImpl->userAsyncBlock );
+
+        if (!(impl = calloc( 1, sizeof(*impl) ))) return;
+
+        impl->IXAsyncBlockInternalGuard_iface.lpVtbl = &x_async_block_guard_vtbl;
+        impl->ref = 1;
+        impl->locked = FALSE;
+
+        {
+            InitInternalGuardFromBlock( &impl->IXAsyncBlockInternalGuard_iface, stateImpl->userAsyncBlock );
+            callStatus = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->GetStatus( &impl->IXAsyncBlockInternalGuard_iface );
+        }
+
+        if ( callStatus != E_ABORT )
+        {
+            XAsyncComplete( stateImpl->userAsyncBlock, E_ABORT, 0 );
+        }
+
+        if ( impl->locked )
+        {
+            LeaveCriticalSection( &impl->internal->lock );
+            if ( impl->userInternal != impl->internal )
+            {
+                LeaveCriticalSection( &impl->userInternal->lock );
+            }
+        }
+
+        free( impl );
+    }
+    else
+    {
+        callStatus = stateImpl->providerCallback( DoWork, &stateImpl->providerData );
+
+        // Work routine can return E_PENDING if there is more work to do.  Otherwise
+        // it either needs to be a failure or it should have called XAsyncComplete, which
+        // would have set a new value into the status.
+
+        if ( callStatus != E_PENDING )
+        {
+            if ( SUCCEEDED( callStatus ) )
+            {
+                callStatus = E_UNEXPECTED;
+            }
+
+            XAsyncComplete( &stateImpl->providerAsyncBlock, callStatus, 0 );
+        }
+    }
+
+    // If the result of this call caused a completion with no payload, XAsyncComplete
+    // will change the provider cleanup to be "AfterWork", which is here.  Cleanup
+    // the provider if we need to.
+    CleanupProviderForLocation( state, CleanupLocation_AfterDoWork );
+}
+
+HRESULT XAsyncGetStatus( XAsyncBlock* asyncBlock, BOOLEAN wait )
+{
+    HRESULT result = E_PENDING;
+    IAsyncState *state;
+
+    struct x_async_block_guard *impl;
+    struct async_state *stateImpl = NULL;
+
+    TRACE( "asyncBlock %p, wait %d.\n", asyncBlock, wait );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+
+    impl->IXAsyncBlockInternalGuard_iface.lpVtbl = &x_async_block_guard_vtbl;
+    impl->ref = 1;
+    impl->locked = FALSE;
+
+    {
+        InitInternalGuardFromBlock( &impl->IXAsyncBlockInternalGuard_iface, asyncBlock );
+        result = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->GetStatus( &impl->IXAsyncBlockInternalGuard_iface );
+        state = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->GetState( &impl->IXAsyncBlockInternalGuard_iface );
+        stateImpl = impl_from_IAsyncState( state );
+    }
+
+    // If we are being asked to wait, always check the wait state before
+    // looking at the hresult.  Our wait waits until the completion runs
+    // so we may need to wait past when the status is set.
+
+    if ( wait )
+    {
+        if ( state == NULL )
+        {
+            if ( result == E_PENDING )
+                return E_INVALIDARG;
+        }
+        else
+        {
+            EnterCriticalSection( &stateImpl->cs );
+
+            if ( !stateImpl->waitSatisfied )
+            {
+                SleepConditionVariableCS( &stateImpl->cv, &stateImpl->cs, INFINITE );
+            }
+            result = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->GetStatus( &impl->IXAsyncBlockInternalGuard_iface );    
+        }
+    }
+
+    if ( impl->locked )
+    {
+        LeaveCriticalSection( &impl->internal->lock );
+        if ( impl->userInternal != impl->internal )
+        {
+            LeaveCriticalSection( &impl->userInternal->lock );
+        }
+    }
+
+    free( impl );
+
+    return result;
+}
+
+HRESULT XAsyncGetResultSize( XAsyncBlock* asyncBlock, SIZE_T* bufferSize )
+{
+    HRESULT result = E_PENDING;
+    IAsyncState *state;
+
+    struct x_async_block_guard *impl;
+    struct async_state *stateImpl = NULL;
+
+    TRACE( "asyncBlock %p, bufferSize %p.\n", asyncBlock, bufferSize );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+
+    impl->IXAsyncBlockInternalGuard_iface.lpVtbl = &x_async_block_guard_vtbl;
+    impl->ref = 1;
+    impl->locked = FALSE;
+
+    {
+        //constructor
+        InitInternalGuardFromBlock( &impl->IXAsyncBlockInternalGuard_iface, asyncBlock );
+        result = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->GetStatus( &impl->IXAsyncBlockInternalGuard_iface );
+        state = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->GetState( &impl->IXAsyncBlockInternalGuard_iface );
+        stateImpl = impl_from_IAsyncState( state );
+    }
+
+    *bufferSize = state == NULL ? 0 : stateImpl->providerData.bufferSize;
+
+    //destructor
+    if ( impl->locked )
+    {
+        LeaveCriticalSection( &impl->internal->lock );
+        if ( impl->userInternal != impl->internal )
+        {
+            LeaveCriticalSection( &impl->userInternal->lock );
+        }
+    }
+
+    free( impl );
+
+    return result;
+}
+
+VOID XAsyncCancel( XAsyncBlock* asyncBlock )
+{
+    IAsyncState *state;
+
+    struct x_async_block_guard *impl;
+    struct async_state *stateImpl = NULL;
+
+    TRACE( "asyncBlock %p.\n", asyncBlock );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return;
+
+    impl->IXAsyncBlockInternalGuard_iface.lpVtbl = &x_async_block_guard_vtbl;
+    impl->ref = 1;
+    impl->locked = FALSE;
+
+    {
+        InitInternalGuardFromBlock( &impl->IXAsyncBlockInternalGuard_iface, asyncBlock );
+        state = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->GetState( &impl->IXAsyncBlockInternalGuard_iface );
+        stateImpl = impl_from_IAsyncState( state );
+    }
+
+    if ( state != NULL )
+    {
+        // In case of cancel, failure, or success with no payload we will
+        // agressively clean up the provider at the end of DoWork. This can race
+        // with a cancel call. To prevent this we mark the provider cleanup as
+        // "in cancel", which prevents switching it to the aggressive DoWork
+        // cleanup.  We switch out of "in cancel" when done.  In the worst case this
+        // will defer provider cleanup to the state destructor, which is the natural
+        // place for it anyway.  Anything else here is just an optimization to get the
+        // provider cleaned up sooner (the destructor location may be delayed until the
+        // completion callback fires, since it's hanging on to a state object ref).
+
+        if ( TrySetProviderCleanup( state, CleanupLocation_InCancel ) )
+        {
+            stateImpl->providerCallback( Cancel, &stateImpl->providerData );
+            RevertProviderCleanup( state, CleanupLocation_InCancel );
+        }
+    }
+
+    if ( impl->locked )
+    {
+        LeaveCriticalSection( &impl->internal->lock );
+        if ( impl->userInternal != impl->internal )
+        {
+            LeaveCriticalSection( &impl->userInternal->lock );
+        }
+    }
+
+    free( impl );
+}
+
+HRESULT XAsyncRun( XAsyncBlock* asyncBlock, XAsyncWork* work )
+{
+    HRESULT hr = S_OK;
+
+    TRACE( "asyncBlock %p, work %p.\n", asyncBlock, work );
+
+    hr = XAsyncBegin( asyncBlock, (PVOID)work, (PVOID)XAsyncRun, "XAsyncRun", selfProviderOperation );
+
+    return hr;
+}
+
+HRESULT XAsyncBegin( XAsyncBlock* asyncBlock, PVOID context, PVOID identity, LPCSTR identityName, XAsyncProviderCallback* provider )
+{
+    HRESULT hr;
+    IAsyncState *state;
+
+    struct x_async_block_guard *impl;
+    struct async_state *stateImpl = NULL;
+
+    TRACE( "asyncBlock %p, context %p, identity %p, identityName %s, provider %p.\n", asyncBlock, context, identity, identityName, provider );
+
+    hr = AllocState( asyncBlock, 0 );
+    if ( FAILED( hr ) ) return hr;
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+
+    impl->IXAsyncBlockInternalGuard_iface.lpVtbl = &x_async_block_guard_vtbl;
+    impl->ref = 1;
+    impl->locked = FALSE;
+
+    {
+        InitInternalGuardFromBlock( &impl->IXAsyncBlockInternalGuard_iface, asyncBlock );
+        state = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->GetState( &impl->IXAsyncBlockInternalGuard_iface );
+        stateImpl = impl_from_IAsyncState( state );
+    }
+
+    stateImpl->providerCallback = provider;
+    stateImpl->identity = identity;
+    stateImpl->identityName = identityName;
+    stateImpl->providerData.context = context;
+
+    hr = stateImpl->providerCallback( Begin, &stateImpl->providerData );
+    if ( FAILED( hr ) )
+    {
+        XAsyncComplete( asyncBlock, hr, 0 );
+    }
+
+    return S_OK;
+}
+
+HRESULT XAsyncSchedule( XAsyncBlock* asyncBlock, UINT32 delayInMs )
+{
+    HRESULT hr;
+    HRESULT exitingStatus;
+    BOOLEAN priorScheduled;
+    IAsyncState *state;
+
+    struct x_async_block_guard *impl;
+    struct async_state *stateImpl = NULL;
+
+    TRACE( "asyncBlock %p, delayInMs %d.\n", asyncBlock, delayInMs );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+
+    impl->IXAsyncBlockInternalGuard_iface.lpVtbl = &x_async_block_guard_vtbl;
+    impl->ref = 1;
+    impl->locked = FALSE;
+
+    {
+        InitInternalGuardFromBlock( &impl->IXAsyncBlockInternalGuard_iface, asyncBlock );
+        state = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->GetState( &impl->IXAsyncBlockInternalGuard_iface );
+        exitingStatus = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->GetStatus( &impl->IXAsyncBlockInternalGuard_iface );
+        stateImpl = impl_from_IAsyncState( state );
+    }
+
+    if ( FAILED( exitingStatus ) && exitingStatus != E_PENDING )
+        return exitingStatus;
+
+    if ( state == NULL )
+        return E_INVALIDARG;
+
+    priorScheduled = FALSE;
+    InterlockedCompareExchange( &stateImpl->workScheduled, priorScheduled, TRUE );
+
+    if ( priorScheduled )
+    {
+        return E_UNEXPECTED;
+    }
+
+    state->lpVtbl->AddRef( state );
+
+    hr = XTaskQueueSubmitDelayedCallback( stateImpl->queue, Work, delayInMs, (PVOID)state, WorkerCallback );
+
+    state->lpVtbl->Release( state );
+
+    free( impl );
+
+    return hr;
+}
+
+VOID XAsyncComplete( XAsyncBlock* asyncBlock, HRESULT result, SIZE_T requiredBufferSize )
+{
+    // E_PENDING is special -- if you still have work to do don't complete.
+    HRESULT hr;
+    BOOLEAN completedNow;
+    BOOLEAN doCleanup;
+    IAsyncState *state;
+
+    struct x_async_block_guard *impl;
+    struct async_state *stateImpl = NULL;
+
+    TRACE( "asyncBlock %p, result %#lx, requiredBufferSize %lld.\n", asyncBlock, result, requiredBufferSize );
+
+    if ( result == E_PENDING )
+    {
+        return;
+    }
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return;
+
+    impl->IXAsyncBlockInternalGuard_iface.lpVtbl = &x_async_block_guard_vtbl;
+    impl->ref = 1;
+    impl->locked = FALSE;
+
+    InitInternalGuardFromBlock( &impl->IXAsyncBlockInternalGuard_iface, asyncBlock );
+
+    completedNow = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->TrySetTerminalStatus( &impl->IXAsyncBlockInternalGuard_iface, result );
+
+    if ( (requiredBufferSize == 0 || FAILED( result )) && completedNow )
+    {
+        doCleanup = TRUE;
+        requiredBufferSize = 0;
+        state = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->ExtractState( &impl->IXAsyncBlockInternalGuard_iface, FALSE );
+    }
+    else
+    {
+        state = impl->IXAsyncBlockInternalGuard_iface.lpVtbl->GetState( &impl->IXAsyncBlockInternalGuard_iface );
+    }
+
+    if ( !state )
+    {
+        WARN( "called from an invalid block!\n" );
+        return;
+    }
+
+    stateImpl = impl_from_IAsyncState( state );
+
+    if ( completedNow )
+    {
+        stateImpl->providerData.bufferSize = requiredBufferSize;
+    }
+
+    // Only signal / adjust needed buffer size if we were first to complete.
+    if ( completedNow )
+    {
+        hr = SignalCompletion( state );
+        if ( FAILED( hr ) ) return;
+    }
+
+    // At this point asyncBlock may be unsafe to touch. As we've cleaned up
+    // state we will mark the state so that the DoWork callback calls
+    // the Cleanup op on the provider.  This gets it cleaned up sooner
+    // so it doesn't have to wait for the task queue to process it.
+
+    if ( doCleanup )
+    {
+        TrySetProviderCleanup( state, CleanupLocation_AfterDoWork );
+        CleanupState( state );
+    }
+}
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Threading/XAsync.h b/dlls/xgameruntime/GDKComponent/System/Threading/XAsync.h
new file mode 100644
index 00000000000..41709cdb751
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Threading/XAsync.h
@@ -0,0 +1,143 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XAsync
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef XASYNC_H
+#define XASYNC_H
+
+#include "../../../private.h"
+
+#define ASYNC_BLOCK_SIG         0x41535942 // ASYB
+#define ASYNC_BLOCK_RESULT_SIG  0x41535242 // ASRB
+#define ASYNC_STATE_SIG         0x41535445 // ASTE
+
+typedef struct IXAsyncBlockInternalGuard IXAsyncBlockInternalGuard;
+typedef struct IAsyncState IAsyncState;
+
+typedef enum ProviderCleanupLocation
+{
+    CleanupLocation_Destructor,
+    CleanupLocation_AfterDoWork,
+    CleanupLocation_InCancel,
+    CleanupLocation_CleanedUp
+} ProviderCleanupLocation;
+
+typedef struct AsyncBlockInternal
+{
+    IAsyncState* state;
+    HRESULT status;
+    DWORD signature;
+    CRITICAL_SECTION lock;
+} AsyncBlockInternal;
+
+typedef struct IXAsyncBlockInternalGuardVtbl {
+    /* IUnknown methods */
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IXAsyncBlockInternalGuard* This, 
+        REFIID riid, 
+        void** ppvObject);
+        
+    ULONG   (STDMETHODCALLTYPE *AddRef)(
+        IXAsyncBlockInternalGuard* This);
+
+    ULONG   (STDMETHODCALLTYPE *Release)(
+        IXAsyncBlockInternalGuard* This);
+
+    IAsyncState* (STDMETHODCALLTYPE *GetState)(
+        IXAsyncBlockInternalGuard* This);
+
+    IAsyncState* (STDMETHODCALLTYPE *ExtractState)(
+        IXAsyncBlockInternalGuard* This,
+        BOOLEAN resultsRetrieved);
+
+    HRESULT (STDMETHODCALLTYPE *GetStatus)(
+        IXAsyncBlockInternalGuard* This);
+
+    BOOLEAN (STDMETHODCALLTYPE *GetResultsRetrieved)(
+        IXAsyncBlockInternalGuard* This);
+
+    BOOLEAN (STDMETHODCALLTYPE *TrySetTerminalStatus)(
+        IXAsyncBlockInternalGuard* This,
+        HRESULT status);
+
+    AsyncBlockInternal* (*DoLock)(
+        XAsyncBlock* asyncBlock);
+} IXAsyncBlockInternalGuardVtbl;
+
+typedef struct IAsyncStateVtbl {
+    /* IUnknown methods */
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IAsyncState* This, 
+        REFIID riid, 
+        void** ppvObject);
+        
+    ULONG   (STDMETHODCALLTYPE *AddRef)(
+        IAsyncState* This);
+
+    ULONG   (STDMETHODCALLTYPE *Release)(
+        IAsyncState* This);
+} IAsyncStateVtbl;
+
+struct IAsyncState {
+    const IAsyncStateVtbl* lpVtbl;
+};
+
+struct IXAsyncBlockInternalGuard {
+    const IXAsyncBlockInternalGuardVtbl* lpVtbl;
+};
+
+struct async_state
+{
+    IAsyncState IAsyncState_iface;
+    UINT32 signature;
+    LONG ref;
+    LONG /* ProviderCleanupLocation */ providerCleanup;
+    LONG workScheduled;
+    BOOLEAN valid;
+    XAsyncProviderCallback *providerCallback;
+    XAsyncProviderData providerData;
+    XAsyncBlock providerAsyncBlock;
+    XAsyncBlock* userAsyncBlock;
+    XTaskQueueHandle queue;
+    CRITICAL_SECTION cs;
+    CONDITION_VARIABLE cv;
+    BOOLEAN waitSatisfied;
+    LPCSTR identity;
+    LPCSTR identityName;
+};
+
+struct x_async_block_guard
+{
+    IXAsyncBlockInternalGuard IXAsyncBlockInternalGuard_iface;
+    AsyncBlockInternal *internal;
+    AsyncBlockInternal *userInternal;
+    BOOLEAN locked;
+    LONG ref;
+};
+
+HRESULT XAsyncGetStatus( XAsyncBlock* asyncBlock, BOOLEAN wait );
+HRESULT XAsyncGetResultSize( XAsyncBlock* asyncBlock, SIZE_T* bufferSize );
+VOID XAsyncCancel( XAsyncBlock* asyncBlock );
+HRESULT XAsyncRun( XAsyncBlock* asyncBlock, XAsyncWork* work );
+HRESULT XAsyncBegin( XAsyncBlock* asyncBlock, PVOID context, PVOID identity, LPCSTR identityName, XAsyncProviderCallback* provider );
+HRESULT XAsyncSchedule( XAsyncBlock* asyncBlock, UINT32 delayInMs );
+VOID XAsyncComplete( XAsyncBlock* asyncBlock, HRESULT result, SIZE_T requiredBufferSize );
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Threading/XOSThreading.c b/dlls/xgameruntime/GDKComponent/System/Threading/XOSThreading.c
new file mode 100644
index 00000000000..8f952d3c15a
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Threading/XOSThreading.c
@@ -0,0 +1,186 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> OS Thread Handling
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#include "XOSThreading.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(xtaskqueue);
+
+static inline struct x_wait_timer *impl_from_IXWaitTimer( IXWaitTimer *iface )
+{
+    return CONTAINING_RECORD( iface, struct x_wait_timer, IXWaitTimer_iface );
+}
+
+static VOID CALLBACK WaitCallback( PTP_CALLBACK_INSTANCE instance , void* context, PTP_TIMER timer )
+{
+    if ( context != NULL )
+    {
+        struct x_wait_timer *impl = impl_from_IXWaitTimer( (IXWaitTimer *)context );
+        impl->callback(impl->context);
+    }
+
+    return;
+}
+
+static HRESULT WINAPI x_wait_timer_QueryInterface( IXWaitTimer *iface, REFIID iid, void **out )
+{
+    struct x_wait_timer *impl = impl_from_IXWaitTimer( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IXWaitTimer ))
+    {
+        *out = &impl->IXWaitTimer_iface;
+        impl->IXWaitTimer_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI x_wait_timer_AddRef( IXWaitTimer *iface )
+{
+    struct x_wait_timer *impl = impl_from_IXWaitTimer( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI x_wait_timer_Release( IXWaitTimer *iface )
+{
+    struct x_wait_timer *impl = impl_from_IXWaitTimer( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI x_wait_timer_Initialize( IXWaitTimer *iface, PVOID context, WaitTimerCallback* callback )
+{
+    struct x_wait_timer *impl = impl_from_IXWaitTimer( iface );
+
+    TRACE( "iface %p, context %p, callback %p.\n", iface, context, callback );
+
+    impl->context = context;
+    impl->callback = callback;
+    impl->timer = CreateThreadpoolTimer( WaitCallback, iface, NULL );
+
+    if ( !impl->timer ) 
+        return HRESULT_FROM_WIN32( GetLastError() );
+
+    return S_OK;
+}
+
+static VOID WINAPI x_wait_timer_Terminate( IXWaitTimer *iface )
+{
+    struct x_wait_timer *impl = impl_from_IXWaitTimer( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    if ( !impl->timer )
+    {
+        SetThreadpoolTimer( impl->timer, NULL, 0, 0 );
+        WaitForThreadpoolTimerCallbacks( impl->timer, TRUE );
+        CloseThreadpoolTimer( impl->timer );
+        impl->timer = NULL;
+    }
+
+    return;
+}
+
+static VOID WINAPI x_wait_timer_Start( IXWaitTimer *iface, UINT64 absoluteTime )
+{
+    LARGE_INTEGER li;
+    FILETIME ft;
+
+    struct x_wait_timer *impl = impl_from_IXWaitTimer( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    li.QuadPart = (LONGLONG)absoluteTime;
+    ft.dwHighDateTime = li.HighPart;
+    ft.dwLowDateTime = li.LowPart;
+
+    SetThreadpoolTimer( impl->timer, &ft, 0, 0 );
+
+    return;
+}
+
+static VOID WINAPI x_wait_timer_Cancel( IXWaitTimer *iface )
+{
+    struct x_wait_timer *impl = impl_from_IXWaitTimer( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    SetThreadpoolTimer( impl->timer, NULL, 0, 0 );
+
+    return;
+}
+
+static UINT64 WINAPI x_wait_timer_GetAbsoluteTime( IXWaitTimer *iface, UINT32 msFromNow )
+{
+    FILETIME ft;
+    ULARGE_INTEGER li;
+    UINT64 hundredNanosFromNow;
+
+    TRACE( "iface %p, msFromNow %d.\n", iface, msFromNow );
+
+    GetSystemTimeAsFileTime( &ft );
+
+    hundredNanosFromNow = msFromNow;
+    hundredNanosFromNow *= 10000ULL;
+
+    li.HighPart = ft.dwHighDateTime;
+    li.LowPart = ft.dwLowDateTime;
+    li.QuadPart += hundredNanosFromNow;
+
+    return li.QuadPart;
+}
+
+static const struct IXWaitTimerVtbl x_wait_timer_vtbl =
+{
+    /* IUnknown methods */
+    x_wait_timer_QueryInterface,
+    x_wait_timer_AddRef,
+    x_wait_timer_Release,
+    /* IAtomicVector methods */
+    x_wait_timer_Initialize,
+    x_wait_timer_Terminate,
+    x_wait_timer_Start,
+    x_wait_timer_Cancel,
+    x_wait_timer_GetAbsoluteTime
+};
+
+HRESULT XCreateWaitTimer( IXWaitTimer **out )
+{
+    struct x_wait_timer *impl;
+
+    TRACE( "out %p.\n", out );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+
+    impl->IXWaitTimer_iface.lpVtbl = &x_wait_timer_vtbl;
+    impl->ref = 1;
+    
+    *out = &impl->IXWaitTimer_iface;
+
+    return S_OK;
+}
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Threading/XOSThreading.h b/dlls/xgameruntime/GDKComponent/System/Threading/XOSThreading.h
new file mode 100644
index 00000000000..6b6e6541b4e
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Threading/XOSThreading.h
@@ -0,0 +1,79 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> OS Thread Handling
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef XOSTHREADING_H
+#define XOSTHREADING_H
+
+#include "../../../private.h"
+
+typedef void CALLBACK WaitTimerCallback(void* context);
+
+typedef struct IXWaitTimer IXWaitTimer;
+
+typedef struct IXWaitTimerVtbl {
+    /* IUnknown methods */
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IXWaitTimer* This, 
+        REFIID riid, 
+        void** ppvObject);
+        
+    ULONG   (STDMETHODCALLTYPE *AddRef)(
+        IXWaitTimer* This);
+
+    ULONG   (STDMETHODCALLTYPE *Release)(
+        IXWaitTimer* This);
+
+    /* IXWaitTimer methods */
+    HRESULT (STDMETHODCALLTYPE *Initialize)(
+        IXWaitTimer* This,
+        PVOID context,
+        WaitTimerCallback* callback);
+
+    VOID    (STDMETHODCALLTYPE *Terminate)(
+        IXWaitTimer* This);
+
+    VOID    (STDMETHODCALLTYPE *Start)(
+        IXWaitTimer* This,
+        UINT64 absoluteTime);
+
+    VOID    (STDMETHODCALLTYPE *Cancel)(
+        IXWaitTimer* This);
+
+    UINT64  (STDMETHODCALLTYPE *GetAbsoluteTime)(
+        IXWaitTimer* This,
+        UINT32 msFromNow);
+} IXWaitTimerVtbl;
+
+struct IXWaitTimer {
+    const IXWaitTimerVtbl* lpVtbl;
+};
+
+struct x_wait_timer {
+    IXWaitTimer IXWaitTimer_iface;
+    PTP_TIMER timer;
+    PVOID context;
+    WaitTimerCallback *callback;
+    LONG ref;
+};
+
+HRESULT XCreateWaitTimer( IXWaitTimer **out );
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Threading/XTaskQueue.c b/dlls/xgameruntime/GDKComponent/System/Threading/XTaskQueue.c
new file mode 100644
index 00000000000..63310d7c587
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Threading/XTaskQueue.c
@@ -0,0 +1,2091 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XTask
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "XTaskQueue.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(xtaskqueue);
+
+static void CALLBACK x_task_queue_port_WaitTimerOperation( void *context )
+{
+    IXTaskQueuePort* port = (IXTaskQueuePort *)context;
+    port->lpVtbl->SubmitPendingCallback( port );
+}
+
+static BOOLEAN CALLBACK x_task_queue_port_VectorPredicateOperation( const void *element, void *context )
+{
+    return element == context;
+}
+
+static void CALLBACK x_task_queue_port_VectorVisitOperation( void *context )
+{
+    IXTaskQueuePortContext *impl = (IXTaskQueuePortContext *)context;
+    impl->lpVtbl->ItemQueued( impl );
+}
+
+static void CALLBACK x_task_queue_port_ThreadPoolOperation(void* context, ThreadPoolActionStatus *status)
+{
+    IXTaskQueuePort *impl = (IXTaskQueuePort *)context;
+    impl->lpVtbl->ProcessThreadPoolCallback( context, status );
+}
+
+static inline struct x_task_queue_port_context *impl_from_IXTaskQueuePortContext( IXTaskQueuePortContext *iface )
+{
+    return CONTAINING_RECORD( iface, struct x_task_queue_port_context, IXTaskQueuePortContext_iface );
+}
+
+static inline struct x_task_queue_port *impl_from_IXTaskQueuePort( IXTaskQueuePort *iface )
+{
+    return CONTAINING_RECORD( iface, struct x_task_queue_port, IXTaskQueuePort_iface );
+}
+
+static inline struct x_task_queue_monitor_callback *impl_from_IXTaskQueueMonitorCallback( IXTaskQueueMonitorCallback *iface )
+{
+    return CONTAINING_RECORD( iface, struct x_task_queue_monitor_callback, IXTaskQueueMonitorCallback_iface );
+}
+
+static inline struct x_task_queue *impl_from_IXTaskQueue( IXTaskQueue *iface )
+{
+    return CONTAINING_RECORD( iface, struct x_task_queue, IXTaskQueue_iface );
+}
+
+static HRESULT WINAPI x_task_queue_port_context_QueryInterface( IXTaskQueuePortContext *iface, REFIID iid, void **out )
+{
+    struct x_task_queue_port_context *impl = impl_from_IXTaskQueuePortContext( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IXTaskQueuePortContext ))
+    {
+        *out = &impl->IXTaskQueuePortContext_iface;
+        impl->IXTaskQueuePortContext_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI x_task_queue_port_context_AddRef( IXTaskQueuePortContext *iface )
+{
+    struct x_task_queue_port_context *impl = impl_from_IXTaskQueuePortContext( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    impl->queue->lpVtbl->AddRef( impl->queue );
+    return ref;
+}
+
+static ULONG WINAPI x_task_queue_port_context_Release( IXTaskQueuePortContext *iface )
+{
+    struct x_task_queue_port_context *impl = impl_from_IXTaskQueuePortContext( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    impl->queue->lpVtbl->Release( impl->queue );
+    return ref;
+}
+
+static XTaskQueuePort WINAPI x_task_queue_port_context_get_Type( IXTaskQueuePortContext *iface )
+{
+    struct x_task_queue_port_context *impl = impl_from_IXTaskQueuePortContext( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return impl->type;
+}
+
+static XTaskQueuePortStatus WINAPI x_task_queue_port_context_get_Status( IXTaskQueuePortContext *iface )
+{
+    struct x_task_queue_port_context *impl = impl_from_IXTaskQueuePortContext( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return impl->status;
+}
+
+static IXTaskQueue* WINAPI x_task_queue_port_context_get_Queue( IXTaskQueuePortContext *iface )
+{
+    struct x_task_queue_port_context *impl = impl_from_IXTaskQueuePortContext( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    impl->queue->lpVtbl->AddRef( impl->queue );
+
+    return impl->queue;
+}
+
+static IXTaskQueuePort* WINAPI x_task_queue_port_context_get_Port( IXTaskQueuePortContext *iface )
+{
+    struct x_task_queue_port_context *impl = impl_from_IXTaskQueuePortContext( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    impl->port->lpVtbl->AddRef( impl->port );
+
+    return impl->port;
+}
+
+static VOID WINAPI x_task_queue_port_context_SetStatus( IXTaskQueuePortContext *iface, XTaskQueuePortStatus status )
+{
+    struct x_task_queue_port_context *impl = impl_from_IXTaskQueuePortContext( iface );
+
+    TRACE( "iface %p, status %d.\n", iface, status );
+
+    impl->status = status;
+
+    return;
+}
+
+static VOID WINAPI x_task_queue_port_context_ItemQueued( IXTaskQueuePortContext *iface )
+{
+    struct x_task_queue_port_context *impl = impl_from_IXTaskQueuePortContext( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    if ( impl->callbackSubmitted->lpVtbl )
+        impl->callbackSubmitted->lpVtbl->Invoke( impl->callbackSubmitted, impl->type );
+
+    return;
+}
+
+static BOOLEAN WINAPI x_task_queue_port_context_AddSuspend( IXTaskQueuePortContext *iface )
+{
+    struct x_task_queue_port_context *impl = impl_from_IXTaskQueuePortContext( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return ( InterlockedExchangeAdd( &impl->suspendCount, 1 ) == 0 );
+}
+
+static BOOLEAN WINAPI x_task_queue_port_context_RemoveSuspend( IXTaskQueuePortContext *iface )
+{
+    UINT32 current;
+
+    struct x_task_queue_port_context *impl = impl_from_IXTaskQueuePortContext( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    for(;;)
+    {
+        current = InterlockedCompareExchange( &impl->suspendCount, 0, 0 );
+
+        // These should always be balanced and there is no
+        // valid case where this should happen, even
+        // for multiple threads racing.
+
+        if (current == 0)
+        {
+            return TRUE;
+        }
+
+        if ( InterlockedCompareExchange(&impl->suspendCount, current - 1, current) == current )
+        {
+            return current == 1;
+        }
+    }
+
+    return FALSE;
+}
+
+static const struct IXTaskQueuePortContextVtbl x_task_queue_port_context_vtbl =
+{
+    /* IUnknown methods */
+    x_task_queue_port_context_QueryInterface,
+    x_task_queue_port_context_AddRef,
+    x_task_queue_port_context_Release,
+    /* IXTaskQueuePortContext methods */
+    x_task_queue_port_context_get_Type,
+    x_task_queue_port_context_get_Status,
+    x_task_queue_port_context_get_Queue,
+    x_task_queue_port_context_get_Port,
+    x_task_queue_port_context_SetStatus,
+    x_task_queue_port_context_ItemQueued,
+    x_task_queue_port_context_AddSuspend,
+    x_task_queue_port_context_RemoveSuspend
+};
+
+static HRESULT WINAPI x_task_queue_monitor_callback_QueryInterface( IXTaskQueueMonitorCallback *iface, REFIID iid, void **out )
+{
+    struct x_task_queue_monitor_callback *impl = impl_from_IXTaskQueueMonitorCallback( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IXTaskQueueMonitorCallback ))
+    {
+        *out = &impl->IXTaskQueueMonitorCallback_iface;
+        impl->IXTaskQueueMonitorCallback_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI x_task_queue_monitor_callback_AddRef( IXTaskQueueMonitorCallback *iface )
+{
+    struct x_task_queue_monitor_callback *impl = impl_from_IXTaskQueueMonitorCallback( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI x_task_queue_monitor_callback_Release( IXTaskQueueMonitorCallback *iface )
+{
+    struct x_task_queue_monitor_callback *impl = impl_from_IXTaskQueueMonitorCallback( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI x_task_queue_monitor_callback_Register( IXTaskQueueMonitorCallback *iface, PVOID context, XTaskQueueMonitorCallback* callback, XTaskQueueRegistrationToken* token )
+{
+    XMonitor *monitor;
+
+    struct x_task_queue_monitor_callback *impl = impl_from_IXTaskQueueMonitorCallback( iface );
+
+    TRACE( "iface %p, context %p, callback %p, token %p.\n", iface, context, callback, token );
+
+    if ( !callback || !token )
+        return E_POINTER;
+
+    if (!(monitor = calloc( 1, sizeof(*monitor) ))) return E_OUTOFMEMORY;
+
+    token->token = impl->monitors_size;
+    impl->monitors_size++;
+
+    monitor->callback = callback;
+    monitor->token = token->token;
+    monitor->context = context;
+    monitor->next = NULL;
+
+    EnterCriticalSection( &impl->cs );
+
+    if ( !impl->monitors_tail )
+    {
+        impl->monitors_head = impl->monitors_tail = monitor;
+    } else {
+        impl->monitors_tail->next = monitor;
+        impl->monitors_tail = monitor;
+    }
+    
+    LeaveCriticalSection( &impl->cs );
+
+    return S_OK;
+}
+
+static VOID WINAPI x_task_queue_monitor_callback_Unregister( IXTaskQueueMonitorCallback *iface, XTaskQueueRegistrationToken token )
+{
+    XMonitor *current;
+    XMonitor *previous = NULL;
+    XMonitor *next;
+
+    struct x_task_queue_monitor_callback *impl = impl_from_IXTaskQueueMonitorCallback( iface );
+
+    TRACE( "iface %p, token %lld.\n", iface, token.token );
+    
+    EnterCriticalSection( &impl->cs );
+
+    current = impl->monitors_head;
+    
+    while ( current )
+    {
+        next = current->next;
+        if ( current->token == token.token )
+        {
+            if ( previous )
+                previous->next = next;
+            else
+                impl->monitors_head = next;
+
+            if ( impl->monitors_tail == current )
+                impl->monitors_tail = previous;
+
+            current->next = NULL;
+            free( current );
+            break;
+        } else
+        {
+            previous = current;
+        }
+        current = next;
+    }
+
+    LeaveCriticalSection( &impl->cs );
+
+    return;
+}
+
+static VOID WINAPI x_task_queue_monitor_callback_Invoke( IXTaskQueueMonitorCallback *iface, XTaskQueuePort port )
+{
+    XMonitor *current;
+
+    struct x_task_queue_monitor_callback *impl = impl_from_IXTaskQueueMonitorCallback( iface );
+
+    TRACE( "iface %p, port %d.\n", iface, port );
+    
+    EnterCriticalSection( &impl->cs );
+
+    current = impl->monitors_head;
+    
+    while ( current )
+    {
+        if ( current->callback )
+            current->callback( current->context, impl->queue, port );
+        current = current->next;
+    }
+
+    LeaveCriticalSection( &impl->cs );
+
+    return;
+}
+
+static const struct IXTaskQueueMonitorCallbackVtbl x_task_queue_monitor_callback_vtbl =
+{
+    /* IUnknown methods */
+    x_task_queue_monitor_callback_QueryInterface,
+    x_task_queue_monitor_callback_AddRef,
+    x_task_queue_monitor_callback_Release,
+    /* IXTaskQueueMonitorCallback methods */
+    x_task_queue_monitor_callback_Register,
+    x_task_queue_monitor_callback_Unregister,
+    x_task_queue_monitor_callback_Invoke
+};
+
+static HRESULT WINAPI x_task_queue_port_QueryInterface( IXTaskQueuePort *iface, REFIID iid, void **out )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IXTaskQueuePort ))
+    {
+        *out = &impl->IXTaskQueuePort_iface;
+        impl->IXTaskQueuePort_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI x_task_queue_port_AddRef( IXTaskQueuePort *iface )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI x_task_queue_port_Release( IXTaskQueuePort *iface )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI x_task_queue_port_Initialize( IXTaskQueuePort *iface, XTaskQueueDispatchMode mode )
+{
+    HRESULT hr;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, mode %d.\n", iface, mode );
+
+    impl->dispatchMode = mode;
+    impl->processingCallback = 0;
+    InitializeConditionVariable( &impl->cv );
+    InitializeConditionVariable( &impl->cvAny );
+    InitializeCriticalSection( &impl->cs );
+
+    hr = CreateAtomicVector( &impl->attachedContexts );
+    if ( FAILED( hr ) ) return hr;
+
+    hr = XCreateWaitTimer( &impl->timer );
+    if ( FAILED( hr ) ) return hr;
+
+    hr = CreateIThreadPool( &impl->threadPool );
+    if ( FAILED( hr ) ) return hr;
+
+    impl->timer->lpVtbl->Initialize( impl->timer, iface, x_task_queue_port_WaitTimerOperation );
+
+    switch (mode)
+    {
+        case Manual:
+            // nothing
+            break;
+
+        case ThreadPool:
+        case SerializedThreadPool:
+            hr = impl->threadPool->lpVtbl->Initialize( impl->threadPool, iface, x_task_queue_port_ThreadPoolOperation );
+            if ( FAILED( hr ) ) return hr;
+            break;
+
+        case Immediate:
+            // nothing
+            break;
+    }
+
+    return S_OK;
+}
+
+static XTaskQueuePortHandle WINAPI x_task_queue_port_GetHandle( IXTaskQueuePort *iface )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return &impl->portHeader;
+}
+
+static HRESULT WINAPI x_task_queue_port_QueueItem( IXTaskQueuePort *iface, IXTaskQueuePortContext *portContext, UINT32 waitMs, PVOID callbackContext, XTaskQueueCallback *callback)
+{
+    HRESULT hr;
+    
+    XQueue *queue;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, portContext %p, waitMs %d, callbackContext %p, callback %p.\n", iface, portContext, waitMs, callbackContext, callback );
+
+    hr = iface->lpVtbl->VerifyNotTerminated( iface, portContext );
+    if ( FAILED( hr ) ) return hr;
+
+    if (!(queue = calloc( 1, sizeof(*queue) ))) return E_OUTOFMEMORY;
+
+    queue->portContext = portContext;
+    queue->callback = callback;
+    queue->callbackContext = callbackContext;
+    queue->id = impl->nextId;
+
+    InterlockedIncrement( &impl->nextId );
+
+    if ( waitMs == 0 )
+    {
+        queue->enqueueTime = 0;
+        if( !(iface->lpVtbl->AppendEntry( iface, queue )) ) return E_OUTOFMEMORY;
+    } else
+    {
+        queue->enqueueTime = impl->timer->lpVtbl->GetAbsoluteTime( impl->timer, waitMs );
+        if ( !impl->pendingQueueList_tail )
+        {
+            //queue list is empty
+            impl->pendingQueueList_head = impl->pendingQueueList_tail = queue;
+        } else 
+        {
+            impl->pendingQueueList_tail->next = queue;
+            impl->pendingQueueList_tail = queue;
+        }
+
+        while ( TRUE )
+        {
+            LONG64 due = InterlockedCompareExchange64( &impl->timerDue, 0, 0 ) ;
+            if ( queue->enqueueTime < due )
+            {
+                if ( InterlockedCompareExchange64( &impl->timerDue, queue->enqueueTime, due ) == due )
+                {
+                    impl->timer->lpVtbl->Start( impl->timer, queue->enqueueTime );
+                    break;
+                }
+            }
+            else if ( InterlockedCompareExchange64( &impl->timerDue, due, due ) == due )
+            {
+                break;
+            }
+        }
+    }
+
+    // guard against race condition
+    if ( portContext->lpVtbl->get_Status != PortStatus_Active )
+    {
+        iface->lpVtbl->CancelPendingEntries( iface, portContext, TRUE );
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI x_task_queue_port_RegisterWaitHandle( IXTaskQueuePort* iface, IXTaskQueuePortContext* portContext, HANDLE waitHandle, PVOID callbackContext, XTaskQueueCallback* callback, XTaskQueueRegistrationToken* token )
+{
+    WARN( "iface %p, portContext %p, waitHandle %p, callbackContext %p, callback %p, token %p not intended!\n", iface, portContext, waitHandle, callbackContext, callback, token );
+    return E_NOTIMPL;
+}
+
+static VOID WINAPI x_task_queue_port_UnregisterWaitHandle( IXTaskQueuePort* iface, XTaskQueueRegistrationToken token )
+{
+    WARN( "iface %p, token %lld not intended!\n", iface, token.token );
+    return;
+}
+
+static HRESULT WINAPI x_task_queue_port_PrepareTerminate( IXTaskQueuePort* iface, IXTaskQueuePortContext* portContext, PVOID callbackContext, XTaskQueueTerminatedCallback* callback, PVOID *outPrepareToken )
+{
+    XTerminateForPort *terminate;
+
+    TRACE( "iface %p, portContext %p, callbackContext %p, callback %p, outPrepareToken %p.\n", iface, portContext, callbackContext, callback, outPrepareToken );
+
+    // Arguments
+    if ( !outPrepareToken )
+        return E_POINTER;
+    if ( !callback )
+        return E_INVALIDARG;
+
+    if (!(terminate = calloc( 1, sizeof(*terminate) ))) return E_OUTOFMEMORY;
+
+    terminate->callbackContext = callbackContext;
+    terminate->callback = callback;
+    terminate->portContext = portContext;
+
+    // Mark the port as canceled, but don't overwrite
+    // terminating or terminated status.
+    portContext->lpVtbl->SetStatus( portContext, PortStatus_Active );
+    *outPrepareToken = (PVOID)terminate;
+
+    TRACE( "created token %p\n", terminate );
+
+    return S_OK;
+}
+
+static VOID WINAPI x_task_queue_port_CancelTermination( IXTaskQueuePort* iface, PVOID token )
+{
+    XTerminateForPort *terminate = (XTerminateForPort *)token;
+    XTerminateForPort *current = NULL;
+    XTerminateForPort *previous = NULL;
+    XTerminateForPort *next = NULL;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, token %p.\n", iface, token );
+
+    terminate->portContext->lpVtbl->SetStatus( terminate->portContext, PortStatus_Canceled );
+
+    current = impl->terminateList_head;
+
+    while ( current )
+    {
+        next = current->next;
+        if ( current == terminate )
+        {
+            if ( previous )
+                previous->next = next;
+            else
+                impl->terminateList_head = next;
+
+            if ( impl->terminateList_tail == current )
+                impl->terminateList_tail = previous;
+
+            current->next = NULL;
+            free( current );
+        } else
+        {
+            previous = current;
+        }
+        current = next;
+    }
+
+    free ( terminate );
+    return;
+}
+
+static VOID WINAPI x_task_queue_port_Terminate( IXTaskQueuePort* iface, PVOID token )
+{
+    XTerminateForPort *terminate = (XTerminateForPort *)token;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, token %p.\n", iface, token );
+
+    terminate->portContext->lpVtbl->SetStatus( terminate->portContext, PortStatus_Terminating );
+
+    iface->lpVtbl->CancelPendingEntries( iface, terminate->portContext, TRUE );
+
+    // Are there existing suspends? AddSuspend returns
+    // true if this is the first suspend added.
+    if ( terminate->portContext->lpVtbl->AddSuspend( terminate->portContext ) )
+    {
+        iface->lpVtbl->ScheduleTermination( iface, terminate );
+    }
+    else
+    {
+        if ( !impl->pendingTerminateList_tail )
+        {
+            //queue list is empty
+            impl->pendingTerminateList_tail = impl->pendingTerminateList_head = terminate;
+        } else 
+        {
+            impl->pendingTerminateList_tail->next = terminate;
+            impl->pendingTerminateList_tail = terminate;
+        }
+    }
+
+    // Balance our add.  Note we must use ResumeTermination
+    // here so we schedule the termination if this is the
+    // last remove.
+    iface->lpVtbl->ResumeTermination( iface, terminate->portContext );
+}
+
+static HRESULT WINAPI x_task_queue_port_Attach( IXTaskQueuePort *iface, IXTaskQueuePortContext* portContext )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, portContext %p.\n", iface, portContext );
+
+    return impl->attachedContexts->lpVtbl->Add( impl->attachedContexts, (PVOID)portContext );
+}
+
+static VOID WINAPI x_task_queue_port_Detach( IXTaskQueuePort *iface, IXTaskQueuePortContext* portContext )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, portContext %p.\n", iface, portContext );
+
+    iface->lpVtbl->CancelPendingEntries( iface, portContext, FALSE );
+    impl->attachedContexts->lpVtbl->Remove( impl->attachedContexts, x_task_queue_port_VectorPredicateOperation, portContext );
+    return;
+}
+
+static BOOLEAN WINAPI x_task_queue_port_Dispatch( IXTaskQueuePort *iface, IXTaskQueuePortContext* portContext, UINT32 timeoutInMs )
+{
+    BOOLEAN found = FALSE;
+
+    TRACE( "iface %p, portContext %p, timeoutInMs %d.\n", iface, portContext, timeoutInMs );
+
+    while ( !found )
+    {
+        found = iface->lpVtbl->DrainOneItem( iface );
+
+        if ( !found && iface->lpVtbl->Wait( iface, portContext, timeoutInMs ) )
+        {
+            break;
+        }
+    }
+
+    return found;
+}
+
+static BOOLEAN x_task_queue_port_DrainOneItem( IXTaskQueuePort *iface )
+{
+    BOOLEAN popped = FALSE;
+    BOOLEAN canceled;
+
+    XQueue *front;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    if ( impl->suspended && impl->dispatchMode != Immediate )
+    {
+        return FALSE;
+    }
+
+    InterlockedIncrement( &impl->processingCallback );
+
+    if ( !impl->queueList_head ) 
+    {
+        popped = FALSE;
+    }
+    else
+    {
+        front = impl->queueList_head;
+        impl->queueList_head = front->next;
+
+        if ( impl->queueList_head == NULL )
+            impl->queueList_tail = NULL;
+
+        popped = TRUE;
+    }
+
+    TRACE("popped %d!\n", popped);
+
+    if ( popped )
+    {
+        TRACE("calling %p!\n", front->callback);
+        canceled = iface->lpVtbl->IsCallCanceled( iface, front );
+        front->callback( front->callbackContext, canceled );
+        InterlockedDecrement( &impl->processingCallback );
+        WakeAllConditionVariable( &impl->cv );
+        front->portContext->lpVtbl->Release( front->portContext );
+        free( front );
+    }
+    else
+    {
+        InterlockedDecrement( &impl->processingCallback );
+        WakeAllConditionVariable( &impl->cv );
+    }
+
+    if ( !impl->queueList_head )
+    {
+        iface->lpVtbl->SignalTerminations( iface );
+        iface->lpVtbl->SignalQueue( iface );
+    }
+
+    return popped;
+}
+
+static BOOLEAN x_task_queue_port_Wait( IXTaskQueuePort *iface, IXTaskQueuePortContext* portContext, UINT32 timeout )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, portContext %p, timeout %d.\n", iface, portContext, timeout );
+
+    while ( impl->suspended || ( impl->queueList_head && impl->terminateList_head ) )
+    {
+        TRACE( "impl->queueList_head was %p, impl->terminateList_head was %p\n", impl->queueList_head, impl->terminateList_head);
+        if ( portContext->lpVtbl->get_Status( portContext ) == PortStatus_Terminated )
+        {
+            return FALSE;
+        }
+
+        EnterCriticalSection( &impl->cs );
+
+        if ( !impl->signaled && !SleepConditionVariableCS( &impl->cvAny, &impl->cs, timeout ) )
+        {
+            return FALSE;
+        }
+
+        LeaveCriticalSection( &impl->cs );
+
+        impl->signaled = FALSE;
+    }
+
+    return TRUE;
+}
+
+static BOOLEAN WINAPI x_task_queue_port_IsEmpty( IXTaskQueuePort *iface )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return !impl->queueList_head && !impl->pendingQueueList_head && impl->processingCallback == 0;
+}
+
+static VOID WINAPI x_task_queue_port_WaitForUnwind( IXTaskQueuePort *iface )
+{
+    ULONGLONG ms;
+    ULONGLONG now;
+    CRITICAL_SECTION lock;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p.\n", iface );
+    
+    InitializeCriticalSectionEx( &lock, 0, RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO );
+    lock.DebugInfo->Spare[0] = (DWORD_PTR)( __FILE__ ": xtaskqueue.cs" );
+
+    EnterCriticalSection( &lock );
+
+    while( InterlockedCompareExchange( &impl->processingCallback, 0, 0) != 0)
+    {
+        // wait for 10 ms.  We do not modify m_processingCallback under
+        // the protection of a mutex because we don't want the hit of
+        // taking a lock.  Therefore, we can't wait forever for the
+        // cv here.  We could miss it due to a race. This API is only
+        // called during task queue termination and therefore some polling
+        // is OK.
+
+        ms = 10; // 10 milliseconds
+        now = GetTickCount64();
+        SleepConditionVariableCS( &impl->cv, &lock, now + ms );
+    }
+
+    LeaveCriticalSection( &lock );
+}
+
+static HRESULT WINAPI x_task_queue_port_SuspendTermination( IXTaskQueuePort *iface, IXTaskQueuePortContext *portContext )
+{
+    HRESULT hr;
+
+    TRACE( "iface %p, portContext %p.\n", iface, portContext );
+
+    // guard against race condition
+    portContext->lpVtbl->AddSuspend( portContext );
+    hr = iface->lpVtbl->VerifyNotTerminated( iface, portContext );
+    
+    if ( FAILED( hr ) )
+    {
+        iface->lpVtbl->ResumeTermination( iface, portContext );
+        return hr;
+    }
+
+    return S_OK;
+}
+
+static VOID WINAPI x_task_queue_port_ResumeTermination( IXTaskQueuePort *iface, IXTaskQueuePortContext *portContext )
+{
+    XTerminateForPort *previous = NULL;
+    XTerminateForPort *current = NULL;
+    XTerminateForPort *next = NULL;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, portContext %p.\n", iface, portContext );
+
+    if ( portContext->lpVtbl->RemoveSuspend( portContext ) )
+    {
+        // Removed the last external callback.  Look for
+        // parked terminations and reschedule them.
+
+        if( !impl->pendingTerminateList_head )
+            return;
+
+        current = impl->pendingTerminateList_head;
+
+        while ( current )
+        {
+            next = current->next;
+            if ( current->portContext == portContext )
+            {
+                iface->lpVtbl->ScheduleTermination( iface, current );
+
+                if ( previous )
+                {
+                    previous->next = next;
+                } else
+                {
+                    impl->pendingTerminateList_head = next;
+                }
+
+                if ( current == impl->pendingTerminateList_tail )
+                {
+                    impl->pendingTerminateList_tail = previous;
+                }
+
+                current->next = NULL;
+            }
+            else 
+            {
+                previous = current;
+            }
+
+            current = next;
+        }
+    }
+
+    return;
+}
+
+static VOID WINAPI x_task_queue_port_SuspendPort( IXTaskQueuePort *iface )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    InterlockedExchange( (LONG *)&impl->suspended, 1 );
+
+    return;
+}
+
+static VOID WINAPI x_task_queue_port_ResumePort( IXTaskQueuePort *iface )
+{    
+    UINT32 notifyCount = 0;
+
+    XQueue *queueEntry;
+    XTerminateForPort *terminationEntry;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    queueEntry = impl->queueList_head;
+    while ( queueEntry != NULL ) 
+    {
+        notifyCount++;
+        queueEntry = queueEntry->next;
+    }
+
+    terminationEntry = impl->terminateList_head;
+    while ( terminationEntry != NULL )
+    {
+        notifyCount++;
+        terminationEntry = terminationEntry->next;
+    }
+
+    InterlockedExchange( (LONG *)&impl->suspended, 0 );
+
+    while ( notifyCount )
+    {
+        iface->lpVtbl->SignalQueue( iface );
+        iface->lpVtbl->NotifyItemQueued( iface );
+        notifyCount--;
+    }
+
+    return;
+}
+
+static HRESULT x_task_queue_port_VerifyNotTerminated( IXTaskQueuePort *iface, IXTaskQueuePortContext *portContext )
+{
+    TRACE( "iface %p, portContext %p.\n", iface, portContext );
+
+    if ( portContext->lpVtbl->get_Status( portContext ) > PortStatus_Canceled )
+        return E_ABORT;
+
+    return S_OK;
+}
+
+static BOOLEAN x_task_queue_port_IsCallCanceled( IXTaskQueuePort *iface, XQueue *entry )
+{
+    TRACE( "iface %p, entry %p.\n", iface, entry );
+    return entry->portContext->lpVtbl->get_Status( entry->portContext ) != PortStatus_Active;
+}
+
+static BOOLEAN x_task_queue_port_AppendEntry( IXTaskQueuePort *iface, XQueue *entry )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, entry %p.\n", iface, entry );
+
+    entry->next = NULL;
+    if ( !impl->queueList_tail )
+    {
+        TRACE("queue list was empty!\n");
+        impl->queueList_head = impl->queueList_tail = entry;
+    } else
+    {
+        TRACE("queue list was not empty!\n");
+        impl->queueList_tail->next = entry;
+        impl->queueList_tail = entry;
+    }
+
+    iface->lpVtbl->SignalQueue( iface );
+    iface->lpVtbl->NotifyItemQueued( iface );
+
+    return TRUE;
+}
+
+static VOID x_task_queue_port_CancelPendingEntries( IXTaskQueuePort *iface, IXTaskQueuePortContext* portContext, BOOLEAN appendToQueue )
+{
+    XQueue *current;
+    XQueue *previous = NULL;
+    XQueue *next;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, portContext %p, appendToQueue %d.\n", iface, portContext, appendToQueue );
+
+    impl->timer->lpVtbl->Cancel( impl->timer );
+    impl->timerDue = UINT64_MAX;
+
+    current = impl->pendingQueueList_head;
+
+    while ( current )
+    {
+        next = current->next;
+        if ( current->portContext == portContext )
+        {
+            if ( previous )
+            {
+                previous->next = next;
+            } else
+            {
+                impl->pendingQueueList_head = next;
+            }
+
+            if ( current == impl->pendingQueueList_tail )
+            {
+                impl->pendingQueueList_tail = previous;
+            }
+
+            current->next = NULL;
+
+            if ( !appendToQueue || !iface->lpVtbl->AppendEntry( iface, current ) )
+            {
+                current->portContext->lpVtbl->Release( current->portContext );
+                free( current );
+            }
+        }
+        else 
+        {
+           previous = current;
+        }
+        
+        current = next;
+    }
+
+    iface->lpVtbl->SubmitPendingCallback( iface );
+
+    return;
+}
+
+static VOID x_task_queue_port_EraseQueue( IXTaskQueuePort *iface, XQueue *queueHead, XQueue *queueTail )
+{
+    XQueue *current;
+    XQueue *next;
+
+    TRACE( "iface %p, queueHead %p, queueTail %p.\n", iface, queueHead, queueTail );
+
+    current = queueHead;
+
+    while ( current )
+    {
+        next = current->next;
+        free( current );
+        current = next;
+    }
+
+    queueHead = queueTail = NULL;
+
+    return;
+}
+
+static BOOLEAN x_task_queue_port_ScheduleNextPendingCallback( IXTaskQueuePort *iface, UINT64 dueTime, XQueue **dueEntry )
+{
+    XQueue *current;
+    XQueue *previous = NULL;
+    XQueue *nextItem = NULL;
+    XQueue *next;
+
+    BOOLEAN hasDueEntry = FALSE;
+    BOOLEAN hasNextItem = FALSE;
+    BOOLEAN removed = FALSE;
+    UINT64 noDueTime = UINT64_MAX;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, dueTime %lld, dueEntry %p.\n", iface, dueTime, dueEntry );
+
+    current = impl->pendingQueueList_head;
+
+    if (!(nextItem = calloc( 1, sizeof(*nextItem) ))) return FALSE;
+
+    while ( current )
+    {
+        next = current->next;
+        removed = FALSE;
+        if ( !hasDueEntry && current->enqueueTime == dueTime )
+        {
+            *dueEntry = current;
+            hasDueEntry = TRUE;
+
+            if ( previous )
+            {
+                previous->next = next;
+            } else
+            {
+                impl->pendingQueueList_head = next;
+            }
+
+            if ( current == impl->pendingQueueList_tail )
+            {
+                impl->pendingQueueList_tail = previous;
+            }
+
+            current->next = NULL;
+            removed = TRUE;
+        } else 
+        {
+            if ( !hasDueEntry || nextItem->enqueueTime > current->enqueueTime )
+            {
+                if ( hasNextItem )
+                {
+                    nextItem->portContext->lpVtbl->Release( nextItem->portContext );
+                }
+
+                nextItem = current;
+                nextItem->portContext->lpVtbl->AddRef( nextItem->portContext );
+                hasNextItem = TRUE;
+            }
+        }
+
+        if ( !removed )
+        {
+            previous = current;
+        }
+
+        current = next;
+    }
+
+    if ( hasNextItem )
+    {
+        if ( nextItem->portContext->lpVtbl->get_Status( nextItem->portContext ) == PortStatus_Active )
+        {
+            while ( TRUE )
+            {
+                if ( InterlockedCompareExchange64( &impl->timerDue, 0, 0 ) == InterlockedCompareExchange64( &impl->timerDue, dueTime, nextItem->enqueueTime ) )
+                {
+                    impl->timer->lpVtbl->Start( impl->timer, nextItem->enqueueTime );
+                    break;
+                }
+
+                dueTime = InterlockedCompareExchange64( &impl->timerDue, 0, 0 );
+
+                if ( dueTime <= nextItem->enqueueTime )
+                {
+                    break;
+                }
+            }
+        }
+        else
+        {
+            // The port is no longer active. Pending entries are canceled
+            // when the port is terminated, but if we were iterating above
+            // it's possible that we removed an item while the termination was
+            // being processed and it got missed.
+            iface->lpVtbl->CancelPendingEntries( iface, nextItem->portContext, TRUE );
+        }
+
+        nextItem->portContext->lpVtbl->Release( nextItem->portContext );
+    }
+    else
+    {
+        if ( InterlockedCompareExchange64( &impl->timerDue, 0, 0 ) == InterlockedCompareExchange64( &impl->timerDue, dueTime, noDueTime ) )
+        {
+            impl->timer->lpVtbl->Cancel( impl->timer );
+        }
+    }
+
+    return hasDueEntry;
+}
+
+static VOID x_task_queue_port_SubmitPendingCallback( IXTaskQueuePort *iface )
+{
+    XQueue *dueEntry = NULL;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p.\n", iface );
+    
+    if ( iface->lpVtbl->ScheduleNextPendingCallback( iface, InterlockedCompareExchange64( &impl->timerDue, 0, 0 ), &dueEntry ) )
+    {
+        if ( !iface->lpVtbl->AppendEntry( iface, dueEntry ) )
+        {
+            dueEntry->portContext->lpVtbl->Release( dueEntry->portContext );
+            if ( dueEntry )
+                free( dueEntry );
+        }
+    }
+
+    return;
+}
+
+// Must be called in a thread pool.
+static VOID x_task_queue_port_ProcessThreadPoolCallback( IXTaskQueuePort *iface, ThreadPoolActionStatus *status )
+{
+    UINT32 wasProcessing;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    InterlockedIncrement( &impl->processingCallback );
+    wasProcessing = InterlockedCompareExchange( &impl->processingCallback, 0, 0 );
+
+    if ( impl->dispatchMode == SerializedThreadPool )
+    {
+        if ( wasProcessing == 0 )
+        {
+            while ( iface->lpVtbl->DrainOneItem( iface ) );
+        }
+    }
+    else
+    {
+        iface->lpVtbl->DrainOneItem( iface );
+    }
+
+    InterlockedDecrement( &impl->processingCallback );
+    WakeAllConditionVariable( &impl->cv );
+
+    // Important that this comes before Release; otherwise
+    // cleanup may deadlock.
+    status->IActionStatus_iface.lpVtbl->Complete( &status->IActionStatus_iface );
+
+    // When we submitted a request to the thread pool we
+    // added a reference to ourself.  Balance it here. This
+    // may be the final release.
+    iface->lpVtbl->Release( iface );
+
+    return;
+}
+
+static VOID x_task_queue_port_SignalQueue( IXTaskQueuePort *iface )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    if ( !impl->suspended )
+    {
+        EnterCriticalSection( &impl->cs );
+        impl->signaled = TRUE;
+        WakeAllConditionVariable( &impl->cvAny );
+        LeaveCriticalSection( &impl->cs );
+    }
+
+    return;
+}
+
+static VOID x_task_queue_port_NotifyItemQueued( IXTaskQueuePort *iface )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    if ( !impl->suspended || impl->dispatchMode == Immediate)
+    {
+        switch (impl->dispatchMode)
+        {
+            case Manual:
+                // nothing
+                break;
+
+            case SerializedThreadPool:
+            case ThreadPool:
+                // Addref before submitting to the thread pool in case we
+                // are released while there there are outstanding threadpool
+                // items. The threadpool does not cancel outstanding callbacks
+                // on termination so we need to drain before releasing.
+                iface->lpVtbl->AddRef( iface );
+                
+                impl->threadPool->lpVtbl->Submit( impl->threadPool );
+                break;
+
+            case Immediate:
+                // We will handle this after we invoke
+                // callback submitted.
+                break;
+        }
+
+        impl->attachedContexts->lpVtbl->Visit( impl->attachedContexts, x_task_queue_port_VectorVisitOperation );
+        // If the queue is immediate, drain the newly queued item
+        // now.
+
+        if (impl->dispatchMode == Immediate)
+        {
+            iface->lpVtbl->DrainOneItem( iface );
+        }
+    }
+}
+
+static VOID x_task_queue_port_SignalTerminations( IXTaskQueuePort *iface )
+{
+    XTerminateForPort *current;
+    XTerminateForPort *previous = NULL;
+    XTerminateForPort *next;
+
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    current = impl->terminateList_head;
+
+    while ( current )
+    {
+        next = current->next;
+
+        if ( current->portContext->lpVtbl->get_Status( current->portContext ) >= PortStatus_Terminating )
+        {
+            if ( previous )
+            {
+                previous->next = next;
+            } else
+            {
+                impl->terminateList_head = next;
+            }
+
+            if ( current == impl->terminateList_tail )
+            {
+                impl->terminateList_tail = previous;
+            }
+
+            current->portContext->lpVtbl->SetStatus( current->portContext, PortStatus_Terminated );
+            current->callback( current->callbackContext );
+
+            free( current );
+        } else {
+            previous = current;
+        }
+
+        current = next;
+    }
+    
+    return;
+}
+
+static VOID x_task_queue_port_ScheduleTermination( IXTaskQueuePort *iface, XTerminateForPort *entry )
+{
+    struct x_task_queue_port *impl = impl_from_IXTaskQueuePort( iface );
+
+    TRACE( "iface %p, entry %p.\n", iface, entry );
+
+    entry->next = NULL;                     // important: new tail points to NULL
+    if ( !impl->terminateList_tail ) 
+    {
+        impl->terminateList_head = impl->terminateList_tail = entry;
+    } else {
+        impl->terminateList_tail->next = entry;
+        impl->terminateList_tail = entry;
+    }
+
+    iface->lpVtbl->SignalTerminations( iface );
+    iface->lpVtbl->SignalQueue( iface );
+
+    return;
+}
+
+static const struct IXTaskQueuePortVtbl x_task_queue_port_vtbl =
+{
+    /* IUnknown methods */
+    x_task_queue_port_QueryInterface,
+    x_task_queue_port_AddRef,
+    x_task_queue_port_Release,
+    /* IXTaskQueuePort methods */
+    x_task_queue_port_Initialize,
+    x_task_queue_port_GetHandle,
+    x_task_queue_port_QueueItem,
+    x_task_queue_port_RegisterWaitHandle,
+    x_task_queue_port_UnregisterWaitHandle,
+    x_task_queue_port_PrepareTerminate,
+    x_task_queue_port_CancelTermination,
+    x_task_queue_port_Terminate,
+    x_task_queue_port_Attach,
+    x_task_queue_port_Detach,
+    x_task_queue_port_Dispatch,
+    x_task_queue_port_IsEmpty,
+    x_task_queue_port_WaitForUnwind,
+    x_task_queue_port_SuspendTermination,
+    x_task_queue_port_ResumeTermination,
+    x_task_queue_port_SuspendPort,
+    x_task_queue_port_ResumePort,
+    x_task_queue_port_VerifyNotTerminated,
+    x_task_queue_port_IsCallCanceled,
+    x_task_queue_port_AppendEntry,
+    x_task_queue_port_CancelPendingEntries,
+    x_task_queue_port_DrainOneItem,
+    x_task_queue_port_Wait,
+    x_task_queue_port_EraseQueue,
+    x_task_queue_port_ScheduleNextPendingCallback,
+    x_task_queue_port_SubmitPendingCallback,
+    x_task_queue_port_SignalTerminations,
+    x_task_queue_port_ScheduleTermination,
+    x_task_queue_port_SignalQueue,
+    x_task_queue_port_NotifyItemQueued,
+    x_task_queue_port_ProcessThreadPoolCallback
+};
+
+static HRESULT WINAPI x_task_queue_QueryInterface( IXTaskQueue *iface, REFIID iid, void **out )
+{
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IXTaskQueue ))
+    {
+        *out = &impl->IXTaskQueue_iface;
+        impl->IXTaskQueue_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI x_task_queue_AddRef( IXTaskQueue *iface )
+{
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI x_task_queue_Release( IXTaskQueue *iface )
+{
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI x_task_queue_Initialize( IXTaskQueue *iface, XTaskQueuePortHandle workPort, XTaskQueuePortHandle completionPort )
+{
+    HRESULT hr; 
+
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+    struct x_task_queue_port_context *workContext = impl_from_IXTaskQueuePortContext( impl->workPort );
+    struct x_task_queue_port_context *completionContext = impl_from_IXTaskQueuePortContext( impl->completionPort );
+
+    TRACE( "iface %p, workPort %p, completionPort %p.\n", iface, workPort, completionPort );
+
+    // Arguments
+    if ( !workPort || !completionPort || workPort->signature != TASK_QUEUE_PORT_SIGNATURE || completionPort->signature != TASK_QUEUE_PORT_SIGNATURE  )
+        return E_GAMERUNTIME_INVALID_HANDLE;
+
+    workContext->port = workPort->headPort;
+    completionContext->port = completionPort->headPort;
+    workContext->source = workPort->headQueue;
+    completionContext->source = completionPort->headQueue;
+ 
+    impl->terminationData.allowed = TRUE;
+    impl->allowClose = TRUE;
+
+    hr = workContext->port->lpVtbl->Attach( workContext->port, &workContext->IXTaskQueuePortContext_iface );
+    if ( FAILED( hr ) ) return hr;
+
+    hr = completionContext->port->lpVtbl->Attach( completionContext->port, &completionContext->IXTaskQueuePortContext_iface );
+    if ( FAILED( hr ) ) return hr;
+
+    TRACE( "completionContext->callbackSubmitted is %p, workContext->callbackSubmitted is %p\n", workContext->callbackSubmitted, workContext->callbackSubmitted );
+
+    return S_OK;
+}
+
+static HRESULT WINAPI x_task_queue_InitializeOverloadPorts( IXTaskQueue *iface, XTaskQueueDispatchMode workDispatch, XTaskQueueDispatchMode completionDispatch, BOOLEAN allowTermination, BOOLEAN allowClose )
+{
+    HRESULT hr; 
+
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+    struct x_task_queue_port *workPort;
+    struct x_task_queue_port *completionPort;
+    struct x_task_queue_port_context *workContext = impl_from_IXTaskQueuePortContext( impl->workPort );
+    struct x_task_queue_port_context *completionContext = impl_from_IXTaskQueuePortContext( impl->completionPort );
+
+    TRACE( "iface %p, workDispatch %d, completionDispatch %d, allowTermination %d, allowClose %d.\n", iface, workDispatch, completionDispatch, allowTermination, allowClose );
+
+    if (!(workPort = calloc( 1, sizeof(*workPort) ))) return E_OUTOFMEMORY;
+    if (!(completionPort = calloc( 1, sizeof(*completionPort) ))) return E_OUTOFMEMORY;
+
+    workPort->IXTaskQueuePort_iface.lpVtbl = &x_task_queue_port_vtbl;
+    workPort->portHeader.signature = TASK_QUEUE_PORT_SIGNATURE;
+    workPort->portHeader.headQueue = &impl->IXTaskQueue_iface;
+    workPort->portHeader.headPort = &workPort->IXTaskQueuePort_iface;
+    workPort->ref = 1;
+
+    completionPort->IXTaskQueuePort_iface.lpVtbl = &x_task_queue_port_vtbl;
+    completionPort->portHeader.signature = TASK_QUEUE_PORT_SIGNATURE;
+    completionPort->portHeader.headQueue = &impl->IXTaskQueue_iface;
+    completionPort->portHeader.headPort = &completionPort->IXTaskQueuePort_iface;
+    completionPort->ref = 1;
+
+    workContext->port = &workPort->IXTaskQueuePort_iface;
+    workContext->source = iface;
+    completionContext->port = &completionPort->IXTaskQueuePort_iface;
+    completionContext->source = iface;
+
+    hr = workPort->IXTaskQueuePort_iface.lpVtbl->Initialize( &workPort->IXTaskQueuePort_iface, workDispatch );
+    if ( FAILED( hr ) ) goto _CLEANUP;
+
+    hr = completionPort->IXTaskQueuePort_iface.lpVtbl->Initialize( &completionPort->IXTaskQueuePort_iface, completionDispatch );
+    if ( FAILED( hr ) ) goto _CLEANUP;
+
+    workPort->IXTaskQueuePort_iface.lpVtbl->Attach( &workPort->IXTaskQueuePort_iface, impl->workPort );
+    completionPort->IXTaskQueuePort_iface.lpVtbl->Attach( &completionPort->IXTaskQueuePort_iface, impl->completionPort );
+
+    impl->terminationData.allowed = allowTermination;
+    impl->allowClose = allowClose;
+
+    InitializeCriticalSection( &impl->terminationData.cs );
+    InitializeConditionVariable( &impl->terminationData.cv );
+
+_CLEANUP:
+    if ( FAILED( hr ) ) 
+    {
+        free( workPort );
+        free( completionPort );
+    }
+    return hr;
+}
+
+static XTaskQueueHandle WINAPI x_task_queue_GetHandle( IXTaskQueue *iface )
+{
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return &impl->queueHeader;
+}
+
+static HRESULT WINAPI x_task_queue_GetPortContext( IXTaskQueue *iface, XTaskQueuePort port, IXTaskQueuePortContext **portContext )
+{
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+    struct x_task_queue_port_context *workContext = impl_from_IXTaskQueuePortContext( impl->workPort );
+    struct x_task_queue_port_context *completionContext = impl_from_IXTaskQueuePortContext( impl->completionPort );
+
+    TRACE( "iface %p, port %d, portContext %p.\n", iface, port, portContext );
+
+    // Arguments
+    if ( !portContext )
+        return E_POINTER;
+
+    switch( port )
+    {
+        case Work:
+            *portContext = &workContext->IXTaskQueuePortContext_iface;
+            IUnknown_AddRef( *portContext );
+            break;
+
+        case Completion:
+            *portContext = &completionContext->IXTaskQueuePortContext_iface;
+            IUnknown_AddRef( *portContext );
+            break;
+
+        default:
+            return E_INVALIDARG;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI x_task_queue_RegisterWaitHandle( IXTaskQueue *iface, XTaskQueuePort port, HANDLE waitHandle, PVOID callbackContext, XTaskQueueCallback* callback, XTaskQueueRegistrationToken* token )
+{
+    HRESULT hr;
+    
+    XTaskQueueRegistrationToken portToken;
+    IXTaskQueuePortContext *portContext;
+    IXTaskQueuePort *portQueue;
+
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+
+    TRACE( "iface %p, port %d, waitHandle %p, callbackContext %p, callback %p, token %p.\n", iface, port, waitHandle, callbackContext, callback, token );
+
+    // Arguments
+    if ( !callback || !token )
+        return E_POINTER;
+
+    hr = iface->lpVtbl->GetPortContext( iface, port, &portContext );
+    if ( FAILED( hr ) ) return hr;
+
+    portQueue = portContext->lpVtbl->get_Port( portContext );
+
+    hr = portQueue->lpVtbl->RegisterWaitHandle( portQueue, portContext, waitHandle, callbackContext, callback, &portToken );
+    if ( FAILED( hr ) ) return hr;
+
+    hr = impl->waitRegistry->lpVtbl->Register( impl->waitRegistry, port, portToken, token );
+    if ( FAILED( hr ) )
+    {
+        portQueue->lpVtbl->UnregisterWaitHandle( portQueue, portToken );
+        return hr;
+    }
+
+    return S_OK;
+}
+
+static VOID WINAPI x_task_queue_UnregisterWaitHandle( IXTaskQueue *iface, XTaskQueueRegistrationToken token )
+{
+    HRESULT hr;
+
+    IXTaskQueuePortContext *portContext;
+    IXTaskQueuePort *queuePort;
+    XTaskQueuePort port;
+    XTaskQueueRegistrationToken portToken;
+
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+
+    TRACE( "iface %p, token %lld.\n", iface, token.token );
+
+    hr = impl->waitRegistry->lpVtbl->Unregister( impl->waitRegistry, token, &port, &portToken );
+    if ( FAILED( hr ) ) return;
+
+    hr = iface->lpVtbl->GetPortContext( iface, port, &portContext );
+    if ( FAILED( hr ) ) return;
+
+    queuePort = portContext->lpVtbl->get_Port( portContext );
+    queuePort->lpVtbl->UnregisterWaitHandle( queuePort, portToken );
+
+    return;
+}
+
+static HRESULT WINAPI x_task_queue_RegisterSubmitCallback( IXTaskQueue *iface, PVOID context, XTaskQueueMonitorCallback* callback, XTaskQueueRegistrationToken* token )
+{
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+
+    TRACE( "iface %p, context %p, callback %p, token %p.\n", iface, context, callback, token );
+
+    return impl->callbackSubmitted->lpVtbl->Register( impl->callbackSubmitted, context, callback, token );
+}
+
+static VOID WINAPI x_task_queue_UnregisterSubmitCallback( IXTaskQueue *iface, XTaskQueueRegistrationToken token )
+{
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+
+    TRACE( "iface %p, token %lld.\n", iface, token.token );
+
+    impl->callbackSubmitted->lpVtbl->Unregister( impl->callbackSubmitted, token );
+}
+
+static BOOLEAN WINAPI x_task_queue_get_CanTerminate( IXTaskQueue *iface )
+{
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return impl->terminationData.allowed;
+}
+
+static BOOLEAN WINAPI x_task_queue_get_CanClose( IXTaskQueue *iface )
+{
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return impl->allowClose;
+}
+
+static HRESULT WINAPI x_task_queue_Terminate( IXTaskQueue* iface, BOOLEAN wait, PVOID callbackContext, XTaskQueueTerminatedCallback* callback )
+{
+    HRESULT hr;
+    PVOID workToken;
+
+    XTerminate *terminate;
+    IXTaskQueuePort *queuePort;
+
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+
+    TRACE( "iface %p, wait %d, callbackContext %p, callback %p.\n", iface, wait, callbackContext, callback );
+
+    if (!(terminate = calloc( 1, sizeof(*terminate) ))) return E_OUTOFMEMORY;
+
+    if ( !impl->terminationData.allowed )
+        return E_ACCESSDENIED;
+
+    terminate->owner = iface;
+    terminate->level = TerminationLevel_Work;
+    terminate->context = callbackContext;
+    terminate->callback = callback;
+
+    queuePort = impl->workPort->lpVtbl->get_Port( impl->workPort );
+    hr = queuePort->lpVtbl->PrepareTerminate( queuePort, impl->workPort, (PVOID)terminate, iface->lpVtbl->OnTerminationCallback, &workToken );
+    if ( FAILED( hr ) ) goto _CLEANUP;
+
+    queuePort = impl->completionPort->lpVtbl->get_Port( impl->completionPort );
+    hr = queuePort->lpVtbl->PrepareTerminate( queuePort, impl->workPort, (PVOID)terminate, iface->lpVtbl->OnTerminationCallback, &terminate->completionPortToken );
+    if ( FAILED( hr ) )
+    {
+        queuePort->lpVtbl->CancelTermination( queuePort, workToken );
+        goto _CLEANUP;
+    }
+
+    iface->lpVtbl->AddRef( iface );
+    if ( wait ) iface->lpVtbl->AddRef( iface ); // guard against de-ref
+    queuePort = impl->workPort->lpVtbl->get_Port( impl->workPort );
+    queuePort->lpVtbl->Terminate( queuePort, workToken );
+
+    if ( wait )
+    {
+        EnterCriticalSection( &impl->terminationData.cs );
+        while( !impl->terminationData.terminated )
+        {
+            SleepConditionVariableCS( &impl->terminationData.cv, &impl->terminationData.cs, INFINITE );
+        }
+        LeaveCriticalSection( &impl->terminationData.cs );
+
+        queuePort = impl->workPort->lpVtbl->get_Port( impl->workPort );
+        queuePort->lpVtbl->WaitForUnwind( queuePort );
+
+        queuePort = impl->completionPort->lpVtbl->get_Port( impl->completionPort );
+        queuePort->lpVtbl->WaitForUnwind( queuePort );
+
+        iface->lpVtbl->Release( iface );
+    }
+
+_CLEANUP:
+    if ( FAILED( hr ) )
+        free( terminate );
+
+    return hr;
+}
+
+static VOID x_task_queue_RundownObject( IXTaskQueue* iface )
+{
+    IXTaskQueuePort *queuePort;
+
+    struct x_task_queue *impl = impl_from_IXTaskQueue( iface );
+
+    TRACE( "iface %p.\n", iface );
+    
+    impl->workPort->lpVtbl->SetStatus( impl->workPort, PortStatus_Terminated );
+    impl->completionPort->lpVtbl->SetStatus( impl->completionPort, PortStatus_Terminated );
+
+    queuePort = impl->workPort->lpVtbl->get_Port( impl->workPort );
+
+    if (queuePort != NULL)
+        queuePort->lpVtbl->Detach( queuePort, impl->workPort );
+
+    queuePort = impl->workPort->lpVtbl->get_Port( impl->workPort );
+
+    if (queuePort != NULL)
+       queuePort->lpVtbl->Detach( queuePort, impl->completionPort );
+
+    return;
+}
+
+static VOID CALLBACK x_task_queue_OnTerminationCallback( PVOID context )
+{
+    XTerminate *terminate = (XTerminate *)context;
+    IXTaskQueuePort *queuePort;
+
+    struct x_task_queue *impl = impl_from_IXTaskQueue( terminate->owner );
+
+    TRACE( "iface %p, context %p.\n", terminate->owner, context );
+
+    switch ( terminate->level )
+    {
+        case TerminationLevel_Work:
+            terminate->level = TerminationLevel_Completion;
+            queuePort = impl->completionPort->lpVtbl->get_Port( impl->workPort );
+            queuePort->lpVtbl->Terminate( queuePort, terminate->completionPortToken );
+            break;
+
+        case TerminationLevel_Completion:
+            if ( terminate->callback != NULL )
+            {
+                terminate->callback( terminate->context );
+            }
+
+            EnterCriticalSection( &impl->terminationData.cs );
+            impl->terminationData.terminated = TRUE;
+            WakeAllConditionVariable( &impl->terminationData.cv );
+            LeaveCriticalSection( &impl->terminationData.cs );
+
+            terminate->owner->lpVtbl->Release( terminate->owner );
+            free( terminate );
+            break;
+
+        case TerminationLevel_None:
+            break;
+    }
+}
+
+static const struct IXTaskQueueVtbl x_task_queue_vtbl =
+{
+    /* IUnknown methods */
+    x_task_queue_QueryInterface,
+    x_task_queue_AddRef,
+    x_task_queue_Release,
+    /* IXTaskQueue methods */
+    x_task_queue_Initialize,
+    x_task_queue_InitializeOverloadPorts,
+    x_task_queue_GetHandle,
+    x_task_queue_GetPortContext,
+    x_task_queue_RegisterWaitHandle,
+    x_task_queue_UnregisterWaitHandle,
+    x_task_queue_RegisterSubmitCallback,
+    x_task_queue_UnregisterSubmitCallback,
+    x_task_queue_get_CanTerminate,
+    x_task_queue_get_CanClose,
+    x_task_queue_Terminate,
+    x_task_queue_RundownObject,
+    x_task_queue_OnTerminationCallback
+};
+
+static HRESULT CreateTaskQueueHandle( IXTaskQueue* impl, XTaskQueueHandle* queue )
+{
+    XTaskQueueObject *taskObject = NULL;
+
+    TRACE( "impl %p, queue %p.\n", impl, queue );
+    
+    *queue = NULL;
+
+    if (!(taskObject = calloc( 1, sizeof(*taskObject) ))) return E_OUTOFMEMORY;
+
+    taskObject->signature = TASK_QUEUE_SIGNATURE;
+    taskObject->headQueue = impl;
+
+    impl->lpVtbl->AddRef( impl );
+
+    *queue = taskObject;
+
+    TRACE( "created taskObject %p.\n", taskObject );
+
+    return S_OK;
+}
+
+HRESULT XTaskQueueCreate( XTaskQueueDispatchMode workDispatchMode, XTaskQueueDispatchMode completionDispatchMode, XTaskQueueHandle* queue ) 
+{
+    HRESULT hr;
+
+    struct x_task_queue *impl = NULL;
+    struct x_task_queue_monitor_callback *monitor_callback_impl = NULL;
+    struct x_task_queue_port_context *workContext = NULL;
+    struct x_task_queue_port_context *completionContext = NULL;
+
+    TRACE( "workDispatchMode %d, completionDispatchMode %d, queue %p.\n", workDispatchMode, completionDispatchMode, queue );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+    if (!(monitor_callback_impl = calloc( 1, sizeof(*monitor_callback_impl) ))) return E_OUTOFMEMORY;
+    if (!(workContext = calloc( 1, sizeof(*workContext) ))) return E_OUTOFMEMORY;
+    if (!(completionContext = calloc( 1, sizeof(*completionContext) ))) return E_OUTOFMEMORY;
+
+    impl->IXTaskQueue_iface.lpVtbl = &x_task_queue_vtbl;
+    impl->queueHeader.signature = TASK_QUEUE_SIGNATURE;
+    impl->queueHeader.headQueue = &impl->IXTaskQueue_iface;
+
+    monitor_callback_impl->IXTaskQueueMonitorCallback_iface.lpVtbl = &x_task_queue_monitor_callback_vtbl;
+    InitializeCriticalSection( &monitor_callback_impl->cs );
+    monitor_callback_impl->queue = &impl->queueHeader;
+    monitor_callback_impl->ref = 1;
+
+    impl->callbackSubmitted = &monitor_callback_impl->IXTaskQueueMonitorCallback_iface;
+    impl->ref = 1;
+
+    workContext->IXTaskQueuePortContext_iface.lpVtbl = &x_task_queue_port_context_vtbl;
+    workContext->callbackSubmitted = impl->callbackSubmitted;
+    workContext->queue = &impl->IXTaskQueue_iface;
+    workContext->type = Work;
+    workContext->ref = 1;
+
+    impl->workPort = &workContext->IXTaskQueuePortContext_iface;
+
+    completionContext->IXTaskQueuePortContext_iface.lpVtbl = &x_task_queue_port_context_vtbl;
+    completionContext->callbackSubmitted = impl->callbackSubmitted;
+    completionContext->queue = &impl->IXTaskQueue_iface;
+    completionContext->type = Completion;
+    completionContext->ref = 1;
+
+    impl->completionPort = &completionContext->IXTaskQueuePortContext_iface;
+
+    *queue = NULL;
+
+    hr = impl->IXTaskQueue_iface.lpVtbl->InitializeOverloadPorts( &impl->IXTaskQueue_iface, workDispatchMode, completionDispatchMode, TRUE, TRUE );
+    if ( FAILED( hr ) ) goto _CLEANUP;
+
+    hr = CreateTaskQueueHandle( &impl->IXTaskQueue_iface, queue );
+
+_CLEANUP:
+    if ( FAILED( hr ) ) 
+        free( impl );
+
+    return hr;
+}
+
+HRESULT XTaskQueueGetPort( XTaskQueueHandle queue, XTaskQueuePort port, XTaskQueuePortHandle* portHandle )
+{
+    HRESULT hr;
+    IXTaskQueuePortContext *portContext;
+    IXTaskQueuePort *queuePort;
+    IXTaskQueue *impl;
+
+    TRACE( "queue %p, port %d, portHandle %p.\n", queue, port, portHandle );
+
+    if ( !queue )
+        return E_GAMERUNTIME_INVALID_HANDLE;
+
+    impl = queue->headQueue;
+
+    hr = impl->lpVtbl->GetPortContext( impl, port, &portContext );
+    if ( FAILED( hr ) ) return hr;
+    
+    queuePort = portContext->lpVtbl->get_Port( portContext );
+    *portHandle = queuePort->lpVtbl->GetHandle( queuePort );
+    
+    return S_OK;
+}
+
+HRESULT XTaskQueueCreateComposite( XTaskQueuePortHandle workPort, XTaskQueuePortHandle completionPort, XTaskQueueHandle* queue )
+{
+    HRESULT hr;
+
+    struct x_task_queue *impl = NULL;
+    struct x_task_queue_monitor_callback *monitor_callback_impl = NULL;
+    struct x_task_queue_port_context *workContext = NULL;
+    struct x_task_queue_port_context *completionContext = NULL;
+
+    TRACE( "workPort %p, completionPort %p, queue %p.\n", workPort, completionPort, queue );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+    if (!(monitor_callback_impl = calloc( 1, sizeof(*monitor_callback_impl) ))) return E_OUTOFMEMORY;
+    if (!(workContext = calloc( 1, sizeof(*workContext) ))) return E_OUTOFMEMORY;
+    if (!(completionContext = calloc( 1, sizeof(*completionContext) ))) return E_OUTOFMEMORY;
+
+    impl->IXTaskQueue_iface.lpVtbl = &x_task_queue_vtbl;
+    impl->queueHeader.signature = TASK_QUEUE_SIGNATURE;
+    impl->queueHeader.headQueue = &impl->IXTaskQueue_iface;
+
+    monitor_callback_impl->IXTaskQueueMonitorCallback_iface.lpVtbl = &x_task_queue_monitor_callback_vtbl;
+    InitializeCriticalSection( &monitor_callback_impl->cs );
+    monitor_callback_impl->queue = &impl->queueHeader;
+    monitor_callback_impl->ref = 1;
+
+    impl->callbackSubmitted = &monitor_callback_impl->IXTaskQueueMonitorCallback_iface;
+    impl->ref = 1;
+
+    workContext->IXTaskQueuePortContext_iface.lpVtbl = &x_task_queue_port_context_vtbl;
+    workContext->callbackSubmitted = impl->callbackSubmitted;
+    workContext->queue = &impl->IXTaskQueue_iface;
+    workContext->type = Work;
+    workContext->ref = 1;
+
+    impl->workPort = &workContext->IXTaskQueuePortContext_iface;
+
+    completionContext->IXTaskQueuePortContext_iface.lpVtbl = &x_task_queue_port_context_vtbl;
+    completionContext->callbackSubmitted = impl->callbackSubmitted;
+    completionContext->queue = &impl->IXTaskQueue_iface;
+    completionContext->type = Completion;
+    completionContext->ref = 1;
+
+    impl->completionPort = &completionContext->IXTaskQueuePortContext_iface;
+
+    *queue = NULL;
+
+    hr = impl->IXTaskQueue_iface.lpVtbl->Initialize( &impl->IXTaskQueue_iface, workPort, completionPort );
+    if ( FAILED( hr ) ) return hr;
+
+    hr = CreateTaskQueueHandle( &impl->IXTaskQueue_iface, queue );
+
+    return hr;
+}
+
+BOOLEAN XTaskQueueDispatch( XTaskQueueHandle queue, XTaskQueuePort port, UINT32 timeoutInMs )
+{
+    HRESULT hr;
+    IXTaskQueuePortContext *portContext;
+    IXTaskQueuePort *queuePort;
+    IXTaskQueue *impl;
+
+    TRACE( "queue %p, port %d, timeoutInMs %d.\n", queue, port, timeoutInMs );
+
+    if ( !queue )
+        return FALSE;
+
+    impl = queue->headQueue;
+
+    hr = impl->lpVtbl->GetPortContext( impl, port, &portContext );
+    if ( FAILED( hr ) ) return hr;
+    
+    queuePort = portContext->lpVtbl->get_Port( portContext );
+    
+    return queuePort->lpVtbl->Dispatch( queuePort, portContext, timeoutInMs );
+}
+
+VOID XTaskQueueCloseHandle( XTaskQueueHandle queue )
+{
+    IXTaskQueue *impl;
+
+    TRACE( "queue %p.\n", queue );
+
+    if ( !queue )
+        return;
+
+    impl = queue->headQueue;
+
+    if ( impl->lpVtbl->get_CanClose( impl ) )
+    {
+        if ( queue != impl->lpVtbl->GetHandle( impl ) )
+        {
+            free( queue );
+        }
+
+        impl->lpVtbl->Release( impl );
+    }
+    
+    return;
+}
+
+HRESULT XTaskQueueTerminate( XTaskQueueHandle queue, BOOLEAN wait, PVOID callbackContext, XTaskQueueTerminatedCallback* callback )
+{
+    IXTaskQueue *impl;
+
+    TRACE( "queue %p, wait %d, callbackContext %p, callback %p.\n", queue, wait, callbackContext, callback );
+
+    if ( !queue )
+        return E_GAMERUNTIME_INVALID_HANDLE;
+
+    impl = queue->headQueue;
+    return impl->lpVtbl->Terminate( impl, wait, callbackContext, callback );
+}
+
+HRESULT XTaskQueueSubmitDelayedCallback( XTaskQueueHandle queue, XTaskQueuePort port, UINT32 delayMs, PVOID callbackContext, XTaskQueueCallback* callback )
+{
+    HRESULT hr;
+    IXTaskQueuePortContext *portContext;
+    IXTaskQueuePort *queuePort;
+    IXTaskQueue *impl;
+
+    TRACE( "queue %p, port %d, delayMs %d, callbackContext %p, callback %p.\n", queue, port, delayMs, callbackContext, callback );
+
+    if ( !queue )
+        return FALSE;
+
+    impl = queue->headQueue;
+
+    hr = impl->lpVtbl->GetPortContext( impl, port, &portContext );
+    if ( FAILED( hr ) ) return hr;
+    
+    queuePort = portContext->lpVtbl->get_Port( portContext );
+
+    return queuePort->lpVtbl->QueueItem( queuePort, portContext, delayMs, callbackContext, callback );
+}
+
+HRESULT XTaskQueueDuplicateHandle( XTaskQueueHandle queue, XTaskQueueHandle* duplicatedHandle )
+{
+    HRESULT hr = S_OK;
+    IXTaskQueue *impl;
+
+    TRACE( "queue %p, duplicatedHandle %p.\n", queue, duplicatedHandle );
+
+    if ( !duplicatedHandle )
+        return E_POINTER;
+
+    if ( !queue )
+        return E_GAMERUNTIME_INVALID_HANDLE;
+
+    impl = queue->headQueue;
+
+    if ( impl->lpVtbl->get_CanClose( impl ) )
+    {
+        hr = CreateTaskQueueHandle( impl, duplicatedHandle );
+        TRACE( "created unique duplicate handle %p.\n", *duplicatedHandle );
+    } else
+    {
+        *duplicatedHandle = queue;
+    }
+    
+    return hr;
+}
+
+HRESULT XTaskQueueRegisterMonitor( XTaskQueueHandle queue, PVOID callbackContext, XTaskQueueMonitorCallback* callback, XTaskQueueRegistrationToken* token )
+{
+    IXTaskQueue *impl;
+
+    TRACE( "queue %p, callbackContext %p, callback %p, token %p.\n", queue, callbackContext, callback, token );
+
+    if ( !queue )
+        return E_GAMERUNTIME_INVALID_HANDLE;
+
+    impl = queue->headQueue;
+
+    return impl->lpVtbl->RegisterSubmitCallback( impl, callbackContext, callback, token );
+}
+
+VOID XTaskQueueResumeTermination( XTaskQueueHandle queue )
+{
+    HRESULT hr = S_OK;
+    IXTaskQueuePortContext *portContext;
+    IXTaskQueuePort *queuePort;
+    IXTaskQueue *impl;
+
+    TRACE( "queue %p.\n", queue );
+
+    if ( !queue )
+        return;
+
+    impl = queue->headQueue;
+
+    hr = impl->lpVtbl->GetPortContext( impl, Work, &portContext );
+    if ( FAILED( hr ) ) return;
+
+    queuePort = portContext->lpVtbl->get_Port( portContext );
+
+    queuePort->lpVtbl->ResumeTermination( queuePort, portContext );
+}
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/Threading/XTaskQueue.h b/dlls/xgameruntime/GDKComponent/System/Threading/XTaskQueue.h
new file mode 100644
index 00000000000..a205c57e049
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/Threading/XTaskQueue.h
@@ -0,0 +1,536 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XTask
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef XTASKQUEUE_H
+#define XTASKQUEUE_H
+
+#include "../../../private.h"
+
+#include "XOSThreading.h"
+#include "AtomicVector.h"
+#include "ThreadPool.h"
+
+typedef struct IXTaskQueue IXTaskQueue;
+typedef struct IXTaskQueuePort IXTaskQueuePort;
+typedef struct IXTaskQueueMonitorCallback IXTaskQueueMonitorCallback;
+typedef struct IXTaskQueuePortContext IXTaskQueuePortContext;
+typedef struct IXTaskQueueWaitCallback IXTaskQueueWaitCallback;
+
+static const UINT32 TASK_QUEUE_SIGNATURE = 0x41515545;
+static const UINT32 TASK_QUEUE_PORT_SIGNATURE = 0x41515553;
+
+typedef enum TerminationLevel
+{
+    TerminationLevel_None,
+    TerminationLevel_Work,
+    TerminationLevel_Completion
+} TerminationLevel;
+
+typedef struct XMonitor
+{
+    PVOID context;
+    UINT64 token;
+    XTaskQueueMonitorCallback *callback;
+    struct XMonitor *next;
+} XMonitor;
+
+typedef struct XQueue
+{
+    IXTaskQueuePortContext* portContext;
+    PVOID callbackContext;
+    XTaskQueueCallback* callback;
+    UINT64 enqueueTime;
+    UINT64 id;
+    struct XQueue* next;
+} XQueue;
+
+typedef struct XTerminateForPort
+{
+    IXTaskQueuePortContext* portContext;
+    PVOID callbackContext;
+    XTaskQueueTerminatedCallback* callback;
+    UINT64 node;
+    struct XTerminateForPort* next;
+} XTerminateForPort;
+
+typedef struct XTerminate
+{
+    IXTaskQueue* owner;
+    TerminationLevel level;
+    PVOID completionPortToken;
+    PVOID context;
+    XTaskQueueTerminatedCallback* callback;
+    struct XTerminate* next;
+} XTerminate;
+
+typedef struct XWait
+{
+    UINT64 Token;
+    UINT64 PortToken;
+    XTaskQueuePort Port; 
+} XWait;
+
+typedef struct XTerminateData
+{
+    BOOLEAN allowed;
+    BOOLEAN terminated;
+    CRITICAL_SECTION cs;
+    CONDITION_VARIABLE cv;
+} XTerminateData;
+
+typedef struct IXTaskQueuePortVtbl {
+    /* IUnknown methods */
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IXTaskQueuePort* This, 
+        REFIID riid, 
+        void** ppvObject);
+        
+    ULONG   (STDMETHODCALLTYPE *AddRef)(
+        IXTaskQueuePort* This);
+
+    ULONG   (STDMETHODCALLTYPE *Release)(
+        IXTaskQueuePort* This);
+
+    /* IXTaskQueuePort methods */
+    HRESULT (STDMETHODCALLTYPE *Initialize)(
+        IXTaskQueuePort* This,
+        XTaskQueueDispatchMode mode);
+
+    XTaskQueuePortHandle (STDMETHODCALLTYPE *GetHandle)(
+        IXTaskQueuePort* This);
+
+    HRESULT (STDMETHODCALLTYPE *QueueItem)(
+        IXTaskQueuePort* This,
+        IXTaskQueuePortContext* portContext,
+        UINT32 waitMs,
+        PVOID callbackContext,
+        XTaskQueueCallback* callback);
+
+    HRESULT (STDMETHODCALLTYPE *RegisterWaitHandle)(
+        IXTaskQueuePort* This,
+        IXTaskQueuePortContext* portContext,
+        HANDLE waitHandle,
+        PVOID callbackContext,
+        XTaskQueueCallback* callback,
+        XTaskQueueRegistrationToken* token);
+
+    VOID   (STDMETHODCALLTYPE *UnregisterWaitHandle)(
+        IXTaskQueuePort* This,
+        XTaskQueueRegistrationToken token);
+
+    HRESULT (STDMETHODCALLTYPE *PrepareTerminate)(
+        IXTaskQueuePort* This,
+        IXTaskQueuePortContext* portContext,
+        PVOID callbackContext,
+        XTaskQueueTerminatedCallback* callback,
+        PVOID *outPrepareToken);
+
+    VOID    (STDMETHODCALLTYPE *CancelTermination)(
+        IXTaskQueuePort* This,
+        PVOID prepareToken);
+
+    VOID    (STDMETHODCALLTYPE *Terminate)(
+        IXTaskQueuePort* This,
+        PVOID prepareToken);
+
+    HRESULT (STDMETHODCALLTYPE *Attach)(
+        IXTaskQueuePort* This,
+        IXTaskQueuePortContext* portContext);
+
+    VOID    (STDMETHODCALLTYPE *Detach)(
+        IXTaskQueuePort* This,
+        IXTaskQueuePortContext* portContext);
+
+    BOOLEAN (STDMETHODCALLTYPE *Dispatch)(
+        IXTaskQueuePort* This,
+        IXTaskQueuePortContext* portContext,
+        UINT32 timeoutInMs);
+
+    BOOLEAN (STDMETHODCALLTYPE *IsEmpty)(
+        IXTaskQueuePort* This);
+
+    VOID    (STDMETHODCALLTYPE *WaitForUnwind)(
+        IXTaskQueuePort* This);
+
+    HRESULT (STDMETHODCALLTYPE *SuspendTermination)(
+        IXTaskQueuePort* This,
+        IXTaskQueuePortContext* portContext);
+
+    VOID    (STDMETHODCALLTYPE *ResumeTermination)(
+        IXTaskQueuePort* This,
+        IXTaskQueuePortContext* portContext);
+
+    VOID    (STDMETHODCALLTYPE *SuspendPort)(
+        IXTaskQueuePort* This);
+
+    VOID    (STDMETHODCALLTYPE *ResumePort)(
+        IXTaskQueuePort* This);
+
+    HRESULT (*VerifyNotTerminated)(
+        IXTaskQueuePort* This,
+        IXTaskQueuePortContext* portContext);
+
+    BOOLEAN (*IsCallCanceled)(
+        IXTaskQueuePort* This,
+        XQueue *entry);
+
+    BOOLEAN (*AppendEntry)(
+        IXTaskQueuePort* This,
+        XQueue *entry);
+
+    VOID    (*CancelPendingEntries)(
+        IXTaskQueuePort* This,
+        IXTaskQueuePortContext* portContext,
+        BOOLEAN appendToQueue);
+
+    BOOLEAN (*DrainOneItem)(
+        IXTaskQueuePort* This);
+
+    BOOLEAN (*Wait)(
+        IXTaskQueuePort* This,
+        IXTaskQueuePortContext* portContext,
+        UINT32 timeout);
+
+    VOID    (*EraseQueue)(
+        IXTaskQueuePort* This,
+        XQueue* queueHead,
+        XQueue* queueTail);
+
+    BOOLEAN (*ScheduleNextPendingCallback)(
+        IXTaskQueuePort* This,
+        UINT64 dueTime,
+        XQueue **dueEntry);
+
+    VOID    (*SubmitPendingCallback)(
+        IXTaskQueuePort* This);
+
+    VOID    (*SignalTerminations)(
+        IXTaskQueuePort* This);
+
+    VOID    (*ScheduleTermination)(
+        IXTaskQueuePort* This,
+        XTerminateForPort* terminate);
+
+    VOID    (*SignalQueue)(
+        IXTaskQueuePort* This);
+
+    VOID    (*NotifyItemQueued)(
+        IXTaskQueuePort* This);
+
+    VOID    (*ProcessThreadPoolCallback)(
+        IXTaskQueuePort* This,
+        ThreadPoolActionStatus *status);
+} IXTaskQueuePortVtbl;
+
+typedef struct IXTaskQueuePortContextVtbl {
+    /* IUnknown methods */
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IXTaskQueuePortContext* This, 
+        REFIID riid, 
+        void** ppvObject);
+        
+    ULONG   (STDMETHODCALLTYPE *AddRef)(
+        IXTaskQueuePortContext* This);
+
+    ULONG   (STDMETHODCALLTYPE *Release)(
+        IXTaskQueuePortContext* This);
+
+    /* IXTaskQueuePortContext methods */
+    XTaskQueuePort (STDMETHODCALLTYPE *get_Type)(
+        IXTaskQueuePortContext* This);
+
+    XTaskQueuePortStatus (STDMETHODCALLTYPE *get_Status)(
+        IXTaskQueuePortContext* This);
+
+    IXTaskQueue* (STDMETHODCALLTYPE *get_PartentQueue)(
+        IXTaskQueuePortContext* This);
+
+    IXTaskQueuePort* (STDMETHODCALLTYPE *get_Port)(
+        IXTaskQueuePortContext* This);
+
+    VOID    (STDMETHODCALLTYPE *SetStatus)(
+        IXTaskQueuePortContext* This,
+        XTaskQueuePortStatus status);
+
+    VOID    (STDMETHODCALLTYPE *ItemQueued)(
+        IXTaskQueuePortContext* This);
+
+    BOOLEAN (STDMETHODCALLTYPE *AddSuspend)(
+        IXTaskQueuePortContext* This);
+
+    BOOLEAN (STDMETHODCALLTYPE *RemoveSuspend)(
+        IXTaskQueuePortContext* This);
+
+} IXTaskQueuePortContextVtbl;
+
+typedef struct IXTaskQueueVtbl {
+    /* IUnknown methods */
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IXTaskQueue* This, 
+        REFIID riid, 
+        void** ppvObject);
+        
+    ULONG   (STDMETHODCALLTYPE *AddRef)(
+        IXTaskQueue* This);
+
+    ULONG   (STDMETHODCALLTYPE *Release)(
+        IXTaskQueue* This);
+
+    /* IXTaskQueue methods */
+    HRESULT (STDMETHODCALLTYPE *Initialize)(
+        IXTaskQueue* This, 
+        XTaskQueuePortHandle workPort, 
+        XTaskQueuePortHandle completionPort);
+
+    HRESULT (STDMETHODCALLTYPE *InitializeOverloadPorts)(
+        IXTaskQueue* This, 
+        XTaskQueueDispatchMode workDispatch, 
+        XTaskQueueDispatchMode completionDispatch,
+        BOOLEAN allowTermination,
+        BOOLEAN allowClose);
+
+    XTaskQueueHandle (STDMETHODCALLTYPE *GetHandle)(
+        IXTaskQueue* This);
+    
+    HRESULT (STDMETHODCALLTYPE *GetPortContext)(
+        IXTaskQueue* This,
+        XTaskQueuePort port,
+        IXTaskQueuePortContext** portContext);
+
+    HRESULT (STDMETHODCALLTYPE *RegisterWaitHandle)(
+        IXTaskQueue* This,
+        XTaskQueuePort port,
+        HANDLE waitHandle,
+        PVOID callbackContext,
+        XTaskQueueCallback* callback,
+        XTaskQueueRegistrationToken* token);
+
+    VOID    (STDMETHODCALLTYPE *UnregisterWaitHandle)(
+        IXTaskQueue* This,
+        XTaskQueueRegistrationToken token);
+
+    HRESULT (STDMETHODCALLTYPE *RegisterSubmitCallback)(
+        IXTaskQueue* This,
+        PVOID context,
+        XTaskQueueMonitorCallback* callback,
+        XTaskQueueRegistrationToken* token);
+
+    VOID    (STDMETHODCALLTYPE *UnregisterSubmitCallback)(
+        IXTaskQueue* This,
+        XTaskQueueRegistrationToken token);
+
+    BOOLEAN (STDMETHODCALLTYPE *get_CanTerminate)(
+        IXTaskQueue* This);
+
+    BOOLEAN (STDMETHODCALLTYPE *get_CanClose)(
+        IXTaskQueue* This);
+
+    HRESULT (STDMETHODCALLTYPE *Terminate)(
+        IXTaskQueue* This,
+        BOOLEAN wait,
+        PVOID callbackContext,
+        XTaskQueueTerminatedCallback* callback);
+
+    VOID    (*RundownObject)(
+        IXTaskQueue* This);
+
+    VOID    (CALLBACK *OnTerminationCallback)(
+        PVOID context);
+} IXTaskQueueVtbl;
+
+typedef struct IXTaskQueueMonitorCallbackVtbl {
+    /* IUnknown methods */
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IXTaskQueueMonitorCallback* This, 
+        REFIID riid, 
+        void** ppvObject);
+        
+    ULONG   (STDMETHODCALLTYPE *AddRef)(
+        IXTaskQueueMonitorCallback* This);
+
+    ULONG   (STDMETHODCALLTYPE *Release)(
+        IXTaskQueueMonitorCallback* This);
+        
+    /* IXTaskQueueMonitorCallback methods */
+    HRESULT (STDMETHODCALLTYPE *Register)(
+        IXTaskQueueMonitorCallback* This,
+        PVOID context,
+        XTaskQueueMonitorCallback* callback,
+        XTaskQueueRegistrationToken *token
+    );
+
+    VOID    (STDMETHODCALLTYPE *Unregister)(
+        IXTaskQueueMonitorCallback* This,
+        XTaskQueueRegistrationToken token
+    );
+
+    VOID    (STDMETHODCALLTYPE *Invoke)(
+        IXTaskQueueMonitorCallback* This,
+        XTaskQueuePort port
+    );
+    
+} IXTaskQueueMonitorCallbackVtbl;
+
+typedef struct IXTaskQueueWaitCallbackVtbl {
+    /* IUnknown methods */
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IXTaskQueueWaitCallback* This, 
+        REFIID riid, 
+        void** ppvObject);
+        
+    ULONG   (STDMETHODCALLTYPE *AddRef)(
+        IXTaskQueueWaitCallback* This);
+
+    ULONG   (STDMETHODCALLTYPE *Release)(
+        IXTaskQueueWaitCallback* This);
+
+    /* IXTaskQueueWaitCallback methods */
+    HRESULT (STDMETHODCALLTYPE *Register)(
+        IXTaskQueueWaitCallback* This,
+        XTaskQueuePort port,
+        XTaskQueueRegistrationToken portToken,
+        XTaskQueueRegistrationToken *token);
+    
+    HRESULT (STDMETHODCALLTYPE *Unregister)(
+        IXTaskQueueWaitCallback* This,
+        XTaskQueueRegistrationToken token,
+        XTaskQueuePort *outPort,
+        XTaskQueueRegistrationToken *outPortToken
+    );
+} IXTaskQueueWaitCallbackVtbl;
+
+struct IXTaskQueue {
+    const IXTaskQueueVtbl* lpVtbl;
+};
+
+struct IXTaskQueuePortContext {
+    const IXTaskQueuePortContextVtbl* lpVtbl;
+};
+
+struct IXTaskQueueMonitorCallback {
+    const IXTaskQueueMonitorCallbackVtbl* lpVtbl;
+};
+
+struct IXTaskQueuePort {
+    const IXTaskQueuePortVtbl* lpVtbl;
+};
+
+struct IXTaskQueueWaitCallback {
+    const IXTaskQueueWaitCallbackVtbl* lpVtbl;
+};
+
+// Backwards decleration of XTaskQueueObject
+typedef struct XTaskQueueObject
+{
+    UINT32 signature;
+    IXTaskQueue *headQueue;
+} XTaskQueueObject;
+
+// Backwards decleration of XTaskQueuePortObject
+typedef struct XTaskQueuePortObject
+{
+    UINT32 signature;
+    IXTaskQueuePort *headPort;
+    IXTaskQueue *headQueue;
+} XTaskQueuePortObject;
+
+struct x_task_queue_monitor_callback
+{
+    IXTaskQueueMonitorCallback IXTaskQueueMonitorCallback_iface;
+    UINT32 monitors_size;
+    CRITICAL_SECTION cs;
+    XMonitor *monitors_tail, *monitors_head;
+    XTaskQueueHandle queue;
+    LONG ref;
+};
+
+struct x_task_queue_port
+{
+    IXTaskQueuePort IXTaskQueuePort_iface;
+    XTaskQueuePortObject portHeader;
+    XTaskQueueDispatchMode dispatchMode;
+    IAtomicVector *attachedContexts;
+    LONG processingCallback;
+    CONDITION_VARIABLE cv;
+    CONDITION_VARIABLE cvAny;
+    CRITICAL_SECTION cs;
+    XQueue *queueList_tail, *queueList_head;
+    XQueue *pendingQueueList_tail, *pendingQueueList_head;
+    XTerminateForPort *terminateList_tail, *terminateList_head;
+    XTerminateForPort *pendingTerminateList_tail, *pendingTerminateList_head;
+    IXWaitTimer *timer;
+    IThreadPool *threadPool;
+    LONG64 timerDue;
+    LONG nextId;
+    BOOLEAN signaled;
+    BOOL suspended;
+    LONG ref;
+};
+
+struct x_task_queue_port_context
+{
+    IXTaskQueuePortContext IXTaskQueuePortContext_iface;
+    IXTaskQueuePort *port;
+    IXTaskQueue *source;
+
+    XTaskQueuePort type;
+    XTaskQueuePortStatus status;
+    IXTaskQueue *queue;
+    IXTaskQueueMonitorCallback *callbackSubmitted;
+    LONG suspendCount;
+    LONG ref;
+};
+
+struct x_task_queue
+{
+    IXTaskQueue IXTaskQueue_iface;
+
+    XTaskQueueObject queueHeader;
+    IXTaskQueueMonitorCallback *callbackSubmitted;
+    IXTaskQueueWaitCallback *waitRegistry;
+    XTerminateData terminationData;
+    IXTaskQueuePortContext *workPort;
+    IXTaskQueuePortContext *completionPort;
+    BOOLEAN allowClose;
+    LONG ref;
+};
+
+struct x_task_queue_wait_callback
+{
+    IXTaskQueueWaitCallback IXTaskQueueWaitCallback_iface;
+    UINT64 nextToken;
+    XWait callbacks[120];
+    CRITICAL_SECTION cs;
+    LONG ref;
+};
+
+HRESULT XTaskQueueCreate( XTaskQueueDispatchMode workDispatchMode, XTaskQueueDispatchMode completionDispatchMode, XTaskQueueHandle* queue );
+HRESULT XTaskQueueGetPort( XTaskQueueHandle queue, XTaskQueuePort port, XTaskQueuePortHandle* portHandle );
+HRESULT XTaskQueueCreateComposite( XTaskQueuePortHandle workPort, XTaskQueuePortHandle completionPort, XTaskQueueHandle* queue );
+BOOLEAN XTaskQueueDispatch( XTaskQueueHandle queue, XTaskQueuePort port, UINT32 timeoutInMs );
+VOID XTaskQueueCloseHandle( XTaskQueueHandle queue );
+HRESULT XTaskQueueTerminate( XTaskQueueHandle queue, BOOLEAN wait, PVOID callbackContext, XTaskQueueTerminatedCallback* callback );
+HRESULT XTaskQueueSubmitDelayedCallback( XTaskQueueHandle queue, XTaskQueuePort port, UINT32 delayMs, PVOID callbackContext, XTaskQueueCallback* callback );
+HRESULT XTaskQueueDuplicateHandle( XTaskQueueHandle queue, XTaskQueueHandle* duplicatedHandle );
+HRESULT XTaskQueueRegisterMonitor( XTaskQueueHandle queue, PVOID callbackContext, XTaskQueueMonitorCallback* callback, XTaskQueueRegistrationToken* token );
+VOID XTaskQueueResumeTermination( XTaskQueueHandle queue );
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/XGameRuntimeFeature.c b/dlls/xgameruntime/GDKComponent/System/XGameRuntimeFeature.c
new file mode 100644
index 00000000000..d9ec844b507
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/XGameRuntimeFeature.c
@@ -0,0 +1,88 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XGameRuntimeFeature
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "XGameRuntimeFeature.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(gdkc);
+
+static inline struct x_game_runtime_feature *impl_from_IXGameRuntimeFeatureImpl( IXGameRuntimeFeatureImpl *iface )
+{
+    return CONTAINING_RECORD( iface, struct x_game_runtime_feature, IXGameRuntimeFeatureImpl_iface );
+}
+
+static HRESULT WINAPI x_game_runtime_feature_QueryInterface( IXGameRuntimeFeatureImpl *iface, REFIID iid, void **out )
+{
+    struct x_game_runtime_feature *impl = impl_from_IXGameRuntimeFeatureImpl( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IXGameRuntimeFeatureImpl ))
+    {
+        *out = &impl->IXGameRuntimeFeatureImpl_iface;
+        impl->IXGameRuntimeFeatureImpl_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI x_game_runtime_feature_AddRef( IXGameRuntimeFeatureImpl *iface )
+{
+    struct x_game_runtime_feature *impl = impl_from_IXGameRuntimeFeatureImpl( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI x_game_runtime_feature_Release( IXGameRuntimeFeatureImpl *iface )
+{
+    struct x_game_runtime_feature *impl = impl_from_IXGameRuntimeFeatureImpl( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static BOOLEAN WINAPI x_game_runtime_feature_XGameRuntimeIsFeatureAvailable( IXGameRuntimeFeatureImpl *iface, XGameRuntimeFeature feature )
+{
+    // Always assume the feature is available, regardless of what game it is, for compatibility reasons.
+    TRACE( "iface %p feature %d.\n", iface, feature );
+    return TRUE;
+}
+
+static const struct IXGameRuntimeFeatureImplVtbl x_game_runtime_feature_vtbl =
+{
+    x_game_runtime_feature_QueryInterface,
+    x_game_runtime_feature_AddRef,
+    x_game_runtime_feature_Release,
+    /* IXGameRuntimeFeatureImpl methods */
+    x_game_runtime_feature_XGameRuntimeIsFeatureAvailable
+};
+
+static struct x_game_runtime_feature x_game_runtime_feature =
+{
+    {&x_game_runtime_feature_vtbl},
+    0,
+};
+
+IXGameRuntimeFeatureImpl *x_game_runtime_feature_impl = &x_game_runtime_feature.IXGameRuntimeFeatureImpl_iface;
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/XGameRuntimeFeature.h b/dlls/xgameruntime/GDKComponent/System/XGameRuntimeFeature.h
new file mode 100644
index 00000000000..7e51d734b7c
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/XGameRuntimeFeature.h
@@ -0,0 +1,35 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XGameRuntimeFeature
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef XGAMERUNTIMEFEATURE_H
+#define XGAMERUNTIMEFEATURE_H
+
+#include "../../private.h"
+
+#include <string.h>
+
+struct x_game_runtime_feature
+{
+    IXGameRuntimeFeatureImpl IXGameRuntimeFeatureImpl_iface;
+    LONG ref;
+};
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/XSystem.c b/dlls/xgameruntime/GDKComponent/System/XSystem.c
new file mode 100644
index 00000000000..a7f0a603e2b
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/XSystem.c
@@ -0,0 +1,147 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XSystem
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "XSystem.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(gdkc);
+
+static inline struct x_system *impl_from_IXSystemImpl( IXSystemImpl *iface )
+{
+    return CONTAINING_RECORD( iface, struct x_system, IXSystemImpl_iface );
+}
+
+static HRESULT WINAPI x_system_QueryInterface( IXSystemImpl *iface, REFIID iid, void **out )
+{
+    struct x_system *impl = impl_from_IXSystemImpl( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IXSystemImpl ))
+    {
+        *out = &impl->IXSystemImpl_iface;
+        impl->IXSystemImpl_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI x_system_AddRef( IXSystemImpl *iface )
+{
+    struct x_system *impl = impl_from_IXSystemImpl( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI x_system_Release( IXSystemImpl *iface )
+{
+    struct x_system *impl = impl_from_IXSystemImpl( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI x_system_XSystemGetConsoleId( IXSystemImpl *iface, INT32 consoleIdSize, LPSTR consoleId, SIZE_T *consoleIdUsed )
+{    
+    // For Windows, Console ID is always `00000000.00000000.00000000.00000000.00
+    LPCSTR Id = "00000000.00000000.00000000.00000000.00";
+
+    TRACE( "iface %p, consoleIdSize %d, consoleId %p, consoleIdUsed %p\n", iface, consoleIdSize, consoleId, consoleIdUsed );
+
+    if ( !consoleId || !consoleIdUsed )
+        return E_POINTER;
+
+    if ( consoleIdSize < XSystemConsoleIdBytes )
+        return HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
+
+    strcpy_s( consoleId, consoleIdSize, Id );
+    *consoleIdUsed = strlen( Id ) + 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI x_system_XSystemGetXboxLiveSandboxId( IXSystemImpl *iface, INT32 sandboxIdSize, LPSTR sandboxId, SIZE_T *sandboxIdUsed )
+{    
+    // Always assume RETAIL environment for Wine
+    LPCSTR Id = "RETAIL";
+
+    TRACE( "iface %p, sandboxIdSize %d, sandboxId %p, sandboxIdUsed %p\n", iface, sandboxIdSize, sandboxId, sandboxIdUsed );
+
+    if ( !sandboxId || !sandboxIdUsed )
+        return E_POINTER;
+
+    if ( sandboxIdSize < XSystemXboxLiveSandboxIdMaxBytes )
+        return HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
+
+    strcpy_s( sandboxId, sandboxIdSize, Id );
+    *sandboxIdUsed = strlen( Id ) + 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI x_system_XSystemGetAppSpecificDeviceId( IXSystemImpl *iface, INT32 appSpecificDeviceIdSize, LPSTR appSpecificDeviceId, SIZE_T *appSpecificDeviceIdUsed )
+{    
+    FIXME( "iface %p, appSpecificDeviceIdSize %d, appSpecificDeviceId %p, appSpecificDeviceIdUsed %p stub!\n", iface, appSpecificDeviceIdSize, appSpecificDeviceId, appSpecificDeviceIdUsed );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI x_system_XSystemHandleTrack( IXSystemImpl *iface )
+{
+    FIXME( "iface %p stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+static BOOLEAN WINAPI x_system_XSystemIsHandleValid( IXSystemImpl *iface )
+{
+    // always assume it's valid.
+    FIXME( "iface %p stub!\n", iface );
+    return TRUE;
+}
+
+static HRESULT WINAPI x_system_XSystemAllowFullDownloadBandwidth( IXSystemImpl *iface, boolean enable )
+{
+    FIXME( "iface %p, enable %d stub!\n", iface, enable );
+    return E_NOTIMPL;
+}
+
+static const struct IXSystemImplVtbl x_system_vtbl =
+{
+    x_system_QueryInterface,
+    x_system_AddRef,
+    x_system_Release,
+    /* IXSystemImpl methods */
+    x_system_XSystemGetConsoleId,
+    x_system_XSystemGetXboxLiveSandboxId,
+    x_system_XSystemGetAppSpecificDeviceId,
+    x_system_XSystemHandleTrack,
+    x_system_XSystemIsHandleValid,
+    x_system_XSystemAllowFullDownloadBandwidth
+};
+
+static struct x_system x_system =
+{
+    {&x_system_vtbl},
+    0,
+};
+
+IXSystemImpl *x_system_impl = &x_system.IXSystemImpl_iface;
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/XSystem.h b/dlls/xgameruntime/GDKComponent/System/XSystem.h
new file mode 100644
index 00000000000..ad3ab342586
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/XSystem.h
@@ -0,0 +1,39 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XSystem
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef XSYSTEM_H
+#define XSYSTEM_H
+
+#include "../../private.h"
+
+#include <string.h>
+
+struct x_system
+{
+    IXSystemImpl IXSystemImpl_iface;
+    LONG ref;
+};
+
+const SIZE_T XSystemConsoleIdBytes = 39;
+const SIZE_T XSystemXboxLiveSandboxIdMaxBytes = 16;
+const SIZE_T XSystemAppSpecificDeviceIdBytes = 45;
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/XSystemAnalytics.c b/dlls/xgameruntime/GDKComponent/System/XSystemAnalytics.c
new file mode 100644
index 00000000000..990ea1c36bc
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/XSystemAnalytics.c
@@ -0,0 +1,192 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XSystem
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "XSystemAnalytics.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(gdkc);
+
+static inline struct x_system_analytics *impl_from_IXSystemAnalyticsImpl( IXSystemAnalyticsImpl *iface )
+{
+    return CONTAINING_RECORD( iface, struct x_system_analytics, IXSystemAnalyticsImpl_iface );
+}
+
+static HRESULT WINAPI x_system_analytics_QueryInterface( IXSystemAnalyticsImpl *iface, REFIID iid, void **out )
+{
+    struct x_system_analytics *impl = impl_from_IXSystemAnalyticsImpl( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IXSystemAnalyticsImpl ))
+    {
+        *out = &impl->IXSystemAnalyticsImpl_iface;
+        impl->IXSystemAnalyticsImpl_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI x_system_analytics_AddRef( IXSystemAnalyticsImpl *iface )
+{
+    struct x_system_analytics *impl = impl_from_IXSystemAnalyticsImpl( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI x_system_analytics_Release( IXSystemAnalyticsImpl *iface )
+{
+    struct x_system_analytics *impl = impl_from_IXSystemAnalyticsImpl( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static XSystemAnalyticsInfo * WINAPI x_system_analytics_XSystemGetAnalyticsInfo( IXSystemAnalyticsImpl *iface, XSystemAnalyticsInfo *__ret )
+{
+    // For Windows, XSystemAnalyticsInfo->form is always "Desktop"
+    XSystemAnalyticsInfo info;    
+    ULONGLONG version;
+    LPCWSTR analytics_info_str = RuntimeClass_Windows_System_Profile_AnalyticsInfo;
+    HSTRING analytics_info_class;
+    HSTRING deviceFamilyVersion;
+    HSTRING deviceFamily;
+    LPCWSTR deviceFamilyVersionStr;
+    LPCWSTR deviceFamilyStr;
+    HRESULT status;
+    UINT32 strSize;
+    LPSTR str;
+    PSTR splitter;
+
+    IAnalyticsVersionInfo *analytics_version_info = NULL;
+    IAnalyticsInfoStatics *analytics_info_statics = NULL;
+
+    TRACE( "iface %p.\n", iface );
+
+    status = WindowsCreateString( analytics_info_str, wcslen( analytics_info_str ), &analytics_info_class );
+    if ( FAILED( status ) ) return NULL;
+
+    status = RoGetActivationFactory( analytics_info_class, &IID_IAnalyticsInfoStatics, (void **)&analytics_info_statics );
+    WindowsDeleteString( analytics_info_class );
+    if ( FAILED( status ) ) return NULL;
+
+    status = IAnalyticsInfoStatics_get_VersionInfo( analytics_info_statics, &analytics_version_info );
+    IAnalyticsInfoStatics_Release( analytics_info_statics );
+    if ( FAILED( status ) ) return NULL;
+
+    status = IAnalyticsVersionInfo_get_DeviceFamilyVersion( analytics_version_info, &deviceFamilyVersion );
+    if ( FAILED( status ) )
+    {
+        IAnalyticsVersionInfo_Release( analytics_version_info );
+        return NULL;
+    }
+
+    status = IAnalyticsVersionInfo_get_DeviceFamily( analytics_version_info, &deviceFamily );
+    IAnalyticsVersionInfo_Release( analytics_version_info );
+    if ( FAILED( status ) )
+    {
+        WindowsDeleteString( deviceFamilyVersion );
+        return NULL;
+    }
+
+    deviceFamilyStr = WindowsGetStringRawBuffer( deviceFamily, NULL );
+    strSize = WideCharToMultiByte( CP_UTF8, 0, deviceFamilyStr, -1, NULL, 0, NULL, NULL );
+
+    str = (LPSTR)malloc( strSize );
+    if ( !str )
+    {
+        WindowsDeleteString( deviceFamilyVersion );
+        WindowsDeleteString( deviceFamily );
+        return NULL;
+    }
+
+    if ( !WideCharToMultiByte( CP_UTF8, 0, deviceFamilyStr, -1, str, strSize, NULL, NULL ) )
+    {
+        WindowsDeleteString( deviceFamilyVersion );
+        WindowsDeleteString( deviceFamily );
+        free( str );
+        return NULL;
+    }
+
+    splitter = strchr( str, '.' );
+    if ( splitter )
+    {
+        *splitter = '\0';
+
+        strcpy( info.family, str );
+        strcpy( info.form, splitter + 1 );
+    }
+
+    WindowsDeleteString( deviceFamily );
+    free( str );
+
+    deviceFamilyVersionStr = WindowsGetStringRawBuffer( deviceFamilyVersion, NULL );
+    strSize = WideCharToMultiByte( CP_UTF8, 0, deviceFamilyVersionStr, -1, NULL, 0, NULL, NULL );
+
+    str = (LPSTR)malloc( strSize );
+    if ( !str )
+    {
+        WindowsDeleteString( deviceFamilyVersion );
+        return NULL;
+    }
+
+    if ( !WideCharToMultiByte( CP_UTF8, 0, deviceFamilyVersionStr, -1, str, strSize, NULL, NULL ) )
+    {
+        WindowsDeleteString( deviceFamilyVersion );
+        free( str );
+        return NULL;
+    }
+
+    version = strtoull( str, NULL, 10 );
+    info.osVersion.major = (UINT16)(version >> 48);
+    info.osVersion.minor = (UINT16)((version >> 32) & 0xFFFF);
+    info.osVersion.build = (UINT16)((version >> 16) & 0xFFFF);
+    info.osVersion.revision = (UINT16)(version & 0xFFFF);
+
+    WindowsDeleteString( deviceFamilyVersion );
+    free( str );
+
+    info.hostingOsVersion = info.osVersion;
+
+    *__ret = info;
+
+    return __ret;
+}
+
+static const struct IXSystemAnalyticsImplVtbl x_system_analytics_vtbl =
+{
+    x_system_analytics_QueryInterface,
+    x_system_analytics_AddRef,
+    x_system_analytics_Release,
+    /* IXSystemAnalyticsImpl methods */
+    x_system_analytics_XSystemGetAnalyticsInfo
+};
+
+static struct x_system_analytics x_system_analytics =
+{
+    {&x_system_analytics_vtbl},
+    0,
+};
+
+IXSystemAnalyticsImpl *x_system_analytics_impl = &x_system_analytics.IXSystemAnalyticsImpl_iface;
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/XSystemAnalytics.h b/dlls/xgameruntime/GDKComponent/System/XSystemAnalytics.h
new file mode 100644
index 00000000000..59ce77e073d
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/XSystemAnalytics.h
@@ -0,0 +1,35 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XSystem
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef XSYSTEM_ANALYTICS_H
+#define XSYSTEM_ANALYTICS_H
+
+#include "../../private.h"
+
+#include <string.h>
+
+struct x_system_analytics
+{
+    IXSystemAnalyticsImpl IXSystemAnalyticsImpl_iface;
+    LONG ref;
+};
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/XThreading.c b/dlls/xgameruntime/GDKComponent/System/XThreading.c
new file mode 100644
index 00000000000..ef86655a7b8
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/XThreading.c
@@ -0,0 +1,296 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XThread, XAsync and XTask
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "XThreading.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(gdkc);
+
+static inline struct x_threading *impl_from_IXThreadingImpl( IXThreadingImpl *iface )
+{
+    return CONTAINING_RECORD( iface, struct x_threading, IXThreadingImpl_iface );
+}
+
+static HRESULT WINAPI x_threading_QueryInterface( IXThreadingImpl *iface, REFIID iid, void **out )
+{
+    struct x_threading *impl = impl_from_IXThreadingImpl( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IXThreadingImpl ))
+    {
+        *out = &impl->IXThreadingImpl_iface;
+        impl->IXThreadingImpl_iface.lpVtbl->AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI x_threading_AddRef( IXThreadingImpl *iface )
+{
+    struct x_threading *impl = impl_from_IXThreadingImpl( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI x_threading_Release( IXThreadingImpl *iface )
+{
+    struct x_threading *impl = impl_from_IXThreadingImpl( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+/* --- XAsync --- */
+
+static HRESULT WINAPI x_threading_XAsyncGetStatus( IXThreadingImpl *iface, XAsyncBlock *asyncBlock, boolean wait )
+{
+    TRACE( "iface %p, asyncBlock %p, wait %d.\n", iface, asyncBlock, wait );
+    return XAsyncGetStatus( asyncBlock, wait );
+}
+
+static HRESULT WINAPI x_threading_XAsyncGetResultSize( IXThreadingImpl *iface, XAsyncBlock *asyncBlock, SIZE_T *bufferSize )
+{
+    TRACE( "iface %p, asyncBlock %p, bufferSize %p.\n", iface, asyncBlock, bufferSize );
+    return XAsyncGetResultSize( asyncBlock, bufferSize );
+}
+
+static VOID WINAPI x_threading_XAsyncCancel( IXThreadingImpl *iface, XAsyncBlock *asyncBlock )
+{
+    TRACE( "iface %p, asyncBlock %p.\n", iface, asyncBlock );
+    XAsyncCancel( asyncBlock );
+    return;
+}
+
+static HRESULT WINAPI x_threading_XAsyncRun( IXThreadingImpl *iface, XAsyncBlock *asyncBlock, XAsyncWork *work )
+{
+    TRACE( "iface %p, asyncBlock %p, work %p.\n", iface, asyncBlock, work );
+    return XAsyncRun( asyncBlock, work );
+}
+
+/* --- XAsyncProvider --- */
+
+static HRESULT WINAPI x_threading_XAsyncBegin(IXThreadingImpl* iface, XAsyncBlock* asyncBlock, PVOID context, const PVOID identity, LPCSTR identityName, XAsyncProviderCallback* provider)
+{
+    TRACE( "iface %p, asyncBlock %p, context %p, identity %p, identityName %s, provider %p.\n", iface, asyncBlock, context, identity, identityName, provider );
+    return XAsyncBegin( asyncBlock, context, identity, identityName, provider );
+}
+
+static HRESULT WINAPI __PADDING__( IXThreadingImpl* iface )
+{
+    WARN( "iface %p padding function called! It's unknown what this function does\n", iface );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI x_threading_XAsyncSchedule( IXThreadingImpl* iface, XAsyncBlock* asyncBlock, UINT32 delayInMs )
+{
+    TRACE( "iface %p, asyncBlock %p, delayInMs %d.\n", iface, asyncBlock, delayInMs );
+    return XAsyncSchedule( asyncBlock, delayInMs );
+}
+
+static VOID WINAPI x_threading_XAsyncComplete( IXThreadingImpl* iface, XAsyncBlock* asyncBlock, HRESULT result, SIZE_T requiredBufferSize )
+{
+    TRACE( "iface %p, asyncBlock %p, result %#lx, requiredBufferSize %lld.\n", iface, asyncBlock, result, requiredBufferSize );
+    XAsyncComplete( asyncBlock, result, requiredBufferSize );
+    return;
+}
+
+static HRESULT WINAPI x_threading_XAsyncGetResult( IXThreadingImpl* iface, XAsyncBlock* asyncBlock, const PVOID identity, SIZE_T bufferSize, PVOID buffer, SIZE_T* bufferUsed )
+{
+    FIXME( "iface %p stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+
+/* --- XTaskQueue --- */
+
+static HRESULT WINAPI x_threading_XTaskQueueCreate( IXThreadingImpl* iface, XTaskQueueDispatchMode workDispatchMode, XTaskQueueDispatchMode completionDispatchMode, XTaskQueueHandle* queue )
+{
+    TRACE( "iface %p, workDispatchMode %d, completionDispatchMode %d, queue %p.\n", iface, workDispatchMode, completionDispatchMode, queue );
+    return XTaskQueueCreate( workDispatchMode, completionDispatchMode, queue );
+}
+
+static HRESULT WINAPI x_threading_XTaskQueueCreateComposite( IXThreadingImpl* iface, XTaskQueuePortHandle workPort, XTaskQueuePortHandle completionPort, XTaskQueueHandle* queue )
+{
+    TRACE( "iface %p, workPort %p, completionPort %p, queue %p.\n", iface, workPort, completionPort, queue );
+    return XTaskQueueCreateComposite( workPort, completionPort, queue );
+}
+
+static HRESULT WINAPI x_threading_XTaskQueueGetPort( IXThreadingImpl* iface, XTaskQueueHandle queue, XTaskQueuePort port, XTaskQueuePortHandle* portHandle )
+{
+    TRACE( "iface %p, queue %p, port %d, portHandle %p.\n", iface, queue, port, portHandle );
+    return XTaskQueueGetPort( queue, port, portHandle );
+}
+
+static HRESULT WINAPI x_threading_XTaskQueueDuplicateHandle( IXThreadingImpl* iface, XTaskQueueHandle queueHandle, XTaskQueueHandle* duplicatedHandle )
+{
+    TRACE( "iface %p, queueHandle %p, duplicatedHandle %p.\n", iface, queueHandle, duplicatedHandle );
+    return XTaskQueueDuplicateHandle( queueHandle, duplicatedHandle );
+}
+
+static BOOLEAN WINAPI x_threading_XTaskQueueDispatch( IXThreadingImpl* iface, XTaskQueueHandle queue, XTaskQueuePort port, uint32_t timeoutInMs )
+{
+    TRACE( "iface %p, queue %p, port %d, timeoutInMs %d.\n", iface, queue, port, timeoutInMs );
+    return XTaskQueueDispatch( queue, port, timeoutInMs );
+}
+
+static VOID WINAPI x_threading_XTaskQueueCloseHandle( IXThreadingImpl* iface, XTaskQueueHandle queue )
+{
+    TRACE( "iface %p, queue %p.\n", iface, queue );
+    XTaskQueueCloseHandle( queue );
+    /* no-op return */
+}
+
+static HRESULT WINAPI x_threading_XTaskQueueSubmitCallback( IXThreadingImpl* iface, XTaskQueueHandle queue, XTaskQueuePort port, PVOID callbackContext, XTaskQueueCallback* callback )
+{
+    TRACE( "iface %p, queue %p, port %d, callbackContext %p, callback %p.\n", iface, queue, port, callbackContext, callback );
+    return XTaskQueueSubmitDelayedCallback( queue, port, 0, callbackContext, callback );
+}
+
+static HRESULT WINAPI x_threading_XTaskQueueSubmitDelayedCallback( IXThreadingImpl* iface, XTaskQueueHandle queue, XTaskQueuePort port, uint32_t delayMs, PVOID callbackContext, XTaskQueueCallback* callback )
+{
+    TRACE( "iface %p, queue %p, port %d, delayMs %d, callbackContext %p, callback %p.\n", iface, queue, port, delayMs, callbackContext, callback );
+    return XTaskQueueSubmitDelayedCallback( queue, port, delayMs, callbackContext, callback );
+}
+
+static HRESULT WINAPI x_threading_XTaskQueueRegisterWaiter( IXThreadingImpl* iface, XTaskQueueHandle queue, XTaskQueuePort port, HANDLE waitHandle, PVOID callbackContext, XTaskQueueCallback* callback, XTaskQueueRegistrationToken* token )
+{
+    FIXME( "iface %p, queue %p, port %d, waitHandle %p, callbackContext %p, callback %p, token %p stub!\n", iface, queue, port, waitHandle, callbackContext, callback, token );
+    return E_NOTIMPL;
+}
+
+static VOID WINAPI x_threading_XTaskQueueUnregisterWaiter( IXThreadingImpl* iface, XTaskQueueHandle queue, XTaskQueueRegistrationToken token )
+{
+    FIXME( "iface %p, queue %p, token %p stub!\n", iface, queue, &token );
+    /* no-op return */
+}
+
+static HRESULT WINAPI x_threading_XTaskQueueTerminate( IXThreadingImpl* iface, XTaskQueueHandle queue, BOOLEAN wait, PVOID callbackContext, XTaskQueueTerminatedCallback* callback )
+{
+    TRACE( "iface %p, queue %p, wait %d, callbackContext %p, callback %p.\n", iface, queue, wait, callbackContext, callback );
+    return XTaskQueueTerminate( queue, wait, callbackContext, callback );
+}
+
+static HRESULT WINAPI x_threading_XTaskQueueRegisterMonitor( IXThreadingImpl* iface, XTaskQueueHandle queue, PVOID callbackContext, XTaskQueueMonitorCallback* callback, XTaskQueueRegistrationToken* token )
+{
+    TRACE( "iface %p, queue %p, callbackContext %p, callback %p, token %p.\n", iface, queue, callbackContext, callback, token );
+    return XTaskQueueRegisterMonitor( queue, callbackContext, callback, token );
+}
+
+static VOID WINAPI x_threading_XTaskQueueUnregisterMonitor( IXThreadingImpl* iface, XTaskQueueHandle queue, XTaskQueueRegistrationToken token )
+{
+    FIXME( "iface %p, queue %p, token %p stub!\n", iface, queue, &token );
+    /* no-op return */
+}
+
+static BOOLEAN WINAPI x_threading_XTaskQueueGetCurrentProcessTaskQueue( IXThreadingImpl* iface, XTaskQueueHandle* queue )
+{
+    struct x_threading *impl = impl_from_IXThreadingImpl( iface );
+    TRACE( "iface %p, queue %p.\n", iface, queue );
+    if ( impl->currentProcessTaskQueue )
+    {
+        *queue = impl->currentProcessTaskQueue;
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static VOID WINAPI x_threading_XTaskQueueSetCurrentProcessTaskQueue( IXThreadingImpl* iface, XTaskQueueHandle queue )
+{
+    struct x_threading *impl = impl_from_IXThreadingImpl( iface );
+    TRACE( "iface %p, queue %p.\n", iface, queue );
+    impl->currentProcessTaskQueue = queue;
+    /* no-op return */
+}
+
+static HRESULT WINAPI x_threading_XThreadSetTimeSensitive( IXThreadingImpl* iface, BOOLEAN isTimeSensitiveThread )
+{
+    struct x_threading *impl = impl_from_IXThreadingImpl( iface );
+    TRACE( "iface %p, isTimeSensitiveThread %d.\n", iface, isTimeSensitiveThread );
+    impl->isTimeSensitiveThread = isTimeSensitiveThread;
+    return S_OK;
+}
+
+static VOID WINAPI x_threading_XThreadAssertNotTimeSensitive( IXThreadingImpl* iface )
+{
+    struct x_threading *impl = impl_from_IXThreadingImpl( iface );
+    TRACE( "iface %p.\n", iface );
+    if ( impl->isTimeSensitiveThread && IsDebuggerPresent() )
+        DebugBreak();
+    /* no-op return */
+}
+
+static BOOLEAN WINAPI x_threading_XThreadIsTimeSensitive( IXThreadingImpl* iface )
+{
+    struct x_threading *impl = impl_from_IXThreadingImpl( iface );
+    TRACE( "iface %p.\n", iface );
+    return impl->isTimeSensitiveThread;
+}
+
+static const struct IXThreadingImplVtbl x_threading_vtbl =
+{
+    x_threading_QueryInterface,
+    x_threading_AddRef,
+    x_threading_Release,
+    /* IXThreadingImpl methods */
+    x_threading_XAsyncGetStatus,
+    x_threading_XAsyncGetResultSize,
+    x_threading_XAsyncCancel,
+    x_threading_XAsyncRun,
+    x_threading_XAsyncBegin,
+    __PADDING__,
+    x_threading_XAsyncSchedule,
+    x_threading_XAsyncComplete,
+    x_threading_XAsyncGetResult,
+    x_threading_XTaskQueueCreate,
+    x_threading_XTaskQueueCreateComposite,
+    x_threading_XTaskQueueGetPort,
+    x_threading_XTaskQueueDuplicateHandle,
+    x_threading_XTaskQueueDispatch,
+    x_threading_XTaskQueueCloseHandle,
+    x_threading_XTaskQueueSubmitCallback,
+    x_threading_XTaskQueueSubmitDelayedCallback,
+    x_threading_XTaskQueueRegisterWaiter,
+    x_threading_XTaskQueueUnregisterWaiter,
+    x_threading_XTaskQueueTerminate,
+    x_threading_XTaskQueueRegisterMonitor,
+    x_threading_XTaskQueueUnregisterMonitor,
+    x_threading_XTaskQueueGetCurrentProcessTaskQueue,
+    x_threading_XTaskQueueSetCurrentProcessTaskQueue,
+    x_threading_XThreadSetTimeSensitive,
+    __PADDING__,
+    x_threading_XThreadAssertNotTimeSensitive,
+    x_threading_XThreadIsTimeSensitive
+};
+
+static struct x_threading x_threading =
+{
+    {&x_threading_vtbl},
+    NULL,
+    0,
+    0,
+};
+
+IXThreadingImpl *x_threading_impl = &x_threading.IXThreadingImpl_iface;
\ No newline at end of file
diff --git a/dlls/xgameruntime/GDKComponent/System/XThreading.h b/dlls/xgameruntime/GDKComponent/System/XThreading.h
new file mode 100644
index 00000000000..b9237c6fc01
--- /dev/null
+++ b/dlls/xgameruntime/GDKComponent/System/XThreading.h
@@ -0,0 +1,37 @@
+/*
+ * Xbox Game runtime Library
+ *  GDK Component: System API -> XThread, XAsync and XTask
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef XTHREADING_H
+#define XTHREADING_H
+
+#include "../../private.h"
+#include "Threading/XTaskQueue.h"
+#include "Threading/XAsync.h"
+
+struct x_threading
+{
+    IXThreadingImpl IXThreadingImpl_iface;
+    XTaskQueueHandle currentProcessTaskQueue;
+    BOOLEAN isTimeSensitiveThread;
+    LONG ref;
+};
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/Makefile.in b/dlls/xgameruntime/Makefile.in
new file mode 100644
index 00000000000..b00c401eec2
--- /dev/null
+++ b/dlls/xgameruntime/Makefile.in
@@ -0,0 +1,21 @@
+IMPORTS   = user32 advapi32 crypt32 combase winhttp
+MODULE    = xgameruntime.dll
+
+SOURCES = \
+	main.c \
+	provider.idl \
+	\
+	GDKComponent/InitInternalGDKC.c \
+	\
+	GDKComponent/System/XSystem.c \
+	GDKComponent/System/XThreading.c \
+	GDKComponent/System/Threading/XTaskQueue.c \
+	GDKComponent/System/Threading/XAsync.c \
+	GDKComponent/System/Threading/AtomicVector.c \
+	GDKComponent/System/Threading/XOSThreading.c \
+	GDKComponent/System/Threading/ThreadPool.c \
+	GDKComponent/System/XSystemAnalytics.c \
+	GDKComponent/System/XGameRuntimeFeature.c \
+	GDKComponent/System/Networking/HTTPClient.c \
+	GDKComponent/System/Networking/XNetworking.c
+
diff --git a/dlls/xgameruntime/NOTES b/dlls/xgameruntime/NOTES
new file mode 100644
index 00000000000..f5d4ad8228f
--- /dev/null
+++ b/dlls/xgameruntime/NOTES
@@ -0,0 +1,18 @@
+Wine's Microsoft Game Development Kit Implementation
+
+This consists of a library called `xgameruntime.dll`.
+Most GDK games only rely on this library and wouldn't use anything else for GDK API.
+
+Our GDK implementation here does NOT include functionality that's under NDA.
+Fortunately, this does not tend to affect GDK games published for Microsoft Windows, and
+is mostly exclusive to the Microsoft Xbox console.
+
+UNDER NO CIRCUMSTANCES SHOULD YOU ATTEMPT TO IMPLEMENT OR STUB ANY FUNCTIONALITY THAT'S UNDER AN NDA.
+
+These include, and are not limited to:
+
+A) Audio API Reference: https://learn.microsoft.com/en-us/gaming/gdk/docs/reference/audio/gc-reference-audio-toc
+
+B) Developer Kit Only API Reference: https://learn.microsoft.com/en-us/gaming/gdk/docs/reference/devkit/atoc-devkit-reference
+
+C) Graphics API Reference: https://learn.microsoft.com/en-us/gaming/gdk/docs/reference/graphics/gc-reference-graphics-toc
\ No newline at end of file
diff --git a/dlls/xgameruntime/main.c b/dlls/xgameruntime/main.c
new file mode 100644
index 00000000000..f92911ec8c3
--- /dev/null
+++ b/dlls/xgameruntime/main.c
@@ -0,0 +1,229 @@
+/*
+ * Xbox Game runtime Library
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "initguid.h"
+#include "private.h"
+
+#include "GDKComponent/InitInternalGDKC.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(xgameruntime);
+
+static HMODULE xgameruntime;
+static HMODULE xgameruntime_threading;
+
+static VOID LoadOtherRuntime( DWORD *asked )
+{
+    HKEY hKey;
+    LPCSTR subKey = "Software\\Wine\\WineGDK";
+    LPCSTR valueName = "LoadOtherRuntimeAsked";
+    DWORD value;
+    DWORD dataSize = sizeof(DWORD);
+    LONG result;
+
+    *asked = 0;
+
+    result = RegCreateKeyExA(
+        HKEY_LOCAL_MACHINE,
+        subKey,
+        0,
+        NULL,
+        REG_OPTION_NON_VOLATILE,
+        KEY_READ | KEY_WRITE,
+        NULL,
+        &hKey,
+        NULL
+    );
+
+    if (result != ERROR_SUCCESS) {
+        return;
+    }
+
+    // Try to read the value
+    result = RegQueryValueExA(
+        hKey,
+        valueName,
+        NULL,
+        NULL,
+        (LPBYTE)&value,
+        &dataSize
+    );
+
+    if ( result == ERROR_FILE_NOT_FOUND ) 
+    {
+        value = 1;
+
+        result = RegSetValueExA(
+            hKey,
+            valueName,
+            0,
+            REG_DWORD,
+            (const BYTE*)&value,
+            sizeof(DWORD)
+        );
+    } else if ( result == ERROR_SUCCESS ) 
+    {
+        *asked = value;
+
+        value = 1;
+
+        result = RegSetValueExA(
+            hKey,
+            valueName,
+            0,
+            REG_DWORD,
+            (const BYTE*)&value,
+            sizeof(DWORD)
+        );
+    }
+
+    RegCloseKey( hKey );
+    return;
+}
+
+HRESULT WINAPI DllCanUnloadNow(void)
+{
+    return xgameruntime != NULL ? S_FALSE : S_OK;
+}
+
+BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, void *reserved )
+{
+    TRACE("inst %p, reason %lu, reserved %p.\n", hinst, reason, reserved);
+
+    switch (reason)
+    {
+        case DLL_PROCESS_ATTACH:
+            DisableThreadLibraryCalls(hinst);
+            xgameruntime_threading = LoadLibraryA("xgameruntime.dll.threading");
+            break;
+        case DLL_PROCESS_DETACH:
+            if (reserved) break;
+            if (xgameruntime) FreeLibrary(xgameruntime);
+            if (xgameruntime_threading) FreeLibrary(xgameruntime_threading);
+        break;
+    }
+    return TRUE;
+}
+
+typedef HRESULT (WINAPI *InitializeApiImplEx2_ext)( ULONG gdkVer, ULONG gsVer, CHAR mode, INITIALIZE_OPTIONS *options );
+
+HRESULT WINAPI InitializeApiImplEx2( ULONG gdkVer, ULONG gsVer, CHAR mode, INITIALIZE_OPTIONS *options )
+{
+    //  Initialization can be done however we want on our side.
+    // You can choose to return `S_OK` once the full SDK is implemented.
+    //
+    //  There's no documented information about what `INITIALIZE_OPTIONS` is,
+    // and xgameruntime.lib never utilizes this argument anyway.
+    TRACE("gdkVer %ld, gsVer %ld, mode %d, options %p stub!\n", gdkVer, gsVer, mode, options);
+    return GDKC_InitAPI( gdkVer, gsVer, mode, options );
+}
+
+HRESULT WINAPI InitializeApiImplEx( ULONG gdkVer, ULONG gsVer, CHAR mode )
+{
+    TRACE("gdkVer %ld, gsVer %ld, mode %d\n", gdkVer, gsVer, mode);
+    return InitializeApiImplEx2( gdkVer, gsVer, mode, NULL );
+}
+
+HRESULT WINAPI InitializeApiImpl( ULONG gdkVer, ULONG gsVer )
+{
+    TRACE("gdkVer %ld, gsVer %ld\n", gdkVer, gsVer);
+    return InitializeApiImplEx2( gdkVer, gsVer, 0, NULL );
+}
+
+typedef HRESULT (WINAPI *QueryApiImpl_ext)( GUID *runtimeClassId, REFIID interfaceId, void **out );
+
+HRESULT WINAPI QueryApiImpl( const GUID *runtimeClassId, REFIID interfaceId, void **out )
+{
+    // Interfaces returned are COM interfaces and inherit IUnknown*
+    // 
+    //  On MSDN, There's no official documentation on the order of these interfaces and functions.
+    // However, we can hook a dummy `xgameruntime.dll` into test environments and individually query
+    // each class and what signatures they posses. Once we've pass through an empty IUnknown* interface,
+    // we can reconstruct the vtable of each class based on what function gets called.
+    //
+    //  Example: (e349bd1a-fc20-4e40-b99c-4178cc6b409f) corresponds to part of the `ISystem` class and implements
+    // these functions in order:
+    //
+    //  /*** IUnknown methods ***/
+    //  IXSystemImpl_QueryInterface,                    (offset 0)
+    //  IXSystemImpl_AddRef,                            (offset 8)
+    //  IXSystemImpl_Release,                           (offset 16)
+    //  /*** IXSystemImpl methods ***/
+    //  IXSystemImpl_XSystemGetConsoleId                (offset 24)
+    //  IXSystemImpl_XSystemGetXboxLiveSandboxId        (offset 32)
+    //  IXSystemImpl_XSystemGetAppSpecificDeviceId      (offset 40)
+    //  IXSystemImpl_XSystemHandleTrack                 (offset 48)
+    //  IXSystemImpl_XSystemIsHandleValid               (offset 56)
+    //  IXSystemImpl_XSystemAllowFullDownloadBandwidth  (offset 64)
+    //
+
+    QueryApiImpl_ext func = (QueryApiImpl_ext)GetProcAddress( xgameruntime_threading, "QueryApiImpl" );
+    DWORD asked;
+
+    TRACE("runtimeClassId %s, interfaceId %s, out %p\n", debugstr_guid(runtimeClassId), debugstr_guid(interfaceId), out);
+
+    if ( IsEqualGUID( runtimeClassId, &CLSID_XSystemImpl ) )
+    {
+        return IXSystemImpl_QueryInterface( x_system_impl, interfaceId, out );
+    }
+    else if ( IsEqualGUID( runtimeClassId, &CLSID_XGameRuntimeFeatureImpl ) )
+    {
+        return IXGameRuntimeFeatureImpl_QueryInterface( x_game_runtime_feature_impl, interfaceId, out );
+    }
+    else if ( IsEqualGUID( runtimeClassId, &CLSID_XSystemAnalyticsImpl ) )
+    {
+        return IXSystemAnalyticsImpl_QueryInterface( x_system_analytics_impl, interfaceId, out );
+    }
+    else if ( IsEqualGUID( runtimeClassId, &CLSID_XThreadingImpl ) )
+    {
+        /**
+         * For IXThreading, It's much better to use the native library instead.
+         */
+        if ( !func )
+        {
+            LoadOtherRuntime( &asked );
+            if ( !asked )
+            {
+                MessageBoxA( NULL, "The game has requested XThreading\nIt's recommended that you use Microsoft's native binary for this instead.\nTo do so, copy xgameruntime.dll from a Windows machine and place it under the name \"xgameruntime.dll.threading\" within either the game's binaries or within your prefix's system32 folder.\nYou won't be asked this again.", "Attention Required!", MB_ICONEXCLAMATION );
+            }
+            return IXThreadingImpl_QueryInterface( x_threading_impl, interfaceId, out );
+        }
+        return func( runtimeClassId, interfaceId, out );
+    }
+    else if ( IsEqualGUID( runtimeClassId, &CLSID_XNetworkingImpl ) )
+    {
+        return IXNetworkingImpl_QueryInterface( x_networking_impl, interfaceId, out );
+    }
+    
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( runtimeClassId ) );
+    return E_NOTIMPL;
+}
+
+HRESULT WINAPI UninitializeApiImpl( void )
+{
+    TRACE("stub!\n");
+    return E_NOTIMPL;
+}
+
+HRESULT WINAPI XErrorReport( HRESULT status, LPCSTR message )
+{
+    TRACE("stub!\n");
+    return E_NOTIMPL;
+}
+
diff --git a/dlls/xgameruntime/private.h b/dlls/xgameruntime/private.h
new file mode 100644
index 00000000000..2ff793affb3
--- /dev/null
+++ b/dlls/xgameruntime/private.h
@@ -0,0 +1,95 @@
+/*
+ * Xbox Game runtime Library
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_XGAMERUNTIME_PRIVATE_H
+#define __WINE_XGAMERUNTIME_PRIVATE_H
+
+#define COBJMACROS
+#include <stdlib.h>
+#include <windows.h>
+#include <winstring.h>
+#include <roapi.h>
+#include <activation.h>
+
+#include <xgameerr.h>
+
+#include <unknwn.h>
+#include "provider.h"
+#include "wine/debug.h"
+#include "xthread.h"
+#include "xnetwork.h"
+
+#define WIDL_using_Windows_Foundation
+#define WIDL_using_Windows_Foundation_Collections
+#include "windows.foundation.h"
+#define WIDL_using_Windows_Globalization
+#include "windows.globalization.h"
+#define WIDL_using_Windows_System_Profile
+#include "windows.system.profile.h"
+
+// October 2025 Release of GDK
+#define GDKC_VERSION 10002L
+#define GAMING_SERVICES_VERSION 4429L
+
+extern IXSystemImpl *x_system_impl;
+extern IXSystemAnalyticsImpl *x_system_analytics_impl;
+extern IXThreadingImpl *x_threading_impl;
+extern IXGameRuntimeFeatureImpl *x_game_runtime_feature_impl;
+extern IXNetworkingImpl *x_networking_impl;
+
+typedef struct _INITIALIZE_OPTIONS
+{
+    int unused;
+} INITIALIZE_OPTIONS;
+
+// Deference is for other modules to communicate with eachother through the same binary.
+HRESULT WINAPI QueryApiImpl( const GUID *runtimeClassId, REFIID interfaceId, void **out );
+
+// a85c3901-18ae-48c9-b066-d368f4523420
+DEFINE_GUID(IID_IXTaskQueue, 0xa85c3901, 0x18ae, 0x48c9, 0xb0, 0x66, 0xd3, 0x68, 0xf4, 0x52, 0x34, 0x20);
+
+// 7d2c63a1-77fe-46ab-83f0-dd1ffd46b380
+DEFINE_GUID(IID_IXTaskQueuePort, 0x7d2c63a1, 0x77fe, 0x46ab, 0x83, 0xf0, 0xdd, 0x1f, 0xfd, 0x46, 0xb3, 0x80);
+
+// 9c4a0e19-10f9-48d7-a547-72f4d5693dcb
+DEFINE_GUID(IID_IXTaskQueueMonitorCallback, 0x9c4a0e19, 0x10f9, 0x48d7, 0xa5, 0x47, 0x72, 0xf4, 0xd5, 0x69, 0x3d, 0xcb);
+
+// a44c19b4-7782-46e9-bbfb-f99608c9535a
+DEFINE_GUID(IID_IXTaskQueuePortContext, 0xa44c19b4, 0x7782, 0x46e9, 0xbb, 0xfb, 0xf9, 0x96, 0x08, 0xc9, 0x53, 0x5a);
+
+// 137c11ff-1e57-4983-8b7c-b86621430d40
+DEFINE_GUID(IID_IXTaskQueueWaitCallback, 0x137c11ff, 0x1e57, 0x4983, 0x8b, 0x7c, 0xb8, 0x86, 0x21, 0x43, 0x0d, 0x40);
+
+// c0858629-c135-4774-a8a8-ab3e6969aeeb
+DEFINE_GUID(IID_IAtomicVector, 0xc0858629, 0xc135, 0x4774, 0xa8, 0xa8, 0xab, 0x3e, 0x69, 0x69, 0xae, 0xeb);
+
+// 15b68a9c-386b-4364-9211-5dd598e6a019
+DEFINE_GUID(IID_IXWaitTimer, 0x15b68a9c, 0x386b, 0x4364, 0x92, 0x11, 0x5d, 0xd5, 0x98, 0xe6, 0xa0, 0x19);
+
+// 1c7e9426-2b0e-4c37-a57a-df7c165a18af
+DEFINE_GUID(IID_IThreadPool, 0x1c7e9426, 0x2b0e, 0x4c37, 0xa5, 0x7a, 0xdf, 0x7c, 0x16, 0x5a, 0x18, 0xaf);
+
+// b617596e-fcf5-42c8-bba4-5a91909f3411
+DEFINE_GUID(IID_IAsyncState, 0xb617596e, 0xfcf5, 0x42c8, 0xbb, 0xa4, 0x5a, 0x91, 0x90, 0x9f, 0x34, 0x11);
+
+// 93134919-80eb-472b-861c-e6c4871e2762
+DEFINE_GUID(IID_IXAsyncBlockInternalGuard, 0x93134919, 0x80eb, 0x472b, 0x86, 0x1c, 0xe6, 0xc4, 0x87, 0x1e, 0x27, 0x62);
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/provider.idl b/dlls/xgameruntime/provider.idl
new file mode 100644
index 00000000000..52a837fcb89
--- /dev/null
+++ b/dlls/xgameruntime/provider.idl
@@ -0,0 +1,188 @@
+/*
+ * xgameruntime.dll implementation
+ *
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep header
+
+import "propidl.idl";
+
+// --- xgameruntime --- //
+typedef void* XSystemHandle;
+
+typedef enum XSystemHandleType XSystemHandleType;
+typedef enum XSystemHandleCallbackReason XSystemHandleCallbackReason;
+typedef enum XGameRuntimeFeature XGameRuntimeFeature;
+
+typedef struct XVersion XVersion;
+typedef struct XSystemAnalyticsInfo XSystemAnalyticsInfo;
+
+interface IWineAsyncWorkImpl;
+interface IXSystemImpl;
+interface IXSystemAnalyticsImpl;
+interface IXGameRuntimeFeatureImpl;
+
+coclass XSystemImpl;
+coclass XSystemAnalyticsImpl;
+coclass XGameRuntimeFeatureImpl;
+
+enum XSystemHandleType
+{
+    AppCaptureScreenshotStream = 0x00,
+    DisplayTimeoutDeferral     = 0x01,
+    GameSaveContainer          = 0x02,
+    GameSaveProvider           = 0x03,
+    GameSaveUpdate             = 0x04,
+    PackageInstallationMonitor = 0x05,
+    PackageMount               = 0x06,
+    SpeechSynthesizer          = 0x07,
+    SpeechSynthesizerStream    = 0x08,
+    StoreContext               = 0x09,
+    StoreLicense               = 0x0a,
+    StoreProductQuery          = 0x0b,
+    TaskQueue                  = 0x0c,
+    User                       = 0x0d,
+    UserSignOutDeferral        = 0x0e,
+    GameUiTextEntry            = 0x0f
+};
+
+enum XGameRuntimeFeature
+{  
+    XAccessibility             = 0,  
+    XAppCapture                = 1,  
+    XAsync                     = 2,  
+    XAsyncProvider             = 3,  
+    XDisplay                   = 4,  
+    XGame                      = 5,  
+    XGameInvite                = 6,  
+    XGameSave                  = 7,  
+    XGameUI                    = 8,  
+    XLauncher                  = 9,  
+    XNetworking                = 10,  
+    XPackage                   = 11,  
+    XPersistentLocalStorage    = 12,  
+    XSpeechSynthesizer         = 13,  
+    XStore                     = 14,  
+    XSystem                    = 15,  
+    XTaskQueue                 = 16,  
+    XThread                    = 17,  
+    XUser                      = 18,  
+    XError                     = 19,  
+    XGameEvent                 = 20, 
+    XGameStreaming             = 21, 
+};
+
+enum XSystemHandleCallbackReason
+{
+    Created     = 0x00,
+    Destroyed   = 0x01
+};
+
+struct XVersion {  
+    union
+    {
+        struct
+        {
+            UINT16 major;  
+            UINT16 minor;  
+            UINT16 build;  
+            UINT16 revision;
+        };
+        UINT64 Value;
+    };
+};
+
+struct XSystemAnalyticsInfo
+{
+    XVersion osVersion;  
+    XVersion hostingOsVersion;  
+    CHAR family[64];  
+    CHAR form[64];
+};
+
+[
+    object,
+    uuid(7664288b-54e9-45f9-af0b-b4ad047fa194)
+]
+interface IWineAsyncWorkImpl : IUnknown
+{
+
+}
+
+[
+    object,
+    uuid(dadc2895-34b0-4ef5-a83e-45114d629b80)
+]
+interface IXSystemImpl : IUnknown
+{
+    HRESULT XSystemGetConsoleId( [in] INT32 consoleIdSize, [out, size_is(consoleIdSize)] LPSTR consoleId, [out] SIZE_T *consoleIdUsed );
+    HRESULT XSystemGetXboxLiveSandboxId( [in] INT32 sandboxIdSize, [out, size_is(sandboxIdSize)] LPSTR sandboxId, [out] SIZE_T *sandboxIdUsed );
+    HRESULT XSystemGetAppSpecificDeviceId( [in] INT32 appSpecificDeviceIdSize, [out, size_is(appSpecificDeviceIdSize)] LPSTR appSpecificDeviceId, [out] SIZE_T *appSpecificDeviceIdUsed );
+    /*
+     *  BUG: You cannot have function pointer parameters within COM declared interfaces,
+     * yet Microsoft, in their infinite wisdom, declared function pointers within the 2 
+     * functions below, within a COM interface. Unfortunately no workaround can be found 
+     * unless we transition to a WinRT codebase.
+     */
+    HRESULT XSystemHandleTrack( /* [in] XSystemHandleCallback callback, [in] void *context */ );
+    BOOLEAN XSystemIsHandleValid( /* [in] XSystemHandleCallback callback */ );
+    HRESULT XSystemAllowFullDownloadBandwidth( [in] boolean enable );
+}
+
+[
+    object,
+    uuid(b884675d-b738-4a9c-815d-9a9a1e0c6c9b)
+]
+interface IXSystemAnalyticsImpl : IUnknown
+{
+    XSystemAnalyticsInfo XSystemGetAnalyticsInfo();
+}
+
+[
+    object,
+    uuid(8836fe87-edb9-4fe3-8dad-05f0d2cd5b40)
+]
+interface IXGameRuntimeFeatureImpl : IUnknown
+{
+    BOOLEAN XGameRuntimeIsFeatureAvailable( [in] XGameRuntimeFeature feature );
+}
+
+[
+    uuid(e349bd1a-fc20-4e40-b99c-4178cc6b409f)
+]
+coclass XSystemImpl
+{
+    [default] interface IXSystemImpl;
+}
+
+[
+    uuid(b884675d-b738-4a9c-815d-9a9a1e0c6c9b)
+]
+coclass XSystemAnalyticsImpl
+{
+    [default] interface IXSystemAnalyticsImpl;
+}
+
+[
+    uuid(8836fe87-edb9-4fe3-8dad-05f0d2cd5b40)
+]
+coclass XGameRuntimeFeatureImpl
+{
+    [default] interface IXGameRuntimeFeatureImpl;
+}
+
diff --git a/dlls/xgameruntime/tests/Makefile.in b/dlls/xgameruntime/tests/Makefile.in
new file mode 100644
index 00000000000..578d9b6c18e
--- /dev/null
+++ b/dlls/xgameruntime/tests/Makefile.in
@@ -0,0 +1,6 @@
+TESTDLL = xgameruntime.dll
+IMPORTS = user32 advapi32 combase
+
+SOURCES = \
+    provider.idl \
+	xgameruntime.c
diff --git a/dlls/xgameruntime/tests/provider.idl b/dlls/xgameruntime/tests/provider.idl
new file mode 100644
index 00000000000..046c60d372c
--- /dev/null
+++ b/dlls/xgameruntime/tests/provider.idl
@@ -0,0 +1,192 @@
+/*
+ * xgameruntime.dll implementation
+ *
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep header
+
+import "propidl.idl";
+
+cpp_quote("#include <xasync.h>")
+
+// --- xgameruntime --- //
+typedef void* XSystemHandle;
+
+typedef enum XSystemHandleType XSystemHandleType;
+typedef enum XSystemHandleCallbackReason XSystemHandleCallbackReason;
+typedef enum XGameRuntimeFeature XGameRuntimeFeature;
+
+typedef struct XVersion XVersion;
+typedef struct XSystemAnalyticsInfo XSystemAnalyticsInfo;
+
+/* type-pruning version of XAsyncCompletionRoutine */
+
+interface IWineAsyncWorkImpl;
+interface IXSystemImpl;
+interface IXSystemAnalyticsImpl;
+interface IXGameRuntimeFeatureImpl;
+
+coclass XSystemImpl;
+coclass XSystemAnalyticsImpl;
+coclass XGameRuntimeFeatureImpl;
+
+enum XSystemHandleType
+{
+    AppCaptureScreenshotStream = 0x00,
+    DisplayTimeoutDeferral     = 0x01,
+    GameSaveContainer          = 0x02,
+    GameSaveProvider           = 0x03,
+    GameSaveUpdate             = 0x04,
+    PackageInstallationMonitor = 0x05,
+    PackageMount               = 0x06,
+    SpeechSynthesizer          = 0x07,
+    SpeechSynthesizerStream    = 0x08,
+    StoreContext               = 0x09,
+    StoreLicense               = 0x0a,
+    StoreProductQuery          = 0x0b,
+    TaskQueue                  = 0x0c,
+    User                       = 0x0d,
+    UserSignOutDeferral        = 0x0e,
+    GameUiTextEntry            = 0x0f
+};
+
+enum XGameRuntimeFeature
+{  
+    XAccessibility             = 0,  
+    XAppCapture                = 1,  
+    XAsync                     = 2,  
+    XAsyncProvider             = 3,  
+    XDisplay                   = 4,  
+    XGame                      = 5,  
+    XGameInvite                = 6,  
+    XGameSave                  = 7,  
+    XGameUI                    = 8,  
+    XLauncher                  = 9,  
+    XNetworking                = 10,  
+    XPackage                   = 11,  
+    XPersistentLocalStorage    = 12,  
+    XSpeechSynthesizer         = 13,  
+    XStore                     = 14,  
+    XSystem                    = 15,  
+    XTaskQueue                 = 16,  
+    XThread                    = 17,  
+    XUser                      = 18,  
+    XError                     = 19,  
+    XGameEvent                 = 20, 
+    XGameStreaming             = 21, 
+};
+
+enum XSystemHandleCallbackReason
+{
+    Created     = 0x00,
+    Destroyed   = 0x01
+};
+
+struct XVersion {  
+    union
+    {
+        struct
+        {
+            UINT16 major;  
+            UINT16 minor;  
+            UINT16 build;  
+            UINT16 revision;
+        };
+        UINT64 Value;
+    };
+};
+
+struct XSystemAnalyticsInfo
+{
+    XVersion osVersion;  
+    XVersion hostingOsVersion;  
+    CHAR family[64];  
+    CHAR form[64];
+};
+
+[
+    object,
+    uuid(7664288b-54e9-45f9-af0b-b4ad047fa194)
+]
+interface IWineAsyncWorkImpl : IUnknown
+{
+
+}
+
+[
+    object,
+    uuid(dadc2895-34b0-4ef5-a83e-45114d629b80)
+]
+interface IXSystemImpl : IUnknown
+{
+    HRESULT XSystemGetConsoleId( [in] INT32 consoleIdSize, [out, size_is(consoleIdSize)] LPSTR consoleId, [out] SIZE_T *consoleIdUsed );
+    HRESULT XSystemGetXboxLiveSandboxId( [in] INT32 sandboxIdSize, [out, size_is(sandboxIdSize)] LPSTR sandboxId, [out] SIZE_T *sandboxIdUsed );
+    HRESULT XSystemGetAppSpecificDeviceId( [in] INT32 appSpecificDeviceIdSize, [out, size_is(appSpecificDeviceIdSize)] LPSTR appSpecificDeviceId, [out] SIZE_T *appSpecificDeviceIdUsed );
+    /*
+     *  BUG: You cannot have function pointer parameters within COM declared interfaces,
+     * yet Microsoft, in their infinite wisdom, declared function pointers within the 2 
+     * functions below, within a COM interface. Unfortunately no workaround can be found 
+     * unless we transition to a WinRT codebase.
+     */
+    HRESULT XSystemHandleTrack( /* [in] XSystemHandleCallback callback, [in] void *context */ );
+    BOOLEAN XSystemIsHandleValid( /* [in] XSystemHandleCallback callback */ );
+    HRESULT XSystemAllowFullDownloadBandwidth( [in] boolean enable );
+}
+
+[
+    object,
+    uuid(b884675d-b738-4a9c-815d-9a9a1e0c6c9b)
+]
+interface IXSystemAnalyticsImpl : IUnknown
+{
+    XSystemAnalyticsInfo XSystemGetAnalyticsInfo();
+}
+
+[
+    object,
+    uuid(8836fe87-edb9-4fe3-8dad-05f0d2cd5b40)
+]
+interface IXGameRuntimeFeatureImpl : IUnknown
+{
+    BOOLEAN XGameRuntimeIsFeatureAvailable( [in] XGameRuntimeFeature feature );
+}
+
+[
+    uuid(e349bd1a-fc20-4e40-b99c-4178cc6b409f)
+]
+coclass XSystemImpl
+{
+    [default] interface IXSystemImpl;
+}
+
+[
+    uuid(b884675d-b738-4a9c-815d-9a9a1e0c6c9b)
+]
+coclass XSystemAnalyticsImpl
+{
+    [default] interface IXSystemAnalyticsImpl;
+}
+
+[
+    uuid(8836fe87-edb9-4fe3-8dad-05f0d2cd5b40)
+]
+coclass XGameRuntimeFeatureImpl
+{
+    [default] interface IXGameRuntimeFeatureImpl;
+}
+
diff --git a/dlls/xgameruntime/tests/xgameruntime.c b/dlls/xgameruntime/tests/xgameruntime.c
new file mode 100644
index 00000000000..2359364b777
--- /dev/null
+++ b/dlls/xgameruntime/tests/xgameruntime.c
@@ -0,0 +1,376 @@
+/*
+ * Xbox Game runtime Library Tests
+ * 
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdlib.h>
+#include <stdarg.h>
+#define COBJMACROS
+#include <initguid.h>
+#include <windef.h>
+#include <winbase.h>
+#include <winternl.h>
+#include <roapi.h>
+#include <activation.h>
+#include <unknwn.h>
+#include <xgameerr.h>
+
+#include "provider.h"
+#include "wine/test.h"
+#include "xthread.h"
+
+#define WIDL_using_Windows_Foundation
+#define WIDL_using_Windows_Foundation_Collections
+#include "windows.foundation.h"
+#define WIDL_using_Windows_Globalization
+#include "windows.globalization.h"
+#define WIDL_using_Windows_System_Profile
+#include "windows.system.profile.h"
+
+// April 2025 Release of GDK
+#define GDKC_VERSION 10001L
+#define GAMING_SERVICES_VERSION 3181L
+
+static HMODULE xgameruntime = NULL;
+
+typedef HRESULT (*InitializeApiImpl)( ULONG gdkVer, ULONG gsVer );
+typedef HRESULT (*QueryApiImpl)( const GUID *runtimeClassId, REFIID interfaceId, void **out );
+
+static InitializeApiImpl InitializeApiImpl_fun = NULL;
+static QueryApiImpl QueryApiImpl_fun = NULL;
+
+static const SIZE_T XSystemConsoleIdBytes = 39;
+static const SIZE_T XSystemXboxLiveSandboxIdMaxBytes = 16;
+static const SIZE_T XSystemXboxLiveSandboxIdBytes = 7;
+static const SIZE_T XSystemAppSpecificDeviceIdBytes = 45;
+
+static LPSTR testData = NULL;
+
+#define check_interface(obj, iid, supported) _check_interface(__LINE__, obj, iid, supported)
+static void _check_interface(unsigned int line, void *obj, const IID *iid, BOOL supported)
+{
+    IUnknown *iface = obj, *unknown;
+    HRESULT hr;
+
+    hr = IUnknown_QueryInterface(iface, iid, (void **)&unknown);
+    ok_(__FILE__, line)(hr == S_OK || (!supported && hr == E_NOINTERFACE), "Got unexpected hr %#lx.\n", hr);
+    if (SUCCEEDED(hr))
+        IUnknown_Release(unknown);
+}
+
+static inline HRESULT CALLBACK XAsyncProvider_testCallback( XAsyncOp op, const XAsyncProviderData* data )
+{
+    IXThreadingImpl *xthreading;
+    HRESULT hr;
+    SIZE_T testDataSize = 7;
+
+    hr = QueryApiImpl_fun( &CLSID_XThreadingImpl, &IID_IXThreadingImpl, (void **)&xthreading );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    switch ( op )
+    {
+        case Begin:
+            trace( "Begin invoked\n" );
+            IXThreadingImpl_XAsyncComplete( xthreading, data->async, S_OK, 0 );
+            return S_OK;
+
+        case DoWork:
+            trace( "DoWork invoked\n" );
+            IXThreadingImpl_XAsyncComplete( xthreading, data->async, E_PENDING, 0 );
+            testData = (LPSTR)malloc( testDataSize * sizeof( CHAR ) );
+            strcpy( testData, "foobar" );
+            IXThreadingImpl_XAsyncComplete( xthreading, data->async, S_OK, testDataSize );
+            return S_OK;
+
+        case GetResult:
+            trace( "GetResult invoked\n" );
+            memcpy( data->buffer, (void *)testData, testDataSize);
+            return S_OK;
+
+        case Cancel:
+            trace( "Cancel invoked\n" );
+            IXThreadingImpl_XAsyncComplete( xthreading, data->async, E_ABORT, 0 );
+            return S_OK;
+
+        case Cleanup:
+            trace( "Cleanup invoked\n" );
+            free( testData );
+            return S_OK;
+    }
+
+    return S_OK;
+}
+
+/**
+ *  Testing xgameruntime.dll is a bit difficult to do because the core 
+ * library (xgameruntime.lib) is responsible for most of the interfaces 
+ * used by applications, and applications don't interact with this library
+ * directly themselves.
+ * 
+ *  These test cases were curated to test whatever's in the library itself 
+ * at this moment.
+ */
+
+static void test_GDKComponentInit(void)
+{
+    HRESULT hr;
+    LPCSTR xgameruntime_libname = "xgameruntime.dll";
+
+    xgameruntime = LoadLibraryA( xgameruntime_libname );
+    ok( xgameruntime != NULL, "xgameruntime.dll failed to load! error code: %lu\n", GetLastError() );
+
+    InitializeApiImpl_fun = (InitializeApiImpl)GetProcAddress( xgameruntime, "InitializeApiImpl" );
+    ok( InitializeApiImpl_fun != NULL, "couldn't locate function InitializeApiImpl within %p! error code: %lu\n", xgameruntime, GetLastError() );
+
+    hr = InitializeApiImpl_fun( GDKC_VERSION, GAMING_SERVICES_VERSION );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    QueryApiImpl_fun = (QueryApiImpl)GetProcAddress( xgameruntime, "QueryApiImpl" );
+    ok( QueryApiImpl_fun != NULL, "couldn't locate function QueryApiImpl within %p! error code: %lu\n", xgameruntime, GetLastError() );
+}
+
+static void test_XSystem(void)
+{
+    IXSystemImpl *xsystem;
+    BOOLEAN validHandle;
+    HRESULT hr;
+    SIZE_T consoleIdUsed;
+    SIZE_T sandboxIdUsed;
+    LPSTR consoleId;
+    LPSTR sandboxId;
+
+    hr = QueryApiImpl_fun( &CLSID_XSystemImpl, &IID_IXSystemImpl, (void **)&xsystem );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    check_interface( xsystem, &IID_IUnknown, TRUE );
+    check_interface( xsystem, &IID_IXSystemImpl, TRUE );
+
+    /**
+     * xgameruntime.lib::XSystemGetConsoleId
+     */
+    consoleId = (LPSTR)malloc( XSystemConsoleIdBytes * sizeof( CHAR ) );
+    
+    hr = IXSystemImpl_XSystemGetConsoleId( xsystem, XSystemConsoleIdBytes, consoleId, &consoleIdUsed );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+    ok( strcmp( consoleId, "00000000.00000000.00000000.00000000.00" ) == 0, "unexpected consoleId. got %s.\n", debugstr_a( consoleId ) );
+    ok( consoleIdUsed == XSystemConsoleIdBytes, "unexpected consoleIdUsed. got %lld.\n", consoleIdUsed );
+
+    /**
+     * xgameruntime.lib::XSystemGetXboxLiveSandboxId
+     */
+    sandboxId = (LPSTR)malloc( XSystemXboxLiveSandboxIdMaxBytes * sizeof( CHAR ) );
+    
+    hr = IXSystemImpl_XSystemGetXboxLiveSandboxId( xsystem, XSystemXboxLiveSandboxIdMaxBytes, sandboxId, &sandboxIdUsed );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+    ok( strcmp( sandboxId, "RETAIL" ) == 0, "unexpected sandboxId. got %s.\n", debugstr_a( sandboxId ) );
+    ok( sandboxIdUsed == XSystemXboxLiveSandboxIdBytes, "unexpected sandboxIdUsed. got %lld.\n", sandboxIdUsed );
+
+    /**
+     * xgameruntime.lib::XSystemGetAppSpecificDeviceId
+     */
+    hr = IXSystemImpl_XSystemGetAppSpecificDeviceId( xsystem, XSystemAppSpecificDeviceIdBytes, NULL, NULL );
+    todo_wine ok( hr == S_OK, "got error %#lx.\n", hr );
+
+    /**
+     * xgameruntime.lib::XSystemHandleTrack
+     */
+    hr = IXSystemImpl_XSystemHandleTrack( xsystem );
+    todo_wine ok( hr == S_OK, "got error %#lx.\n", hr );
+
+    /**
+     * xgameruntime.lib::XSystemIsHandleValid
+     */
+    validHandle = IXSystemImpl_XSystemIsHandleValid( xsystem );
+    ok( validHandle, "got validHandle %d\n", validHandle );
+
+    /**
+     * xgameruntime.lib::XSystemAllowFullDownloadBandwidth
+     */
+    hr = IXSystemImpl_XSystemAllowFullDownloadBandwidth( xsystem, TRUE );
+    todo_wine ok( hr == S_OK, "got error %#lx.\n", hr );
+
+    IXSystemImpl_Release( xsystem );
+    free( consoleId );
+    free( sandboxId );
+}
+
+static void test_XSystemAnalytics(void)
+{
+    IXSystemAnalyticsImpl *xsystem_analytics;
+    XSystemAnalyticsInfo analyticsInfo;
+    RTL_OSVERSIONINFOEXW version_info = {0};
+    HRESULT hr;
+    DWORD ubr;
+    DWORD ubr_size = sizeof(ubr);
+    HKEY ubr_registry_key;
+
+    hr = QueryApiImpl_fun( &CLSID_XSystemAnalyticsImpl, &IID_IXSystemAnalyticsImpl, (void **)&xsystem_analytics );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    check_interface( xsystem_analytics, &IID_IUnknown, TRUE );
+    check_interface( xsystem_analytics, &IID_IXSystemAnalyticsImpl, TRUE );
+
+    /**
+     * xgameruntime.lib::XSystemGetAnalyticsInfo
+     */
+    version_info.dwOSVersionInfoSize = sizeof( version_info );
+    ok( RtlGetVersion( &version_info ) == 0, "RtlGetVersion failed.\n" );
+    ok( SUCCEEDED( RegOpenKeyExW( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", 0, KEY_READ | KEY_WOW64_64KEY, &ubr_registry_key ) ),
+        "RegOpenKeyExW failed with code %ld.\n", GetLastError() );
+    ok( SUCCEEDED( RegQueryValueExW( ubr_registry_key, L"UBR", NULL, NULL, (LPBYTE)&ubr, &ubr_size ) ),
+        "RegQueryValueExW failed with code %ld.\n", GetLastError() );
+    RegCloseKey( ubr_registry_key );
+    ubr = (ubr & 0xFFFF); // <-- lower bits of UBR is the actual update revision.
+
+
+    analyticsInfo = IXSystemAnalyticsImpl_XSystemGetAnalyticsInfo( xsystem_analytics );
+    ok( analyticsInfo.osVersion.major == (UINT16)version_info.dwMajorVersion, 
+        "major version %d differs from %d.\n", analyticsInfo.osVersion.major, (UINT16)version_info.dwMajorVersion);
+    ok( analyticsInfo.osVersion.minor == (UINT16)version_info.dwMinorVersion, 
+        "minor version %d differs from %d.\n", analyticsInfo.osVersion.minor, (UINT16)version_info.dwMinorVersion);
+    ok( analyticsInfo.osVersion.build == (UINT16)version_info.dwBuildNumber, 
+        "build number %d differs from %d.\n", analyticsInfo.osVersion.build, (UINT16)version_info.dwBuildNumber);
+    ok( analyticsInfo.osVersion.revision == (UINT16)ubr, 
+        "update revision %d differs from %d.\n", analyticsInfo.hostingOsVersion.revision, (UINT16)ubr);
+    ok( analyticsInfo.hostingOsVersion.major == (UINT16)version_info.dwMajorVersion, 
+        "host major version %d differs from %d.\n", analyticsInfo.hostingOsVersion.major, (UINT16)version_info.dwMajorVersion);
+    ok( analyticsInfo.hostingOsVersion.minor == (UINT16)version_info.dwMinorVersion, 
+        "host minor version %d differs from %d.\n", analyticsInfo.hostingOsVersion.minor, (UINT16)version_info.dwMinorVersion);
+    ok( analyticsInfo.hostingOsVersion.build == (UINT16)version_info.dwBuildNumber, 
+        "host build number %d differs from %d.\n", analyticsInfo.hostingOsVersion.build, (UINT16)version_info.dwBuildNumber);
+    ok( analyticsInfo.hostingOsVersion.revision == (UINT16)ubr, 
+        "host update revision %d differs from %d.\n", analyticsInfo.osVersion.revision, (UINT16)ubr);
+    ok( strcmp( analyticsInfo.family, "Windows" ) == 0, "unexpected family %s.\n", debugstr_a( analyticsInfo.family ) );
+    ok( strcmp( analyticsInfo.form, "Desktop" ) == 0, "unexpected form %s.\n", debugstr_a( analyticsInfo.form ) );
+
+    IXSystemAnalyticsImpl_Release( xsystem_analytics );
+}
+
+static void test_XGameRuntimeFeature(void)
+{
+    IXGameRuntimeFeatureImpl *xgame_runtime_feature;
+    HRESULT hr;
+    BOOLEAN isAvailable;
+
+    hr = QueryApiImpl_fun( &CLSID_XGameRuntimeFeatureImpl, &IID_IXGameRuntimeFeatureImpl, (void **)&xgame_runtime_feature );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    check_interface( xgame_runtime_feature, &IID_IUnknown, TRUE );
+    check_interface( xgame_runtime_feature, &IID_IXGameRuntimeFeatureImpl, TRUE );
+
+    /**
+     * xgameruntime.lib::XGameRuntimeIsFeatureAvailable
+     */
+    isAvailable = IXGameRuntimeFeatureImpl_XGameRuntimeIsFeatureAvailable( xgame_runtime_feature, XGame );
+    ok( isAvailable, "got unexpected isAvailable %d.\n", isAvailable );
+
+    IXGameRuntimeFeatureImpl_Release( xgame_runtime_feature );
+}
+
+static void test_XThreading(void)
+{
+    IXThreadingImpl *xthreading;
+    HRESULT hr;
+    SIZE_T receivedBufferSize;
+    SIZE_T bufferUsed;
+    LPSTR receivedBuffer;
+
+    hr = QueryApiImpl_fun( &CLSID_XThreadingImpl, &IID_IXThreadingImpl, (void **)&xthreading );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    check_interface( xthreading, &IID_IUnknown, TRUE );
+    check_interface( xthreading, &IID_IXThreadingImpl, TRUE );
+
+    /**
+     * Microsoft is very vague about how XAsync is used in applications.
+     * This is the best implementation I can get for now.
+     */
+
+    // --- XAsync --- //
+    {
+        XAsyncBlock currentBlock;
+        XTaskQueueHandle taskHandle;
+
+        currentBlock.callback = NULL;
+        currentBlock.queue = NULL;
+
+        hr = IXThreadingImpl_XTaskQueueCreate( xthreading, Manual, Manual, &taskHandle );
+        ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+        IXThreadingImpl_XTaskQueueSetCurrentProcessTaskQueue( xthreading, taskHandle );
+
+        trace( "BEFORE IS %p\n", currentBlock.queue );
+
+        /**
+         * xgameruntime.lib::XAsyncBegin
+         */
+        hr = IXThreadingImpl_XAsyncBegin( xthreading, &currentBlock, NULL, NULL, NULL, XAsyncProvider_testCallback );
+        ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+        trace( "AFTER IS %p\n", currentBlock.queue );
+        trace( "taskHandle IS %p\n", taskHandle );
+
+        /**
+         * xgameruntime.lib::XAsyncSchedule
+         */
+        //hr = IXThreadingImpl_XAsyncSchedule( xthreading, &currentBlock, 1000 );
+        //ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+        hr = IXThreadingImpl_XTaskQueueDispatch( xthreading, taskHandle, 0, 1000 );
+        ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+        /**
+         * xgameruntime.lib::XAsyncGetStatus
+         */
+        hr = IXThreadingImpl_XAsyncGetStatus( xthreading, &currentBlock, TRUE );
+        ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+        /**
+         * xgameruntime.lib::XAsyncGetResultSize
+         */
+        hr = IXThreadingImpl_XAsyncGetResultSize( xthreading, &currentBlock, &receivedBufferSize );
+        ok( hr == S_OK, "got hr %#lx.\n", hr );
+        ok( receivedBufferSize == 7, "unexpected receivedBufferSize %lld.\b", receivedBufferSize );
+
+        receivedBuffer = (LPSTR)malloc( receivedBufferSize );
+
+        /**
+         * xgameruntime.lib::XAsyncGetResult
+         */
+        hr = IXThreadingImpl_XAsyncGetResult( xthreading, &currentBlock, NULL, receivedBufferSize, (PVOID)receivedBuffer, &bufferUsed );
+        ok( hr == S_OK, "got hr %#lx.\n", hr );
+        ok( bufferUsed == 7, "unexpected bufferUsed %lld.\b", bufferUsed );
+        ok( strcmp( receivedBuffer, "foobar" ) == 0, "unexpected receivedBuffer %s.\n", debugstr_a( receivedBuffer ) );
+    }
+}
+
+START_TEST(xgameruntime)
+{
+    HRESULT hr;
+
+    hr = RoInitialize(RO_INIT_MULTITHREADED);
+    ok(hr == S_OK, "RoInitialize failed, hr %#lx\n", hr);
+
+    test_GDKComponentInit();
+    test_XSystem();
+    test_XSystemAnalytics();
+    test_XGameRuntimeFeature();
+    test_XThreading();
+
+    RoUninitialize();
+}
\ No newline at end of file
diff --git a/dlls/xgameruntime/tests/xthread.h b/dlls/xgameruntime/tests/xthread.h
new file mode 100644
index 00000000000..b4799a5701b
--- /dev/null
+++ b/dlls/xgameruntime/tests/xthread.h
@@ -0,0 +1,199 @@
+/*
+ * xgameruntime.dll implementation
+ *
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __XTHREAD_H
+#define __XTHREAD_H
+
+#include <xasyncprovider.h>
+
+typedef struct IXThreadingImpl IXThreadingImpl;
+
+typedef struct IXThreadingImplVtbl {
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(IXThreadingImpl* This, REFIID riid, void** ppvObject);
+    ULONG   (STDMETHODCALLTYPE *AddRef)(IXThreadingImpl* This);
+    ULONG   (STDMETHODCALLTYPE *Release)(IXThreadingImpl* This);
+    
+    HRESULT (STDMETHODCALLTYPE *XAsyncGetStatus)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, boolean wait);
+    HRESULT (STDMETHODCALLTYPE *XAsyncGetResultSize)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, SIZE_T *bufferSize);
+    VOID    (STDMETHODCALLTYPE *XAsyncCancel)(IXThreadingImpl* This, XAsyncBlock* asyncBlock);
+    HRESULT (STDMETHODCALLTYPE *XAsyncRun)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, XAsyncWork* work);
+    HRESULT (STDMETHODCALLTYPE *XAsyncBegin)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, PVOID context, const PVOID identity, LPCSTR identityName, XAsyncProviderCallback* provider);
+    HRESULT (STDMETHODCALLTYPE *__PADDING__)(IXThreadingImpl* This);
+    HRESULT (STDMETHODCALLTYPE *XAsyncSchedule)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, UINT32 delayInMs);
+    VOID    (STDMETHODCALLTYPE *XAsyncComplete)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, HRESULT result, SIZE_T requiredBufferSize);
+    HRESULT (STDMETHODCALLTYPE *XAsyncGetResult)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, const PVOID identity, SIZE_T bufferSize, PVOID buffer, SIZE_T* bufferUsed);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueCreate)(IXThreadingImpl* This, XTaskQueueDispatchMode workDispatchMode, XTaskQueueDispatchMode completionDispatchMode, XTaskQueueHandle* queue);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueCreateComposite)(IXThreadingImpl* This, XTaskQueuePortHandle workPort, XTaskQueuePortHandle completionPort, XTaskQueueHandle* queue);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueGetPort)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueuePort port, XTaskQueuePortHandle* portHandle);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueDuplicateHandle)(IXThreadingImpl* This, XTaskQueueHandle queueHandle, XTaskQueueHandle* duplicatedHandle);
+    BOOLEAN (STDMETHODCALLTYPE *XTaskQueueDispatch)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueuePort port, uint32_t timeoutInMs);
+    VOID    (STDMETHODCALLTYPE *XTaskQueueCloseHandle)(IXThreadingImpl* This, XTaskQueueHandle queue);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueSubmitCallback)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueuePort port, PVOID callbackContext, XTaskQueueCallback* callback);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueSubmitDelayedCallback)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueuePort port, uint32_t delayMs, PVOID callbackContext, XTaskQueueCallback* callback);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueRegisterWaiter)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueuePort port, HANDLE waitHandle, PVOID callbackContext, XTaskQueueCallback* callback, XTaskQueueRegistrationToken* token);
+    VOID    (STDMETHODCALLTYPE *XTaskQueueUnregisterWaiter)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueueRegistrationToken token);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueTerminate)(IXThreadingImpl* This, XTaskQueueHandle queue, BOOLEAN wait, PVOID callbackContext, XTaskQueueTerminatedCallback* callback);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueRegisterMonitor)(IXThreadingImpl* This, XTaskQueueHandle queue, PVOID callbackContext, XTaskQueueMonitorCallback* callback, XTaskQueueRegistrationToken* token);
+    VOID    (STDMETHODCALLTYPE *XTaskQueueUnregisterMonitor)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueueRegistrationToken token);
+    BOOLEAN (STDMETHODCALLTYPE *XTaskQueueGetCurrentProcessTaskQueue)(IXThreadingImpl* This, XTaskQueueHandle* queue);
+    VOID    (STDMETHODCALLTYPE *XTaskQueueSetCurrentProcessTaskQueue)(IXThreadingImpl* This, XTaskQueueHandle queue);
+    HRESULT (STDMETHODCALLTYPE *XThreadSetTimeSensitive)(IXThreadingImpl* This, BOOLEAN isTimeSensitiveThread);
+    HRESULT (STDMETHODCALLTYPE *__PADDING_2__)(IXThreadingImpl* This);
+    VOID    (STDMETHODCALLTYPE *XThreadAssertNotTimeSensitive)(IXThreadingImpl* This);
+    BOOLEAN (STDMETHODCALLTYPE *XThreadIsTimeSensitive)(IXThreadingImpl* This);
+} IXThreadingImplVtbl;
+
+struct IXThreadingImpl {
+    const IXThreadingImplVtbl* lpVtbl;
+};
+
+#ifdef COBJMACROS
+#ifndef WIDL_C_INLINE_WRAPPERS
+/*** IUnknown methods ***/
+#define IXThreadingImpl_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
+#define IXThreadingImpl_AddRef(This) (This)->lpVtbl->AddRef(This)
+#define IXThreadingImpl_Release(This) (This)->lpVtbl->Release(This)
+/*** IXThreadingImpl methods ***/
+#define IXThreadingImpl_XAsyncGetStatus(This,asyncBlock,wait) (This)->lpVtbl->XAsyncGetStatus(This,asyncBlock,wait)
+#define IXThreadingImpl_XAsyncGetResultSize(This,asyncBlock,bufferSize) (This)->lpVtbl->XAsyncGetResultSize(This,asyncBlock,bufferSize)
+#define IXThreadingImpl_XAsyncCancel(This,asyncBlock) (This)->lpVtbl->XAsyncCancel(This,asyncBlock)
+#define IXThreadingImpl_XAsyncRun(This,asyncBlock,work) (This)->lpVtbl->XAsyncRun(This,asyncBlock,work)
+#define IXThreadingImpl_XAsyncBegin(This,asyncBlock,context,identity,identityName,provider) (This)->lpVtbl->XAsyncBegin(This,asyncBlock,context,identity,identityName,provider)
+#define IXThreadingImpl_XAsyncSchedule(This,asyncBlock,delayInMs) (This)->lpVtbl->XAsyncSchedule(This,asyncBlock,delayInMs)
+#define IXThreadingImpl_XAsyncComplete(This,asyncBlock,result,requiredBufferSize) (This)->lpVtbl->XAsyncComplete(This,asyncBlock,result,requiredBufferSize)
+#define IXThreadingImpl_XAsyncGetResult(This,asyncBlock,identity,bufferSize,buffer,bufferUsed) (This)->lpVtbl->XAsyncGetResult(This,asyncBlock,identity,bufferSize,buffer,bufferUsed)
+#define IXThreadingImpl_XTaskQueueCreate(This,workDispatchMode,completionDispatchMode,queue) (This)->lpVtbl->XTaskQueueCreate(This,workDispatchMode,completionDispatchMode,queue)
+#define IXThreadingImpl_XTaskQueueCreateComposite(This,workPort,completionPort,queue) (This)->lpVtbl->XTaskQueueCreateComposite(This,workPort,completionPort,queue)
+#define IXThreadingImpl_XTaskQueueGetPort(This,queue,port,portHandle) (This)->lpVtbl->XTaskQueueGetPort(This,queue,port,portHandle)
+#define IXThreadingImpl_XTaskQueueDuplicateHandle(This,queueHandle,duplicatedHandle) (This)->lpVtbl->XTaskQueueDuplicateHandle(This,queueHandle,duplicatedHandle)
+#define IXThreadingImpl_XTaskQueueDispatch(This,queue,port,timeoutInMs) (This)->lpVtbl->XTaskQueueDispatch(This,queue,port,timeoutInMs)
+#define IXThreadingImpl_XTaskQueueCloseHandle(This,queue) (This)->lpVtbl->XTaskQueueCloseHandle(This,queue)
+#define IXThreadingImpl_XTaskQueueSubmitCallback(This,queue,port,callbackContext,callback) (This)->lpVtbl->XTaskQueueSubmitCallback(This,queue,port,callbackContext,callback)
+#define IXThreadingImpl_XTaskQueueSubmitDelayedCallback(This,queue,port,delayMs,callbackContext,callback) (This)->lpVtbl->XTaskQueueSubmitDelayedCallback(This,queue,port,delayMs,callbackContext,callback)
+#define IXThreadingImpl_XTaskQueueRegisterWaiter(This,queue,port,waitHandle,callbackContext,callback,token) (This)->lpVtbl->XTaskQueueRegisterWaiter(This,queue,port,waitHandle,callbackContext,callback,token)
+#define IXThreadingImpl_XTaskQueueUnregisterWaiter(This,queue,token) (This)->lpVtbl->XTaskQueueUnregisterWaiter(This,queue,token)
+#define IXThreadingImpl_XTaskQueueTerminate(This,queue,wait,callbackContext,callback) (This)->lpVtbl->XTaskQueueTerminate(This,queue,wait,callbackContext,callback)
+#define IXThreadingImpl_XTaskQueueRegisterMonitor(This,queue,callbackContext,callback,token) (This)->lpVtbl->XTaskQueueRegisterMonitor(This,queue,callbackContext,callback,token)
+#define IXThreadingImpl_XTaskQueueUnregisterMonitor(This,queue,token) (This)->lpVtbl->XTaskQueueUnregisterMonitor(This,queue,token)
+#define IXThreadingImpl_XTaskQueueGetCurrentProcessTaskQueue(This,queue) (This)->lpVtbl->XTaskQueueGetCurrentProcessTaskQueue(This,queue)
+#define IXThreadingImpl_XTaskQueueSetCurrentProcessTaskQueue(This,queue) (This)->lpVtbl->XTaskQueueSetCurrentProcessTaskQueue(This,queue)
+#define IXThreadingImpl_XThreadSetTimeSensitive(This,isTimeSensitiveThread) (This)->lpVtbl->XThreadSetTimeSensitive(This,isTimeSensitiveThread)
+#define IXThreadingImpl_XThreadAssertNotTimeSensitive(This) (This)->lpVtbl->XThreadAssertNotTimeSensitive(This)
+#define IXThreadingImpl_XThreadIsTimeSensitive(This) (This)->lpVtbl->XThreadIsTimeSensitive(This)
+
+#else
+/*** IUnknown methods ***/
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_QueryInterface(IXThreadingImpl* This,REFIID riid,void **ppvObject) {
+    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
+}
+static inline ULONG STDMETHODCALLTYPE IXThreadingImpl_AddRef(IXThreadingImpl* This) {
+    return This->lpVtbl->AddRef(This);
+}
+static inline ULONG STDMETHODCALLTYPE IXThreadingImpl_Release(IXThreadingImpl* This) {
+    return This->lpVtbl->Release(This);
+}
+/*** IXGameRuntimeFeatureImpl methods ***/
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XAsyncGetStatus(IXThreadingImpl* This,XAsyncBlock* asyncBlock,boolean wait) {
+    return This->lpVtbl->XAsyncGetStatus(This,asyncBlock,wait);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XAsyncGetResultSize(IXThreadingImpl* This,XAsyncBlock* asyncBlock,SIZE_T *bufferSize) {
+    return This->lpVtbl->XAsyncGetResultSize(This,asyncBlock,bufferSize);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XAsyncCancel(IXThreadingImpl* This,XAsyncBlock* asyncBlock) {
+    This->lpVtbl->XAsyncCancel(This,asyncBlock);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XAsyncRun(IXThreadingImpl* This,XAsyncBlock* asyncBlock,XAsyncWork* work) {
+    return This->lpVtbl->XAsyncRun(This,asyncBlock,work);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XAsyncBegin(IXThreadingImpl* This,XAsyncBlock* asyncBlock,PVOID context,const PVOID identity,LPCSTR identityName,XAsyncProviderCallback* provider) {
+    return This->lpVtbl->XAsyncBegin(This,asyncBlock,context,identity,identityName,provider);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XAsyncSchedule(IXThreadingImpl* This,XAsyncBlock* asyncBlock,UINT32 delayInMs) {
+    return This->lpVtbl->XAsyncSchedule(This,asyncBlock,delayInMs);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XAsyncComplete(IXThreadingImpl* This,XAsyncBlock* asyncBlock,HRESULT result,SIZE_T requiredBufferSize) {
+    This->lpVtbl->XAsyncComplete(This,asyncBlock,result,requiredBufferSize);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XAsyncGetResult(IXThreadingImpl* This,XAsyncBlock* asyncBlock,const PVOID identity,SIZE_T bufferSize,PVOID buffer,SIZE_T* bufferUsed) {
+    return This->lpVtbl->XAsyncGetResult(This,asyncBlock,identity,bufferSize,buffer,bufferUsed);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueCreate(IXThreadingImpl* This,XTaskQueueDispatchMode workDispatchMode,XTaskQueueDispatchMode completionDispatchMode,XTaskQueueHandle* queue) {
+    return This->lpVtbl->XTaskQueueCreate(This,workDispatchMode,completionDispatchMode,queue);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueCreateComposite(IXThreadingImpl* This,XTaskQueuePortHandle workPort,XTaskQueuePortHandle completionPort,XTaskQueueHandle* queue) {
+    return This->lpVtbl->XTaskQueueCreateComposite(This,workPort,completionPort,queue);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueGetPort(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueuePort port,XTaskQueuePortHandle* portHandle) {
+    return This->lpVtbl->XTaskQueueGetPort(This,queue,port,portHandle);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueDuplicateHandle(IXThreadingImpl* This,XTaskQueueHandle queueHandle,XTaskQueueHandle* duplicatedHandle) {
+    return This->lpVtbl->XTaskQueueDuplicateHandle(This,queueHandle,duplicatedHandle);
+}
+static inline BOOLEAN STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueDispatch(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueuePort port,uint32_t timeoutInMs) {
+    return This->lpVtbl->XTaskQueueDispatch(This,queue,port,timeoutInMs);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueCloseHandle(IXThreadingImpl* This,XTaskQueueHandle queue) {
+    This->lpVtbl->XTaskQueueCloseHandle(This,queue);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueSubmitCallback(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueuePort port,PVOID callbackContext,XTaskQueueCallback* callback) {
+    return This->lpVtbl->XTaskQueueSubmitCallback(This,queue,port,callbackContext,callback);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueSubmitDelayedCallback(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueuePort port,uint32_t delayMs,PVOID callbackContext,XTaskQueueCallback* callback) {
+    return This->lpVtbl->XTaskQueueSubmitDelayedCallback(This,queue,port,delayMs,callbackContext,callback);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueRegisterWaiter(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueuePort port,HANDLE waitHandle,PVOID callbackContext,XTaskQueueCallback* callback,XTaskQueueRegistrationToken* token) {
+    return This->lpVtbl->XTaskQueueRegisterWaiter(This,queue,port,waitHandle,callbackContext,callback,token);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueUnregisterWaiter(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueueRegistrationToken token) {
+    This->lpVtbl->XTaskQueueUnregisterWaiter(This,queue,token);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueTerminate(IXThreadingImpl* This,XTaskQueueHandle queue,BOOLEAN wait,PVOID callbackContext,XTaskQueueTerminatedCallback* callback) {
+    return This->lpVtbl->XTaskQueueTerminate(This,queue,wait,callbackContext,callback);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueRegisterMonitor(IXThreadingImpl* This,XTaskQueueHandle queue,PVOID callbackContext,XTaskQueueMonitorCallback* callback,XTaskQueueRegistrationToken* token) {
+    return This->lpVtbl->XTaskQueueRegisterMonitor(This,queue,callbackContext,callback,token);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueUnregisterMonitor(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueueRegistrationToken token) {
+    This->lpVtbl->XTaskQueueUnregisterMonitor(This,queue,token);
+}
+static inline BOOLEAN STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueGetCurrentProcessTaskQueue(IXThreadingImpl* This,XTaskQueueHandle* queue) {
+    return This->lpVtbl->XTaskQueueGetCurrentProcessTaskQueue(This,queue);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueSetCurrentProcessTaskQueue(IXThreadingImpl* This,XTaskQueueHandle queue) {
+    This->lpVtbl->XTaskQueueSetCurrentProcessTaskQueue(This,queue);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XThreadSetTimeSensitive(IXThreadingImpl* This,BOOLEAN isTimeSensitiveThread) {
+    return This->lpVtbl->XThreadSetTimeSensitive(This,isTimeSensitiveThread);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XThreadAssertNotTimeSensitive(IXThreadingImpl* This) {
+    This->lpVtbl->XThreadAssertNotTimeSensitive(This);
+}
+static inline BOOLEAN STDMETHODCALLTYPE IXThreadingImpl_XThreadIsTimeSensitive(IXThreadingImpl* This) {
+    return This->lpVtbl->XThreadIsTimeSensitive(This);
+}
+#endif
+#endif
+
+// 073b7dcb-1fcf-4030-94be-e3c9eb623428
+
+DEFINE_GUID(CLSID_XThreadingImpl, 0x073b7dcb, 0x1fcf, 0x4030, 0x94,0xbe, 0xe3,0xc9,0xeb,0x62,0x34,0x28);
+DEFINE_GUID(IID_IXThreadingImpl, 0x073b7dcb, 0x1fcf, 0x4030, 0x94,0xbe, 0xe3,0xc9,0xeb,0x62,0x34,0x28);
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/xgameruntime.spec b/dlls/xgameruntime/xgameruntime.spec
new file mode 100644
index 00000000000..e4b1de88d89
--- /dev/null
+++ b/dlls/xgameruntime/xgameruntime.spec
@@ -0,0 +1,9 @@
+1 stdcall -private DllCanUnloadNow()
+2 stdcall InitializeApiImpl(long long)
+3 stdcall InitializeApiImplEx(long long long)
+4 stdcall InitializeApiImplEx2(long long long ptr)
+5 stdcall QueryApiImpl(ptr long long)
+6 stdcall UninitializeApiImpl()
+7 stdcall XErrorReport(long ptr)
+
+@ stdcall -private DllMain(long long ptr)
\ No newline at end of file
diff --git a/dlls/xgameruntime/xnetwork.h b/dlls/xgameruntime/xnetwork.h
new file mode 100644
index 00000000000..5953c127c30
--- /dev/null
+++ b/dlls/xgameruntime/xnetwork.h
@@ -0,0 +1,157 @@
+/*
+ * xgameruntime.dll implementation
+ *
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __XNETWORK_H
+#define __XNETWORK_H
+
+#include <xnetworking.h>
+
+typedef struct IXNetworkingImpl IXNetworkingImpl;
+
+typedef struct IXNetworkingImplVtbl {
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(IXNetworkingImpl* This, REFIID riid, void** ppvObject);
+    ULONG   (STDMETHODCALLTYPE *AddRef)(IXNetworkingImpl* This);
+    ULONG   (STDMETHODCALLTYPE *Release)(IXNetworkingImpl* This);
+
+    HRESULT (STDMETHODCALLTYPE *XNetworkingQueryPreferredLocalUdpMultiplayerPort)(IXNetworkingImpl* This, UINT16* preferredLocalUdpMultiplayerPort);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingQueryPreferredLocalUdpMultiplayerPortAsync)(IXNetworkingImpl* This, XAsyncBlock* asyncBlock);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingQueryPreferredLocalUdpMultiplayerPortAsyncResult)(IXNetworkingImpl* This, XAsyncBlock* asyncBlock, UINT16* preferredLocalUdpMultiplayerPort);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingRegisterPreferredLocalUdpMultiplayerPortChanged)(IXNetworkingImpl* This, XTaskQueueHandle queue, PVOID context, XNetworkingPreferredLocalUdpMultiplayerPortChangedCallback* callback, XTaskQueueRegistrationToken* token);
+    BOOLEAN (STDMETHODCALLTYPE *XNetworkingUnregisterPreferredLocalUdpMultiplayerPortChanged)(IXNetworkingImpl* This, XTaskQueueRegistrationToken token, BOOLEAN wait);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingQuerySecurityInformationForUrlAsync)(IXNetworkingImpl* This, LPCSTR url, XAsyncBlock* asyncBlock);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingQuerySecurityInformationForUrlAsyncResultSize)(IXNetworkingImpl *This, XAsyncBlock* asyncBlock, SIZE_T* securityInformationBufferByteCount);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingQuerySecurityInformationForUrlAsyncResult)(IXNetworkingImpl *This, XAsyncBlock* asyncBlock, SIZE_T securityInformationBufferByteCount, SIZE_T* securityInformationBufferByteCountUsed, UINT8* securityInformationBuffer, XNetworkingSecurityInformation** securityInformation);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingQuerySecurityInformationForUrlUtf16Async)(IXNetworkingImpl* This, LPCWSTR url, XAsyncBlock* asyncBlock);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingQuerySecurityInformationForUrlUtf16AsyncResultSize)(IXNetworkingImpl *This, XAsyncBlock* asyncBlock, SIZE_T* securityInformationBufferByteCount);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingQuerySecurityInformationForUrlUtf16AsyncResult)(IXNetworkingImpl *This, XAsyncBlock* asyncBlock, SIZE_T securityInformationBufferByteCount, SIZE_T* securityInformationBufferByteCountUsed, UINT8* securityInformationBuffer, XNetworkingSecurityInformation** securityInformation);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingVerifyServerCertificate)(IXNetworkingImpl *This, PVOID requestHandle, const XNetworkingSecurityInformation* securityInformation);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingGetConnectivityHint)(IXNetworkingImpl *This, XNetworkingConnectivityHint* connectivityHint);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingRegisterConnectivityHintChanged)(IXNetworkingImpl *This, XTaskQueueHandle queue, PVOID context, XNetworkingConnectivityHintChangedCallback* callback, XTaskQueueRegistrationToken* token);
+    BOOLEAN (STDMETHODCALLTYPE *XNetworkingUnregisterConnectivityHintChanged)(IXNetworkingImpl* This, XTaskQueueRegistrationToken token, BOOLEAN wait);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingQueryConfigurationSetting)(IXNetworkingImpl* This, XNetworkingConfigurationSetting configurationSetting, UINT64* value);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingSetConfigurationSetting)(IXNetworkingImpl* This, XNetworkingConfigurationSetting configurationParameter, UINT64 value);
+    HRESULT (STDMETHODCALLTYPE *XNetworkingQueryStatistics)(IXNetworkingImpl* This, XNetworkingStatisticsBuffer* statisticsBuffer);
+} IXNetworkingImplVtbl;
+
+struct IXNetworkingImpl {
+    const IXNetworkingImplVtbl* lpVtbl;
+};
+
+#ifdef COBJMACROS
+#ifndef WIDL_C_INLINE_WRAPPERS
+/*** IUnknown methods ***/
+#define IXNetworkingImpl_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
+#define IXNetworkingImpl_AddRef(This) (This)->lpVtbl->AddRef(This)
+#define IXNetworkingImpl_Release(This) (This)->lpVtbl->Release(This)
+/*** IXNetworkingImpl methods ***/
+#define IXNetworkingImpl_XNetworkingQueryPreferredLocalUdpMultiplayerPort(This,preferredLocalUdpMultiplayerPort) (This)->lpVtbl->XNetworkingQueryPreferredLocalUdpMultiplayerPort(This,preferredLocalUdpMultiplayerPort)
+#define IXNetworkingImpl_XNetworkingQueryPreferredLocalUdpMultiplayerPortAsync(This,asyncBlock) (This)->lpVtbl->XNetworkingQueryPreferredLocalUdpMultiplayerPortAsync(This,asyncBlock)
+#define IXNetworkingImpl_XNetworkingQueryPreferredLocalUdpMultiplayerPortAsyncResult(This,asyncBlock,preferredLocalUdpMultiplayerPort) (This)->lpVtbl->XNetworkingQueryPreferredLocalUdpMultiplayerPortAsyncResult(This,asyncBlock,preferredLocalUdpMultiplayerPort)
+#define IXNetworkingImpl_XNetworkingRegisterPreferredLocalUdpMultiplayerPortChanged(This,queue,context,callback,token) (This)->lpVtbl->XNetworkingRegisterPreferredLocalUdpMultiplayerPortChanged(This,queue,context,callback,token)
+#define IXNetworkingImpl_XNetworkingUnregisterPreferredLocalUdpMultiplayerPortChanged(This,token,wait) (This)->lpVtbl->XNetworkingUnregisterPreferredLocalUdpMultiplayerPortChanged(This,token,wait)
+#define IXNetworkingImpl_XNetworkingQuerySecurityInformationForUrlAsync(This,url,asyncBlock) (This)->lpVtbl->XNetworkingQuerySecurityInformationForUrlAsync(This,url,asyncBlock)
+#define IXNetworkingImpl_XNetworkingQuerySecurityInformationForUrlAsyncResultSize(This,asyncBlock,securityInformationBufferByteCount) (This)->lpVtbl->XNetworkingQuerySecurityInformationForUrlAsyncResultSize(This,asyncBlock,securityInformationBufferByteCount)
+#define IXNetworkingImpl_XNetworkingQuerySecurityInformationForUrlAsyncResult(This,asyncBlock,securityInformationBufferByteCount,securityInformationBufferByteCountUsed,securityInformationBuffer,securityInformation) (This)->lpVtbl->XNetworkingQuerySecurityInformationForUrlAsyncResult(This,asyncBlock,securityInformationBufferByteCount,securityInformationBufferByteCountUsed,securityInformationBuffer,securityInformation)
+#define IXNetworkingImpl_XNetworkingQuerySecurityInformationForUrlUtf16Async(This,url,asyncBlock) (This)->lpVtbl->XNetworkingQuerySecurityInformationForUrlUtf16Async(This,url,asyncBlock)
+#define IXNetworkingImpl_XNetworkingQuerySecurityInformationForUrlUtf16AsyncResultSize(This,asyncBlock,securityInformationBufferByteCount) (This)->lpVtbl->XNetworkingQuerySecurityInformationForUrlUtf16AsyncResultSize(This,asyncBlock,securityInformationBufferByteCount)
+#define IXNetworkingImpl_XNetworkingQuerySecurityInformationForUrlUtf16AsyncResult(This,asyncBlock,securityInformationBufferByteCount,securityInformationBufferByteCountUsed,securityInformationBuffer,securityInformation) (This)->lpVtbl->XNetworkingQuerySecurityInformationForUrlUtf16AsyncResult(This,asyncBlock,securityInformationBufferByteCount,securityInformationBufferByteCountUsed,securityInformationBuffer,securityInformation)
+#define IXNetworkingImpl_XNetworkingVerifyServerCertificate(This,requestHandle,securityInformation) (This)->lpVtbl->XNetworkingVerifyServerCertificate(This,requestHandle,securityInformation)
+#define IXNetworkingImpl_XNetworkingGetConnectivityHint(This,connectivityHint) (This)->lpVtbl->XNetworkingGetConnectivityHint(This,connectivityHint)
+#define IXNetworkingImpl_XNetworkingRegisterConnectivityHintChanged(This,queue,context,callback,token) (This)->lpVtbl->XNetworkingRegisterConnectivityHintChanged(This,queue,context,callback,token)
+#define IXNetworkingImpl_XNetworkingUnregisterConnectivityHintChanged(This,token,wait) (This)->lpVtbl->XNetworkingUnregisterConnectivityHintChanged(This,token,wait)
+#define IXNetworkingImpl_XNetworkingQueryConfigurationSetting(This,configurationSetting,value) (This)->lpVtbl->XNetworkingQueryConfigurationSetting(This,configurationSetting,value)
+#define IXNetworkingImpl_XNetworkingSetConfigurationSetting(This,configurationParameter,value) (This)->lpVtbl->XNetworkingSetConfigurationSetting(This,configurationParameter,value)
+#define IXNetworkingImpl_XNetworkingQueryStatistics(This,statisticsBuffer) (This)->lpVtbl->XNetworkingQueryStatistics(This,statisticsBuffer)
+#else
+/*** IUnknown methods ***/
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_QueryInterface(IXNetworkingImpl* This,REFIID riid,void **ppvObject) {
+    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
+}
+static inline ULONG STDMETHODCALLTYPE IXNetworkingImpl_AddRef(IXNetworkingImpl* This) {
+    return This->lpVtbl->AddRef(This);
+}
+static inline ULONG STDMETHODCALLTYPE IXNetworkingImpl_Release(IXNetworkingImpl* This) {
+    return This->lpVtbl->Release(This);
+}
+/*** IXNetworkingImpl methods ***/
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingQueryPreferredLocalUdpMultiplayerPort(IXNetworkingImpl* This,UINT16* preferredLocalUdpMultiplayerPort) {
+    return This->lpVtbl->XNetworkingQueryPreferredLocalUdpMultiplayerPort(This,preferredLocalUdpMultiplayerPort);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingQueryPreferredLocalUdpMultiplayerPortAsync(IXNetworkingImpl* This,XAsyncBlock* asyncBlock) {
+    return This->lpVtbl->XNetworkingQueryPreferredLocalUdpMultiplayerPortAsync(This,asyncBlock);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingQueryPreferredLocalUdpMultiplayerPortAsyncResult(IXNetworkingImpl* This,XAsyncBlock* asyncBlock,UINT16* preferredLocalUdpMultiplayerPort) {
+    return This->lpVtbl->XNetworkingQueryPreferredLocalUdpMultiplayerPortAsyncResult(This,asyncBlock,preferredLocalUdpMultiplayerPort);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingRegisterPreferredLocalUdpMultiplayerPortChanged(IXNetworkingImpl* This,XTaskQueueHandle queue,PVOID context,XNetworkingPreferredLocalUdpMultiplayerPortChangedCallback* callback,XTaskQueueRegistrationToken* token) {
+    return This->lpVtbl->XNetworkingRegisterPreferredLocalUdpMultiplayerPortChanged(This,queue,context,callback,token);
+}
+static inline BOOLEAN STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingUnregisterPreferredLocalUdpMultiplayerPortChanged(IXNetworkingImpl* This,XTaskQueueRegistrationToken token,BOOLEAN wait) {
+    return This->lpVtbl->XNetworkingUnregisterPreferredLocalUdpMultiplayerPortChanged(This,token,wait);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingQuerySecurityInformationForUrlAsync(IXNetworkingImpl* This,LPCSTR url,XAsyncBlock* asyncBlock) {
+    return This->lpVtbl->XNetworkingQuerySecurityInformationForUrlAsync(This,url,asyncBlock);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingQuerySecurityInformationForUrlAsyncResultSize(IXNetworkingImpl *This,XAsyncBlock* asyncBlock,SIZE_T* securityInformationBufferByteCount) {
+    return This->lpVtbl->XNetworkingQuerySecurityInformationForUrlAsyncResultSize(This,asyncBlock,securityInformationBufferByteCount);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingQuerySecurityInformationForUrlAsyncResult(IXNetworkingImpl *This,XAsyncBlock* asyncBlock,SIZE_T securityInformationBufferByteCount,SIZE_T* securityInformationBufferByteCountUsed,UINT8* securityInformationBuffer,XNetworkingSecurityInformation** securityInformation) {
+    return This->lpVtbl->XNetworkingQuerySecurityInformationForUrlAsyncResult(This,asyncBlock,securityInformationBufferByteCount,securityInformationBufferByteCountUsed,securityInformationBuffer,securityInformation);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingQuerySecurityInformationForUrlUtf16Async(IXNetworkingImpl* This,LPCWSTR url,XAsyncBlock* asyncBlock) {
+    return This->lpVtbl->XNetworkingQuerySecurityInformationForUrlUtf16Async(This,url,asyncBlock);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingQuerySecurityInformationForUrlUtf16AsyncResultSize(IXNetworkingImpl *This,XAsyncBlock* asyncBlock,SIZE_T* securityInformationBufferByteCount) {
+    return This->lpVtbl->XNetworkingQuerySecurityInformationForUrlUtf16AsyncResultSize(This,asyncBlock,securityInformationBufferByteCount);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingQuerySecurityInformationForUrlUtf16AsyncResult(IXNetworkingImpl *This,XAsyncBlock* asyncBlock,SIZE_T securityInformationBufferByteCount,SIZE_T* securityInformationBufferByteCountUsed,UINT8* securityInformationBuffer,XNetworkingSecurityInformation** securityInformation) {
+    return This->lpVtbl->XNetworkingQuerySecurityInformationForUrlUtf16AsyncResult(This,asyncBlock,securityInformationBufferByteCount,securityInformationBufferByteCountUsed,securityInformationBuffer,securityInformation);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingVerifyServerCertificate(IXNetworkingImpl *This,PVOID requestHandle,const XNetworkingSecurityInformation* securityInformation) {
+    return This->lpVtbl->XNetworkingVerifyServerCertificate(This,requestHandle,securityInformation);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingGetConnectivityHint(IXNetworkingImpl *This,XNetworkingConnectivityHint* connectivityHint) {
+    return This->lpVtbl->XNetworkingGetConnectivityHint(This,connectivityHint);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingRegisterConnectivityHintChanged(IXNetworkingImpl *This,XTaskQueueHandle queue,PVOID context,XNetworkingConnectivityHintChangedCallback* callback,XTaskQueueRegistrationToken* token) {
+    return This->lpVtbl->XNetworkingRegisterConnectivityHintChanged(This,queue,context,callback,token);
+}
+static inline BOOLEAN STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingUnregisterConnectivityHintChanged(IXNetworkingImpl* This,XTaskQueueRegistrationToken token,BOOLEAN wait) {
+    return This->lpVtbl->XNetworkingUnregisterConnectivityHintChanged(This,token,wait);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingQueryConfigurationSetting(IXNetworkingImpl* This,XNetworkingConfigurationSetting configurationSetting,UINT64* value) {
+    return This->lpVtbl->XNetworkingQueryConfigurationSetting(This,configurationSetting,value);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingSetConfigurationSetting(IXNetworkingImpl* This,XNetworkingConfigurationSetting configurationParameter,UINT64 value) {
+    return This->lpVtbl->XNetworkingSetConfigurationSetting(This,configurationParameter,value);
+}
+static inline HRESULT STDMETHODCALLTYPE IXNetworkingImpl_XNetworkingQueryStatistics(IXNetworkingImpl* This,XNetworkingStatisticsBuffer* statisticsBuffer) {
+    return This->lpVtbl->XNetworkingQueryStatistics(This,statisticsBuffer);
+}
+#endif
+#endif
+
+// 37e56907-2f10-41e8-b72f-36edb185331a
+DEFINE_GUID(CLSID_XNetworkingImpl, 0x37e56907, 0x2f10, 0x41e8, 0xb7,0x2f, 0x36,0xed,0xb1,0x85,0x33,0x1a);
+
+// bf2346b2-39af-4658-b5ea-44713c7e83b3
+DEFINE_GUID(IID_IXNetworkingImpl, 0xbf2346b2, 0x39af, 0x4658, 0xb5,0xea, 0x44,0x71,0x3c,0x7e,0x83,0xb3);
+
+#endif
\ No newline at end of file
diff --git a/dlls/xgameruntime/xthread.h b/dlls/xgameruntime/xthread.h
new file mode 100644
index 00000000000..b4799a5701b
--- /dev/null
+++ b/dlls/xgameruntime/xthread.h
@@ -0,0 +1,199 @@
+/*
+ * xgameruntime.dll implementation
+ *
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __XTHREAD_H
+#define __XTHREAD_H
+
+#include <xasyncprovider.h>
+
+typedef struct IXThreadingImpl IXThreadingImpl;
+
+typedef struct IXThreadingImplVtbl {
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(IXThreadingImpl* This, REFIID riid, void** ppvObject);
+    ULONG   (STDMETHODCALLTYPE *AddRef)(IXThreadingImpl* This);
+    ULONG   (STDMETHODCALLTYPE *Release)(IXThreadingImpl* This);
+    
+    HRESULT (STDMETHODCALLTYPE *XAsyncGetStatus)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, boolean wait);
+    HRESULT (STDMETHODCALLTYPE *XAsyncGetResultSize)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, SIZE_T *bufferSize);
+    VOID    (STDMETHODCALLTYPE *XAsyncCancel)(IXThreadingImpl* This, XAsyncBlock* asyncBlock);
+    HRESULT (STDMETHODCALLTYPE *XAsyncRun)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, XAsyncWork* work);
+    HRESULT (STDMETHODCALLTYPE *XAsyncBegin)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, PVOID context, const PVOID identity, LPCSTR identityName, XAsyncProviderCallback* provider);
+    HRESULT (STDMETHODCALLTYPE *__PADDING__)(IXThreadingImpl* This);
+    HRESULT (STDMETHODCALLTYPE *XAsyncSchedule)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, UINT32 delayInMs);
+    VOID    (STDMETHODCALLTYPE *XAsyncComplete)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, HRESULT result, SIZE_T requiredBufferSize);
+    HRESULT (STDMETHODCALLTYPE *XAsyncGetResult)(IXThreadingImpl* This, XAsyncBlock* asyncBlock, const PVOID identity, SIZE_T bufferSize, PVOID buffer, SIZE_T* bufferUsed);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueCreate)(IXThreadingImpl* This, XTaskQueueDispatchMode workDispatchMode, XTaskQueueDispatchMode completionDispatchMode, XTaskQueueHandle* queue);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueCreateComposite)(IXThreadingImpl* This, XTaskQueuePortHandle workPort, XTaskQueuePortHandle completionPort, XTaskQueueHandle* queue);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueGetPort)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueuePort port, XTaskQueuePortHandle* portHandle);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueDuplicateHandle)(IXThreadingImpl* This, XTaskQueueHandle queueHandle, XTaskQueueHandle* duplicatedHandle);
+    BOOLEAN (STDMETHODCALLTYPE *XTaskQueueDispatch)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueuePort port, uint32_t timeoutInMs);
+    VOID    (STDMETHODCALLTYPE *XTaskQueueCloseHandle)(IXThreadingImpl* This, XTaskQueueHandle queue);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueSubmitCallback)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueuePort port, PVOID callbackContext, XTaskQueueCallback* callback);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueSubmitDelayedCallback)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueuePort port, uint32_t delayMs, PVOID callbackContext, XTaskQueueCallback* callback);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueRegisterWaiter)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueuePort port, HANDLE waitHandle, PVOID callbackContext, XTaskQueueCallback* callback, XTaskQueueRegistrationToken* token);
+    VOID    (STDMETHODCALLTYPE *XTaskQueueUnregisterWaiter)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueueRegistrationToken token);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueTerminate)(IXThreadingImpl* This, XTaskQueueHandle queue, BOOLEAN wait, PVOID callbackContext, XTaskQueueTerminatedCallback* callback);
+    HRESULT (STDMETHODCALLTYPE *XTaskQueueRegisterMonitor)(IXThreadingImpl* This, XTaskQueueHandle queue, PVOID callbackContext, XTaskQueueMonitorCallback* callback, XTaskQueueRegistrationToken* token);
+    VOID    (STDMETHODCALLTYPE *XTaskQueueUnregisterMonitor)(IXThreadingImpl* This, XTaskQueueHandle queue, XTaskQueueRegistrationToken token);
+    BOOLEAN (STDMETHODCALLTYPE *XTaskQueueGetCurrentProcessTaskQueue)(IXThreadingImpl* This, XTaskQueueHandle* queue);
+    VOID    (STDMETHODCALLTYPE *XTaskQueueSetCurrentProcessTaskQueue)(IXThreadingImpl* This, XTaskQueueHandle queue);
+    HRESULT (STDMETHODCALLTYPE *XThreadSetTimeSensitive)(IXThreadingImpl* This, BOOLEAN isTimeSensitiveThread);
+    HRESULT (STDMETHODCALLTYPE *__PADDING_2__)(IXThreadingImpl* This);
+    VOID    (STDMETHODCALLTYPE *XThreadAssertNotTimeSensitive)(IXThreadingImpl* This);
+    BOOLEAN (STDMETHODCALLTYPE *XThreadIsTimeSensitive)(IXThreadingImpl* This);
+} IXThreadingImplVtbl;
+
+struct IXThreadingImpl {
+    const IXThreadingImplVtbl* lpVtbl;
+};
+
+#ifdef COBJMACROS
+#ifndef WIDL_C_INLINE_WRAPPERS
+/*** IUnknown methods ***/
+#define IXThreadingImpl_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
+#define IXThreadingImpl_AddRef(This) (This)->lpVtbl->AddRef(This)
+#define IXThreadingImpl_Release(This) (This)->lpVtbl->Release(This)
+/*** IXThreadingImpl methods ***/
+#define IXThreadingImpl_XAsyncGetStatus(This,asyncBlock,wait) (This)->lpVtbl->XAsyncGetStatus(This,asyncBlock,wait)
+#define IXThreadingImpl_XAsyncGetResultSize(This,asyncBlock,bufferSize) (This)->lpVtbl->XAsyncGetResultSize(This,asyncBlock,bufferSize)
+#define IXThreadingImpl_XAsyncCancel(This,asyncBlock) (This)->lpVtbl->XAsyncCancel(This,asyncBlock)
+#define IXThreadingImpl_XAsyncRun(This,asyncBlock,work) (This)->lpVtbl->XAsyncRun(This,asyncBlock,work)
+#define IXThreadingImpl_XAsyncBegin(This,asyncBlock,context,identity,identityName,provider) (This)->lpVtbl->XAsyncBegin(This,asyncBlock,context,identity,identityName,provider)
+#define IXThreadingImpl_XAsyncSchedule(This,asyncBlock,delayInMs) (This)->lpVtbl->XAsyncSchedule(This,asyncBlock,delayInMs)
+#define IXThreadingImpl_XAsyncComplete(This,asyncBlock,result,requiredBufferSize) (This)->lpVtbl->XAsyncComplete(This,asyncBlock,result,requiredBufferSize)
+#define IXThreadingImpl_XAsyncGetResult(This,asyncBlock,identity,bufferSize,buffer,bufferUsed) (This)->lpVtbl->XAsyncGetResult(This,asyncBlock,identity,bufferSize,buffer,bufferUsed)
+#define IXThreadingImpl_XTaskQueueCreate(This,workDispatchMode,completionDispatchMode,queue) (This)->lpVtbl->XTaskQueueCreate(This,workDispatchMode,completionDispatchMode,queue)
+#define IXThreadingImpl_XTaskQueueCreateComposite(This,workPort,completionPort,queue) (This)->lpVtbl->XTaskQueueCreateComposite(This,workPort,completionPort,queue)
+#define IXThreadingImpl_XTaskQueueGetPort(This,queue,port,portHandle) (This)->lpVtbl->XTaskQueueGetPort(This,queue,port,portHandle)
+#define IXThreadingImpl_XTaskQueueDuplicateHandle(This,queueHandle,duplicatedHandle) (This)->lpVtbl->XTaskQueueDuplicateHandle(This,queueHandle,duplicatedHandle)
+#define IXThreadingImpl_XTaskQueueDispatch(This,queue,port,timeoutInMs) (This)->lpVtbl->XTaskQueueDispatch(This,queue,port,timeoutInMs)
+#define IXThreadingImpl_XTaskQueueCloseHandle(This,queue) (This)->lpVtbl->XTaskQueueCloseHandle(This,queue)
+#define IXThreadingImpl_XTaskQueueSubmitCallback(This,queue,port,callbackContext,callback) (This)->lpVtbl->XTaskQueueSubmitCallback(This,queue,port,callbackContext,callback)
+#define IXThreadingImpl_XTaskQueueSubmitDelayedCallback(This,queue,port,delayMs,callbackContext,callback) (This)->lpVtbl->XTaskQueueSubmitDelayedCallback(This,queue,port,delayMs,callbackContext,callback)
+#define IXThreadingImpl_XTaskQueueRegisterWaiter(This,queue,port,waitHandle,callbackContext,callback,token) (This)->lpVtbl->XTaskQueueRegisterWaiter(This,queue,port,waitHandle,callbackContext,callback,token)
+#define IXThreadingImpl_XTaskQueueUnregisterWaiter(This,queue,token) (This)->lpVtbl->XTaskQueueUnregisterWaiter(This,queue,token)
+#define IXThreadingImpl_XTaskQueueTerminate(This,queue,wait,callbackContext,callback) (This)->lpVtbl->XTaskQueueTerminate(This,queue,wait,callbackContext,callback)
+#define IXThreadingImpl_XTaskQueueRegisterMonitor(This,queue,callbackContext,callback,token) (This)->lpVtbl->XTaskQueueRegisterMonitor(This,queue,callbackContext,callback,token)
+#define IXThreadingImpl_XTaskQueueUnregisterMonitor(This,queue,token) (This)->lpVtbl->XTaskQueueUnregisterMonitor(This,queue,token)
+#define IXThreadingImpl_XTaskQueueGetCurrentProcessTaskQueue(This,queue) (This)->lpVtbl->XTaskQueueGetCurrentProcessTaskQueue(This,queue)
+#define IXThreadingImpl_XTaskQueueSetCurrentProcessTaskQueue(This,queue) (This)->lpVtbl->XTaskQueueSetCurrentProcessTaskQueue(This,queue)
+#define IXThreadingImpl_XThreadSetTimeSensitive(This,isTimeSensitiveThread) (This)->lpVtbl->XThreadSetTimeSensitive(This,isTimeSensitiveThread)
+#define IXThreadingImpl_XThreadAssertNotTimeSensitive(This) (This)->lpVtbl->XThreadAssertNotTimeSensitive(This)
+#define IXThreadingImpl_XThreadIsTimeSensitive(This) (This)->lpVtbl->XThreadIsTimeSensitive(This)
+
+#else
+/*** IUnknown methods ***/
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_QueryInterface(IXThreadingImpl* This,REFIID riid,void **ppvObject) {
+    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
+}
+static inline ULONG STDMETHODCALLTYPE IXThreadingImpl_AddRef(IXThreadingImpl* This) {
+    return This->lpVtbl->AddRef(This);
+}
+static inline ULONG STDMETHODCALLTYPE IXThreadingImpl_Release(IXThreadingImpl* This) {
+    return This->lpVtbl->Release(This);
+}
+/*** IXGameRuntimeFeatureImpl methods ***/
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XAsyncGetStatus(IXThreadingImpl* This,XAsyncBlock* asyncBlock,boolean wait) {
+    return This->lpVtbl->XAsyncGetStatus(This,asyncBlock,wait);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XAsyncGetResultSize(IXThreadingImpl* This,XAsyncBlock* asyncBlock,SIZE_T *bufferSize) {
+    return This->lpVtbl->XAsyncGetResultSize(This,asyncBlock,bufferSize);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XAsyncCancel(IXThreadingImpl* This,XAsyncBlock* asyncBlock) {
+    This->lpVtbl->XAsyncCancel(This,asyncBlock);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XAsyncRun(IXThreadingImpl* This,XAsyncBlock* asyncBlock,XAsyncWork* work) {
+    return This->lpVtbl->XAsyncRun(This,asyncBlock,work);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XAsyncBegin(IXThreadingImpl* This,XAsyncBlock* asyncBlock,PVOID context,const PVOID identity,LPCSTR identityName,XAsyncProviderCallback* provider) {
+    return This->lpVtbl->XAsyncBegin(This,asyncBlock,context,identity,identityName,provider);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XAsyncSchedule(IXThreadingImpl* This,XAsyncBlock* asyncBlock,UINT32 delayInMs) {
+    return This->lpVtbl->XAsyncSchedule(This,asyncBlock,delayInMs);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XAsyncComplete(IXThreadingImpl* This,XAsyncBlock* asyncBlock,HRESULT result,SIZE_T requiredBufferSize) {
+    This->lpVtbl->XAsyncComplete(This,asyncBlock,result,requiredBufferSize);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XAsyncGetResult(IXThreadingImpl* This,XAsyncBlock* asyncBlock,const PVOID identity,SIZE_T bufferSize,PVOID buffer,SIZE_T* bufferUsed) {
+    return This->lpVtbl->XAsyncGetResult(This,asyncBlock,identity,bufferSize,buffer,bufferUsed);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueCreate(IXThreadingImpl* This,XTaskQueueDispatchMode workDispatchMode,XTaskQueueDispatchMode completionDispatchMode,XTaskQueueHandle* queue) {
+    return This->lpVtbl->XTaskQueueCreate(This,workDispatchMode,completionDispatchMode,queue);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueCreateComposite(IXThreadingImpl* This,XTaskQueuePortHandle workPort,XTaskQueuePortHandle completionPort,XTaskQueueHandle* queue) {
+    return This->lpVtbl->XTaskQueueCreateComposite(This,workPort,completionPort,queue);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueGetPort(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueuePort port,XTaskQueuePortHandle* portHandle) {
+    return This->lpVtbl->XTaskQueueGetPort(This,queue,port,portHandle);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueDuplicateHandle(IXThreadingImpl* This,XTaskQueueHandle queueHandle,XTaskQueueHandle* duplicatedHandle) {
+    return This->lpVtbl->XTaskQueueDuplicateHandle(This,queueHandle,duplicatedHandle);
+}
+static inline BOOLEAN STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueDispatch(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueuePort port,uint32_t timeoutInMs) {
+    return This->lpVtbl->XTaskQueueDispatch(This,queue,port,timeoutInMs);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueCloseHandle(IXThreadingImpl* This,XTaskQueueHandle queue) {
+    This->lpVtbl->XTaskQueueCloseHandle(This,queue);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueSubmitCallback(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueuePort port,PVOID callbackContext,XTaskQueueCallback* callback) {
+    return This->lpVtbl->XTaskQueueSubmitCallback(This,queue,port,callbackContext,callback);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueSubmitDelayedCallback(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueuePort port,uint32_t delayMs,PVOID callbackContext,XTaskQueueCallback* callback) {
+    return This->lpVtbl->XTaskQueueSubmitDelayedCallback(This,queue,port,delayMs,callbackContext,callback);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueRegisterWaiter(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueuePort port,HANDLE waitHandle,PVOID callbackContext,XTaskQueueCallback* callback,XTaskQueueRegistrationToken* token) {
+    return This->lpVtbl->XTaskQueueRegisterWaiter(This,queue,port,waitHandle,callbackContext,callback,token);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueUnregisterWaiter(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueueRegistrationToken token) {
+    This->lpVtbl->XTaskQueueUnregisterWaiter(This,queue,token);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueTerminate(IXThreadingImpl* This,XTaskQueueHandle queue,BOOLEAN wait,PVOID callbackContext,XTaskQueueTerminatedCallback* callback) {
+    return This->lpVtbl->XTaskQueueTerminate(This,queue,wait,callbackContext,callback);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueRegisterMonitor(IXThreadingImpl* This,XTaskQueueHandle queue,PVOID callbackContext,XTaskQueueMonitorCallback* callback,XTaskQueueRegistrationToken* token) {
+    return This->lpVtbl->XTaskQueueRegisterMonitor(This,queue,callbackContext,callback,token);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueUnregisterMonitor(IXThreadingImpl* This,XTaskQueueHandle queue,XTaskQueueRegistrationToken token) {
+    This->lpVtbl->XTaskQueueUnregisterMonitor(This,queue,token);
+}
+static inline BOOLEAN STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueGetCurrentProcessTaskQueue(IXThreadingImpl* This,XTaskQueueHandle* queue) {
+    return This->lpVtbl->XTaskQueueGetCurrentProcessTaskQueue(This,queue);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XTaskQueueSetCurrentProcessTaskQueue(IXThreadingImpl* This,XTaskQueueHandle queue) {
+    This->lpVtbl->XTaskQueueSetCurrentProcessTaskQueue(This,queue);
+}
+static inline HRESULT STDMETHODCALLTYPE IXThreadingImpl_XThreadSetTimeSensitive(IXThreadingImpl* This,BOOLEAN isTimeSensitiveThread) {
+    return This->lpVtbl->XThreadSetTimeSensitive(This,isTimeSensitiveThread);
+}
+static inline VOID STDMETHODCALLTYPE IXThreadingImpl_XThreadAssertNotTimeSensitive(IXThreadingImpl* This) {
+    This->lpVtbl->XThreadAssertNotTimeSensitive(This);
+}
+static inline BOOLEAN STDMETHODCALLTYPE IXThreadingImpl_XThreadIsTimeSensitive(IXThreadingImpl* This) {
+    return This->lpVtbl->XThreadIsTimeSensitive(This);
+}
+#endif
+#endif
+
+// 073b7dcb-1fcf-4030-94be-e3c9eb623428
+
+DEFINE_GUID(CLSID_XThreadingImpl, 0x073b7dcb, 0x1fcf, 0x4030, 0x94,0xbe, 0xe3,0xc9,0xeb,0x62,0x34,0x28);
+DEFINE_GUID(IID_IXThreadingImpl, 0x073b7dcb, 0x1fcf, 0x4030, 0x94,0xbe, 0xe3,0xc9,0xeb,0x62,0x34,0x28);
+
+#endif
\ No newline at end of file
diff --git a/flake.lock b/flake.lock
new file mode 100644
index 00000000000..9d27ec3c299
--- /dev/null
+++ b/flake.lock
@@ -0,0 +1,61 @@
+{
+  "nodes": {
+    "flake-utils": {
+      "inputs": {
+        "systems": "systems"
+      },
+      "locked": {
+        "lastModified": 1731533236,
+        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
+        "owner": "numtide",
+        "repo": "flake-utils",
+        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
+        "type": "github"
+      },
+      "original": {
+        "owner": "numtide",
+        "repo": "flake-utils",
+        "type": "github"
+      }
+    },
+    "nixpkgs": {
+      "locked": {
+        "lastModified": 1763312402,
+        "narHash": "sha256-3YJkOBrFpmcusnh7i8GXXEyh7qZG/8F5z5+717550Hk=",
+        "owner": "NixOS",
+        "repo": "nixpkgs",
+        "rev": "85a6c4a07faa12aaccd81b36ba9bfc2bec974fa1",
+        "type": "github"
+      },
+      "original": {
+        "owner": "NixOS",
+        "ref": "nixpkgs-unstable",
+        "repo": "nixpkgs",
+        "type": "github"
+      }
+    },
+    "root": {
+      "inputs": {
+        "flake-utils": "flake-utils",
+        "nixpkgs": "nixpkgs"
+      }
+    },
+    "systems": {
+      "locked": {
+        "lastModified": 1681028828,
+        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
+        "owner": "nix-systems",
+        "repo": "default",
+        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
+        "type": "github"
+      },
+      "original": {
+        "owner": "nix-systems",
+        "repo": "default",
+        "type": "github"
+      }
+    }
+  },
+  "root": "root",
+  "version": 7
+}
diff --git a/flake.nix b/flake.nix
new file mode 100644
index 00000000000..95637404d8d
--- /dev/null
+++ b/flake.nix
@@ -0,0 +1,52 @@
+{
+  description = "WineGDK";
+
+  inputs = {
+    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
+    flake-utils.url = "github:numtide/flake-utils";
+  };
+
+  outputs =
+    {
+      self,
+      nixpkgs,
+      flake-utils,
+    }:
+    flake-utils.lib.eachDefaultSystem (
+      system:
+      let
+        pkgs = nixpkgs.legacyPackages.${system};
+        inherit (pkgs) lib;
+
+        versionFile = lib.trim (builtins.readFile ./VERSION);
+        version = builtins.elemAt (builtins.match ".*([0-9]{2,}(\\.[0-9]+)+)$" versionFile) 0;
+
+        src = ./.;
+        pname = "wine-gdk";
+      in
+      {
+        packages = rec {
+          wine-gdk64 = pkgs.wine64Packages.base.overrideAttrs (p: {
+            inherit
+              src
+              pname
+              version
+              ;
+            patches = [ ];
+          });
+
+          default = wine-gdk64;
+        };
+
+        apps = rec {
+          wine-gdk64 = {
+            type = "app";
+            program = "${self.packages.${system}.wine-gdk64}/bin/wine64";
+          };
+          default = wine-gdk64;
+        };
+
+        formatter = pkgs.nixfmt-tree;
+      }
+    );
+}
diff --git a/include/Makefile.in b/include/Makefile.in
index 9a4a00ceed8..b8420ebb60d 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -960,6 +960,7 @@ SOURCES = \
 	windows.ui.xaml.hosting.desktopwindowxamlsource.idl \
 	windows.ui.xaml.idl \
 	windows.ui.xaml.interop.idl \
+	windows.ui.text.core.idl \
 	windowscontracts.idl \
 	windowsx.h \
 	wine/afd.h \
diff --git a/include/shobjidl.idl b/include/shobjidl.idl
index e62ef6f003d..19ccad048e0 100644
--- a/include/shobjidl.idl
+++ b/include/shobjidl.idl
@@ -1876,6 +1876,26 @@ interface IContextMenuCB : IUnknown
         [in] LPARAM lParam);
 }
 
+/*****************************************************************************
+ * IDataTransferManagerInterop interface
+ */
+[
+   object,
+   uuid(3a3dcd6c-3eab-43dc-bcde-45671ce800c8),
+   pointer_default(unique),
+   local
+]
+interface IDataTransferManagerInterop : IUnknown
+{
+    HRESULT GetForWindow(
+        [in] HWND appWindow,
+        [in] REFIID riid,
+        [out, optional] void **dataTransferManager);
+
+    HRESULT ShowShareUIForWindow(
+        [in] HWND appWindow);
+}
+
 /*****************************************************************************
  * IShellExecuteHookA interface
  */
diff --git a/include/windows.ui.text.core.idl b/include/windows.ui.text.core.idl
new file mode 100644
index 00000000000..e4ac7844d2f
--- /dev/null
+++ b/include/windows.ui.text.core.idl
@@ -0,0 +1,546 @@
+/*
+ * Written by Weather
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "inspectable.idl";
+import "asyncinfo.idl";
+import "eventtoken.idl";
+import "windowscontracts.idl";
+import "windows.foundation.idl";
+import "windows.globalization.idl";
+import "windows.ui.viewmanagement.idl";
+
+namespace Windows.UI.Text.Core
+{
+    typedef enum CoreTextInputScope CoreTextInputScope;
+    typedef enum CoreTextInputPaneDisplayPolicy CoreTextInputPaneDisplayPolicy;
+    typedef enum CoreTextFormatUpdatingResult CoreTextFormatUpdatingResult;
+    typedef enum CoreTextSelectionUpdatingResult CoreTextSelectionUpdatingResult;
+    typedef enum CoreTextTextUpdatingResult CoreTextTextUpdatingResult;
+
+    typedef struct CoreTextRange CoreTextRange;
+
+    interface ICoreTextCompositionCompletedEventArgs;
+    interface ICoreTextCompositionStartedEventArgs;
+    interface ICoreTextEditContext;
+    interface ICoreTextFormatUpdatingEventArgs;
+    interface ICoreTextLayoutBounds;
+    interface ICoreTextLayoutRequest;
+    interface ICoreTextLayoutRequestedEventArgs;
+    interface ICoreTextSelectionRequest;
+    interface ICoreTextSelectionRequestedEventArgs;
+    interface ICoreTextSelectionUpdatingEventArgs;
+    interface ICoreTextTextRequest;
+    interface ICoreTextTextRequestedEventArgs;
+    interface ICoreTextTextUpdatingEventArgs;
+    interface ICoreTextServicesManager;
+    interface ICoreTextServicesManagerStatics;
+
+    runtimeclass CoreTextCompositionCompletedEventArgs;
+    runtimeclass CoreTextCompositionStartedEventArgs;
+    runtimeclass CoreTextEditContext;
+    runtimeclass CoreTextFormatUpdatingEventArgs;
+    runtimeclass CoreTextLayoutBounds;
+    runtimeclass CoreTextLayoutRequest;
+    runtimeclass CoreTextLayoutRequestedEventArgs;
+    runtimeclass CoreTextSelectionRequest;
+    runtimeclass CoreTextSelectionRequestedEventArgs;
+    runtimeclass CoreTextSelectionUpdatingEventArgs;
+    runtimeclass CoreTextServicesManager;
+    runtimeclass CoreTextTextUpdatingEventArgs;
+    runtimeclass CoreTextTextRequestedEventArgs;
+    runtimeclass CoreTextTextRequest;
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0)
+    ]
+    enum CoreTextInputScope
+    {
+        Default                 = 0,
+        Url                     = 1,
+        FilePath                = 2,
+        FileName                = 3,
+        EmailUserName           = 4,
+        EmailAddress            = 5,
+        UserName                = 6,
+        PersonalFullName        = 7,
+        PersonalNamePrefix      = 8,
+        PersonalGivenName       = 9,
+        PersonalMiddleName      = 10,
+        PersonalSurname         = 11,
+        PersonalNameSuffix      = 12,
+        Address                 = 13,
+        AddressPostalCode       = 14,
+        AddressStreet           = 15,
+        AddressStateOrProvince  = 16,
+        AddressCity             = 17,
+        AddressCountryName      = 18,
+        AddressCountryShortName = 19,
+        CurrencyAmountAndSymbol = 20,
+        CurrencyAmount          = 21,
+        Date                    = 22,
+        DateMonth               = 23,
+        DateDay                 = 24,
+        DateYear                = 25,
+        DateMonthName           = 26,
+        DateDayName             = 27,
+        Number                  = 29,
+        SingleCharacter         = 30,
+        Password                = 31,
+        TelephoneNumber         = 32,
+        TelephoneCountryCode    = 33,
+        TelephoneAreaCode       = 34,
+        TelephoneLocalNumber    = 35,
+        Time                    = 36,
+        TimeHour                = 37,
+        TimeMinuteOrSecond      = 38,
+        NumberFullWidth         = 39,
+        AlphanumericHalfWidth   = 40,
+        AlphanumericFullWidth   = 41,
+        CurrencyChinese         = 42,
+        Bopomofo                = 43,
+        Hiragana                = 44,
+        KatakanaHalfWidth       = 45,
+        KatakanaFullWidth       = 46,
+        Hanja                   = 47,
+        HangulHalfWidth         = 48,
+        HangulFullWidth         = 49,
+        Search                  = 50,
+        Formula                 = 51,
+        SearchIncremental       = 52,
+        ChineseHalfWidth        = 53,
+        ChineseFullWidth        = 54,
+        NativeScript            = 55,
+        Text                    = 57,
+        Chat                    = 58,
+        NameOrPhoneNumber       = 59,
+        EmailUserNameOrAddress  = 60,
+        Private                 = 61,
+        Maps                    = 62,
+        PasswordNumeric         = 63,
+        FormulaNumber           = 67
+    };
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0)
+    ]
+    enum CoreTextInputPaneDisplayPolicy
+    {
+        Automatic = 0,
+        Manual    = 1
+    };
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0)
+    ]
+    enum CoreTextFormatUpdatingResult
+    {
+        Succeeded = 0,
+        Failed    = 1
+    };
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0)
+    ]
+    enum CoreTextSelectionUpdatingResult
+    {
+        Succeeded = 0,
+        Failed    = 1
+    };
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0)
+    ]
+    enum CoreTextTextUpdatingResult
+    {
+        Succeeded = 0,
+        Failed    = 1
+    };
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0)
+    ]
+    struct CoreTextRange
+    {
+        INT32 StartCaretPosition;
+        INT32 EndCaretPosition;
+    };
+
+    declare
+    {
+        interface Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextServicesManager*, IInspectable*>;
+        interface Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, IInspectable*>;
+        interface Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextLayoutRequestedEventArgs*>;
+        interface Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextSelectionRequestedEventArgs*>;
+        interface Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextTextRequestedEventArgs*>;
+        interface Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs*>;
+        interface Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs*>;
+        interface Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs*>;
+        interface Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs*>;
+        interface Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs*>;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs),
+        uuid(1F34EBB6-B79F-4121-A5E7-FDA9B8616E30)
+    ]
+    interface ICoreTextCompositionCompletedEventArgs : IInspectable
+    {
+        [propget] HRESULT IsCanceled([out] [retval] boolean* value);
+        //[propget] HRESULT CompositionSegments([out] [retval] Windows.Foundation.Collections.IVectorView<Windows.UI.Text.Core.CoreTextCompositionSegment*>** value);
+        HRESULT GetDeferral([out] [retval] Windows.Foundation.Deferral** value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs),
+        uuid(276B16A9-64E7-4AB0-BC4B-A02D73835BFB)
+    ]
+    interface ICoreTextCompositionStartedEventArgs : IInspectable
+    {
+        [propget] HRESULT IsCanceled([out] [retval] boolean* value);
+        HRESULT GetDeferral([out] [retval] Windows.Foundation.Deferral** value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextLayoutBounds),
+        uuid(E972C974-4436-4917-80D0-A525E4CA6780)
+    ]
+    interface ICoreTextLayoutBounds : IInspectable
+    {
+        [propget] HRESULT TextBounds([out] [retval] Windows.Foundation.Rect* value);
+        [propput] HRESULT TextBounds([in] Windows.Foundation.Rect value);
+        [propget] HRESULT ControlBounds([out] [retval] Windows.Foundation.Rect* value);
+        [propput] HRESULT ControlBounds([in] Windows.Foundation.Rect value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextLayoutRequest),
+        uuid(2555A8CC-51FD-4F03-98BF-AC78174D68E0)
+    ]
+    interface ICoreTextLayoutRequest : IInspectable
+    {
+        [propget] HRESULT Range([out] [retval] Windows.UI.Text.Core.CoreTextRange* value);
+        [propget] HRESULT LayoutBounds([out] [retval] Windows.UI.Text.Core.CoreTextLayoutBounds** value);
+        [propget] HRESULT IsCanceled([out] [retval] boolean* value);
+        HRESULT GetDeferral([out] [retval] Windows.Foundation.Deferral** value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextLayoutRequestedEventArgs),
+        uuid(B1DC6AE0-9A7B-4E9E-A566-4A6B5F8AD676)
+    ]
+    interface ICoreTextLayoutRequestedEventArgs : IInspectable
+    {
+        [propget] HRESULT Request([out] [retval] Windows.UI.Text.Core.CoreTextLayoutRequest** value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextSelectionRequest),
+        uuid(F0A70403-208B-4301-883C-74CA7485FD8D)
+    ]
+    interface ICoreTextSelectionRequest : IInspectable
+    {
+        [propget] HRESULT Selection([out] [retval] Windows.UI.Text.Core.CoreTextRange* value);
+        [propput] HRESULT Selection([in] Windows.UI.Text.Core.CoreTextRange value);
+        [propget] HRESULT IsCanceled([out] [retval] boolean* value);
+        HRESULT GetDeferral([out] [retval] Windows.Foundation.Deferral** value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextSelectionRequestedEventArgs),
+        uuid(13C6682B-F614-421A-8F4B-9EC8A5A37FCD)
+    ]
+    interface ICoreTextSelectionRequestedEventArgs : IInspectable
+    {
+        [propget] HRESULT Request([out] [retval] Windows.UI.Text.Core.CoreTextSelectionRequest** value);
+    }
+
+    [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+    [exclusiveto(Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs)]
+    [uuid(D445839F-FE7F-4BD5-8A26-0922C1B3E639)]
+    interface ICoreTextSelectionUpdatingEventArgs : IInspectable
+    {
+        [propget] HRESULT Selection([out] [retval] Windows.UI.Text.Core.CoreTextRange* value);
+        [propget] HRESULT Result([out] [retval] Windows.UI.Text.Core.CoreTextSelectionUpdatingResult* value);
+        [propput] HRESULT Result([in] Windows.UI.Text.Core.CoreTextSelectionUpdatingResult value);
+        [propget] HRESULT IsCanceled([out] [retval] boolean* value);
+        HRESULT GetDeferral([out] [retval] Windows.Foundation.Deferral** value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextTextRequest),
+        uuid(50D950A9-F51E-4CC1-8CA1-E6346D1A61BE)
+    ]
+    interface ICoreTextTextRequest : IInspectable
+    {
+        [propget] HRESULT Range([out] [retval] Windows.UI.Text.Core.CoreTextRange* value);
+        [propget] HRESULT Text([out] [retval] HSTRING* value);
+        [propput] HRESULT Text([in] HSTRING value);
+        [propget] HRESULT IsCanceled([out] [retval] boolean* value);
+        HRESULT GetDeferral([out] [retval] Windows.Foundation.Deferral** value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextTextRequestedEventArgs),
+        uuid(F096A2D0-41C6-4C02-8B1A-D953B00CABB3)
+    ]
+    interface ICoreTextTextRequestedEventArgs : IInspectable
+    {
+        [propget] HRESULT Request([out] [retval] Windows.UI.Text.Core.CoreTextTextRequest** value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs),
+        uuid(EEA7918D-CC2B-4F03-8FF6-02FD217DB450)
+    ]
+    interface ICoreTextTextUpdatingEventArgs : IInspectable
+    {
+        [propget] HRESULT Range([out] [retval] Windows.UI.Text.Core.CoreTextRange* value);
+        [propget] HRESULT Text([out] [retval] HSTRING* value);
+        [propget] HRESULT NewSelection([out] [retval] Windows.UI.Text.Core.CoreTextRange* value);
+        [propget] HRESULT InputLanguage([out] [retval] Windows.Globalization.Language** value);
+        [propget] HRESULT Result([out] [retval] Windows.UI.Text.Core.CoreTextTextUpdatingResult* value);
+        [propput] HRESULT Result([in] Windows.UI.Text.Core.CoreTextTextUpdatingResult value);
+        [propget] HRESULT IsCanceled([out] [retval] boolean* value);
+        HRESULT GetDeferral([out] [retval] Windows.Foundation.Deferral** value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs),
+        uuid(7310BD33-B4A8-43B1-B37B-0724D4ACA7AB)
+    ]
+    interface ICoreTextFormatUpdatingEventArgs : IInspectable
+    {
+        /*
+        [propget] HRESULT Range([out] [retval] Windows.UI.Text.Core.CoreTextRange* value);
+        [propget] HRESULT TextColor([out] [retval] Windows.Foundation.IReference<Windows.UI.ViewManagement.UIElementType>** value);
+        [propget] HRESULT BackgroundColor([out] [retval] Windows.Foundation.IReference<Windows.UI.ViewManagement.UIElementType>** value);
+        [propget] HRESULT UnderlineColor([out] [retval] Windows.Foundation.IReference<Windows.UI.ViewManagement.UIElementType>** value);
+        [propget] HRESULT UnderlineType([out] [retval] Windows.Foundation.IReference<Windows.UI.Text.UnderlineType>** value);
+        [propget] HRESULT Reason([out] [retval] Windows.UI.Text.Core.CoreTextFormatUpdatingReason* value);
+        [propget] HRESULT Result([out] [retval] Windows.UI.Text.Core.CoreTextFormatUpdatingResult* value);
+        [propput] HRESULT Result([in] Windows.UI.Text.Core.CoreTextFormatUpdatingResult value);
+        [propget] HRESULT IsCanceled([out] [retval] boolean* value);
+        */
+        HRESULT GetDeferral([out] [retval] Windows.Foundation.Deferral** value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextEditContext),
+        uuid(BF6608AF-4041-47C3-B263-A918EB5EAEF2)
+    ]
+    interface ICoreTextEditContext : IInspectable
+    {
+        [propget] HRESULT Name([out] [retval] HSTRING* value);
+        [propput] HRESULT Name([in] HSTRING value);
+        [propget] HRESULT InputScope([out] [retval] Windows.UI.Text.Core.CoreTextInputScope* value);
+        [propput] HRESULT InputScope([in] Windows.UI.Text.Core.CoreTextInputScope value);
+        [propget] HRESULT IsReadOnly([out] [retval] boolean* value);
+        [propput] HRESULT IsReadOnly([in] boolean value);
+        [propget] HRESULT InputPaneDisplayPolicy([out] [retval] Windows.UI.Text.Core.CoreTextInputPaneDisplayPolicy* value);
+        [propput] HRESULT InputPaneDisplayPolicy([in] Windows.UI.Text.Core.CoreTextInputPaneDisplayPolicy value);
+        [eventadd] HRESULT TextRequested([in] Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextTextRequestedEventArgs*>* handler, [out] [retval] EventRegistrationToken* cookie);
+        [eventremove] HRESULT TextRequested([in] EventRegistrationToken cookie);
+        [eventadd] HRESULT SelectionRequested([in] Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextSelectionRequestedEventArgs*>* handler, [out] [retval] EventRegistrationToken* cookie);
+        [eventremove] HRESULT SelectionRequested([in] EventRegistrationToken cookie);
+        [eventadd] HRESULT LayoutRequested([in] Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextLayoutRequestedEventArgs*>* handler, [out] [retval] EventRegistrationToken* cookie);
+        [eventremove] HRESULT LayoutRequested([in] EventRegistrationToken cookie);
+        [eventadd] HRESULT TextUpdating([in] Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs*>* handler, [out] [retval] EventRegistrationToken* cookie);
+        [eventremove] HRESULT TextUpdating([in] EventRegistrationToken cookie);
+        [eventadd] HRESULT SelectionUpdating([in] Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs*>* handler, [out] [retval] EventRegistrationToken* cookie);
+        [eventremove] HRESULT SelectionUpdating([in] EventRegistrationToken cookie);
+        [eventadd] HRESULT FormatUpdating([in] Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs*>* handler, [out] [retval] EventRegistrationToken* cookie);
+        [eventremove] HRESULT FormatUpdating([in] EventRegistrationToken cookie);
+        [eventadd] HRESULT CompositionStarted([in] Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs*>* handler, [out] [retval] EventRegistrationToken* cookie);
+        [eventremove] HRESULT CompositionStarted([in] EventRegistrationToken cookie);
+        [eventadd] HRESULT CompositionCompleted([in] Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs*>* handler, [out] [retval] EventRegistrationToken* cookie);
+        [eventremove] HRESULT CompositionCompleted([in] EventRegistrationToken cookie);
+        [eventadd] HRESULT FocusRemoved([in] Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext*, IInspectable*>* handler, [out] [retval] EventRegistrationToken* cookie);
+        [eventremove] HRESULT FocusRemoved([in] EventRegistrationToken cookie);
+        HRESULT NotifyFocusEnter();
+        HRESULT NotifyFocusLeave();
+        HRESULT NotifyTextChanged([in] Windows.UI.Text.Core.CoreTextRange modifiedRange, [in] INT32 newLength, [in] Windows.UI.Text.Core.CoreTextRange newSelection);
+        HRESULT NotifySelectionChanged([in] Windows.UI.Text.Core.CoreTextRange selection);
+        HRESULT NotifyLayoutChanged();
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextServicesManager),
+        uuid(C2507D83-6E0A-4A8A-BDF8-1948874854BA)
+    ]
+    interface ICoreTextServicesManager : IInspectable
+    {
+        [propget] HRESULT InputLanguage([out] [retval] Windows.Globalization.Language** value);
+        [eventadd] HRESULT InputLanguageChanged([in] Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextServicesManager*, IInspectable*>* handler, [out] [retval] EventRegistrationToken* cookie);
+        [eventremove] HRESULT InputLanguageChanged([in] EventRegistrationToken cookie);
+        HRESULT CreateEditContext( [out] [retval] Windows.UI.Text.Core.CoreTextEditContext** out );
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.Text.Core.CoreTextServicesManager),
+        uuid(1520A388-E2CF-4D65-AEB9-B32D86FE39B9)
+    ]
+    interface ICoreTextServicesManagerStatics : IInspectable
+    {
+        HRESULT GetForCurrentView([out] [retval] Windows.UI.Text.Core.CoreTextServicesManager** value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextCompositionCompletedEventArgs
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextCompositionCompletedEventArgs;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextCompositionStartedEventArgs
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextCompositionStartedEventArgs;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextEditContext
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextEditContext;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextFormatUpdatingEventArgs
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextFormatUpdatingEventArgs;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextLayoutBounds
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextLayoutBounds;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextLayoutRequest
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextLayoutRequest;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextLayoutRequestedEventArgs
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextLayoutRequestedEventArgs;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextSelectionRequest
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextSelectionRequest;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextSelectionRequestedEventArgs
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextSelectionRequestedEventArgs;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextSelectionUpdatingEventArgs
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextSelectionUpdatingEventArgs;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextTextRequestedEventArgs
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextTextRequestedEventArgs;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile),
+        static(Windows.UI.Text.Core.ICoreTextServicesManagerStatics, Windows.Foundation.UniversalApiContract, 1.0)
+    ]
+    runtimeclass CoreTextServicesManager
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextServicesManager;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextTextRequest
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextTextRequest;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass CoreTextTextUpdatingEventArgs
+    {
+        [default] interface Windows.UI.Text.Core.ICoreTextTextUpdatingEventArgs;
+    }
+}
\ No newline at end of file
diff --git a/include/windows.ui.text.idl b/include/windows.ui.text.idl
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/include/xasync.h b/include/xasync.h
new file mode 100644
index 00000000000..af27280dc1d
--- /dev/null
+++ b/include/xasync.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) the Wine project
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_XASYNC_H
+#define __WINE_XASYNC_H
+
+#include "xtaskqueue.h"
+
+struct XAsyncBlock;
+
+typedef void CALLBACK XAsyncCompletionRoutine(_Inout_ struct XAsyncBlock* asyncBlock);
+
+typedef HRESULT CALLBACK XAsyncWork(_Inout_ struct XAsyncBlock* asyncBlock);
+
+typedef struct XAsyncBlock
+{
+    XTaskQueueHandle queue;
+    void* context;
+    XAsyncCompletionRoutine* callback;
+    unsigned char internal[sizeof(void*) * 4];
+} XAsyncBlock;
+
+#endif
\ No newline at end of file
diff --git a/include/xasyncprovider.h b/include/xasyncprovider.h
new file mode 100644
index 00000000000..5db8c08fdd9
--- /dev/null
+++ b/include/xasyncprovider.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) the Wine project
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_XASYNCPROVIDER_H
+#define __WINE_XASYNCPROVIDER_H
+
+#include <stdint.h>
+#include "xasync.h"
+
+typedef enum XAsyncOp 
+{
+    Begin,
+    DoWork,
+    GetResult,
+    Cancel,
+    Cleanup
+} XAsyncOp;
+
+typedef struct XAsyncProviderData
+{
+    XAsyncBlock* async;
+    size_t bufferSize;
+    void* buffer;
+    void* context;
+} XAsyncProviderData;
+
+typedef HRESULT CALLBACK XAsyncProviderCallback(_In_ XAsyncOp op, _Inout_ const XAsyncProviderData* data);
+
+#define XASYNC_IDENTITY(method) #method
+
+#endif
\ No newline at end of file
diff --git a/include/xgameerr.h b/include/xgameerr.h
new file mode 100644
index 00000000000..0ccbef6815b
--- /dev/null
+++ b/include/xgameerr.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) the Wine project
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_XGAMEERR_H
+#define __WINE_XGAMEERR_H
+
+#include <specstrings.h>
+
+#define E_GAMERUNTIME_NOT_INITIALIZED                               _HRESULT_TYPEDEF_(0x89240100L)
+#define E_GAMERUNTIME_DLL_NOT_FOUND                                 _HRESULT_TYPEDEF_(0x89240101L)
+#define E_GAMERUNTIME_VERSION_MISMATCH                              _HRESULT_TYPEDEF_(0x89240102L)
+#define E_GAMERUNTIME_WINDOW_NOT_FOREGROUND                         _HRESULT_TYPEDEF_(0x89240103L)
+#define E_GAMERUNTIME_SUSPENDED                                     _HRESULT_TYPEDEF_(0x89240104L)
+#define E_GAMERUNTIME_UNINITIALIZE_ACTIVEOBJECTS                    _HRESULT_TYPEDEF_(0x89240105L)
+#define E_GAMERUNTIME_MULTIPLAYER_NOT_CONFIGURED                    _HRESULT_TYPEDEF_(0x89240106L)
+#define E_GAMERUNTIME_MISSING_DEPENDENCY                            _HRESULT_TYPEDEF_(0x89240107L)
+#define E_GAMERUNTIME_SUSPEND_ACTIVEOBJECTS                         _HRESULT_TYPEDEF_(0x89240108L)
+#define E_GAMERUNTIME_OPTIONS_MISMATCH                              _HRESULT_TYPEDEF_(0x89240109L)
+#define E_GAMERUNTIME_OPTIONS_NOT_SUPPORTED                         _HRESULT_TYPEDEF_(0x8924010AL)
+#define E_GAMERUNTIME_GAMECONFIG_BAD_FORMAT                         _HRESULT_TYPEDEF_(0x8924010BL)
+#define E_GAMERUNTIME_INVALID_HANDLE                                _HRESULT_TYPEDEF_(0x8924010CL)
+#define E_GAMEUSER_NO_AUTH_USER                                     _HRESULT_TYPEDEF_(0x87DD0013L)
+#define E_GAMEUSER_USER_NOT_IN_SANDBOX                              _HRESULT_TYPEDEF_(0x8015DC12L)
+#define E_GAMEUSER_MAX_USERS_ADDED                                  _HRESULT_TYPEDEF_(0x89245100L)
+#define E_GAMEUSER_SIGNED_OUT                                       _HRESULT_TYPEDEF_(0x89245101L)
+#define E_GAMEUSER_RESOLVE_USER_ISSUE_REQUIRED                      _HRESULT_TYPEDEF_(0x89245102L)
+#define E_GAMEUSER_DEFERRAL_NOT_AVAILABLE                           _HRESULT_TYPEDEF_(0x89245103L)
+#define E_GAMEUSER_USER_NOT_FOUND                                   _HRESULT_TYPEDEF_(0x89245104L)
+#define E_GAMEUSER_NO_TOKEN_REQUIRED                                _HRESULT_TYPEDEF_(0x89245105L)
+#define E_GAMEUSER_NO_DEFAULT_USER                                  _HRESULT_TYPEDEF_(0x89245106L)
+#define E_GAMEUSER_FAILED_TO_RESOLVE                                _HRESULT_TYPEDEF_(0x89245107L)
+#define E_GAMEUSER_NO_TITLE_ID                                      _HRESULT_TYPEDEF_(0x89245108L)
+#define E_GAMEUSER_UNKNOWN_GAME_IDENTITY                            _HRESULT_TYPEDEF_(0x89245109L)
+#define E_GAMEUSER_NO_PACKAGE_IDENTITY                              _HRESULT_TYPEDEF_(0x89245110L)
+#define E_GAMEUSER_FAILED_TO_GET_TOKEN                              _HRESULT_TYPEDEF_(0x89245111L)
+#define E_GAMEUSER_INVALID_APP_CONFIGURATION                        _HRESULT_TYPEDEF_(0x89245112L)
+#define E_GAMEUSER_MALFORMED_MSAAPPID                               _HRESULT_TYPEDEF_(0x89245113L)
+#define E_GAMEUSER_INCONSISTENT_MSAAPPID_AND_TITLEID                _HRESULT_TYPEDEF_(0x89245114L)
+#define E_GAMEUSER_NO_MSAAPPID                                      _HRESULT_TYPEDEF_(0x89245115L)
+#define E_GAMEPACKAGE_APP_NOT_PACKAGED                              _HRESULT_TYPEDEF_(0x89245200L)
+#define E_GAMEPACKAGE_NO_INSTALLED_LANGUAGES                        _HRESULT_TYPEDEF_(0x89245201L)
+#define E_GAMEPACKAGE_NO_STORE_ID                                   _HRESULT_TYPEDEF_(0x89245202L)
+#define E_GAMEPACKAGE_INVALID_SELECTOR                              _HRESULT_TYPEDEF_(0x89245203L)
+#define E_GAMEPACKAGE_DOWNLOAD_REQUIRED                             _HRESULT_TYPEDEF_(0x89245204L)
+#define E_GAMEPACKAGE_NO_TAG_CHANGE                                 _HRESULT_TYPEDEF_(0x89245205L)
+#define E_GAMEPACKAGE_DLC_NOT_SUPPORTED                             _HRESULT_TYPEDEF_(0x89245206L)
+#define E_GAMEPACKAGE_DUPLICATE_ID_VALUES                           _HRESULT_TYPEDEF_(0x89245207L)
+#define E_GAMEPACKAGE_NO_PACKAGE_IDENTIFIER                         _HRESULT_TYPEDEF_(0x89245208L)
+#define E_GAMEPACKAGE_CONFIG_NO_ROOT_NODE                           _HRESULT_TYPEDEF_(0x89245209L)
+#define E_GAMEPACKAGE_CONFIG_ZERO_VERSION                           _HRESULT_TYPEDEF_(0x8924520AL)
+#define E_GAMEPACKAGE_CONFIG_NO_MSAAPPID_OR_TITLEID                 _HRESULT_TYPEDEF_(0x8924520BL)
+#define E_GAMEPACKAGE_CONFIG_DEPRECATED_PC_ENTRIES                  _HRESULT_TYPEDEF_(0x8924520CL)
+#define E_GAMEPACKAGE_CONFIG_SUM_REQUIRES_MSAAPPID                  _HRESULT_TYPEDEF_(0x8924520DL)
+#define E_GAMEPACKAGE_CONFIG_NO_CODE_CLOUD_SAVES_REQUIRES_MSAAPPID  _HRESULT_TYPEDEF_(0x8924520EL)
+#define E_GAMEPACKAGE_CONFIG_MSAAPPID_OR_TITLEID_IS_DEFAULT         _HRESULT_TYPEDEF_(0x8924520FL)
+#define E_GAMEPACKAGE_CONFIG_INVALID_CONTROL_CHARACTERS             _HRESULT_TYPEDEF_(0x89245210L)
+#define E_GAMEPACKAGE_CONFIG_PROTOCOL_REQUIRES_EXECUTABLE           _HRESULT_TYPEDEF_(0x89245211L)
+#define E_GAMESTORE_LICENSE_ACTION_NOT_APPLICABLE_TO_PRODUCT        _HRESULT_TYPEDEF_(0x89245300L)
+#define E_GAMESTORE_NETWORK_ERROR                                   _HRESULT_TYPEDEF_(0x89245301L)
+#define E_GAMESTORE_SERVER_ERROR                                    _HRESULT_TYPEDEF_(0x89245302L)
+#define E_GAMESTORE_INSUFFICIENT_QUANTITY                           _HRESULT_TYPEDEF_(0x89245303L)
+#define E_GAMESTORE_ALREADY_PURCHASED                               _HRESULT_TYPEDEF_(0x89245304L)
+#define E_GAMESTORE_LICENSE_ACTION_THROTTLED                        _HRESULT_TYPEDEF_(0x89245305L)
+#define E_GAMESTREAMING_NOT_INITIALIZED                             _HRESULT_TYPEDEF_(0x89245400L)
+#define E_GAMESTREAMING_CLIENT_NOT_CONNECTED                        _HRESULT_TYPEDEF_(0x89245401L)
+#define E_GAMESTREAMING_NO_DATA                                     _HRESULT_TYPEDEF_(0x89245402L)
+#define E_GAMESTREAMING_NO_DATACENTER                               _HRESULT_TYPEDEF_(0x89245403L)
+#define E_GAMESTREAMING_NOT_STREAMING_CONTROLLER                    _HRESULT_TYPEDEF_(0x89245404L)
+#define E_GAMESTREAMING_NO_MATCH                                    _HRESULT_TYPEDEF_(0x89245405L)
+#define E_GAMESTREAMING_TOO_MANY_CALLS                              _HRESULT_TYPEDEF_(0x89245406L)
+#define E_GAMESTREAMING_CUSTOM_RESOLUTION_NOT_SUPPORTED             _HRESULT_TYPEDEF_(0x89245407L)
+#define E_GAMESTREAMING_CUSTOM_RESOLUTION_TOO_SMALL                 _HRESULT_TYPEDEF_(0x89245408L)
+#define E_GAMESTREAMING_CUSTOM_RESOLUTION_TOO_LARGE                 _HRESULT_TYPEDEF_(0x89245409L)
+#define E_GAMESTREAMING_CUSTOM_RESOLUTION_TOO_MANY_PIXELS           _HRESULT_TYPEDEF_(0x8924540AL)
+#define E_GAMESTREAMING_INVALID_CUSTOM_RESOLUTION                   _HRESULT_TYPEDEF_(0x8924540BL)
+
+#endif
\ No newline at end of file
diff --git a/include/xnetworking.h b/include/xnetworking.h
new file mode 100644
index 00000000000..35cb15a16cb
--- /dev/null
+++ b/include/xnetworking.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) the Wine project
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_XNETWORKING_H
+#define __WINE_XNETWORKING_H
+
+#include "xasync.h"
+
+typedef enum XNetworkingThumbprintType
+{  
+    ThumbprintType_Leaf = 0,  
+    ThumbprintType_Issuer = 1,  
+    ThumbprintType_Root = 2,  
+} XNetworkingThumbprintType;
+
+typedef enum XNetworkingConnectivityLevelHint
+{
+    ConnectivityLevelHintUnknown = 0,
+    ConnectivityLevelHintNone = 1,
+    ConnectivityLevelHintLocalAccess = 2,
+    ConnectivityLevelHintInternetAccess = 3,
+    ConnectivityLevelHintConstrainedInternetAccess = 4,
+} XNetworkingConnectivityLevelHint;
+
+typedef enum XNetworkingConnectivityCostHint
+{
+    ConnectivityCostHintUnknown = 0,
+    ConnectivityCostHintUnrestricted = 1,
+    ConnectivityCostHintFixed = 2,
+    ConnectivityCostHintVariable = 3,
+} XNetworkingConnectivityCostHint;
+
+typedef struct XNetworkingThumbprint 
+{  
+    XNetworkingThumbprintType thumbprintType;  
+    SIZE_T thumbprintBufferByteCount;  
+    UINT8* thumbprintBuffer;  
+} XNetworkingThumbprint;
+
+typedef struct XNetworkingSecurityInformation 
+{
+    UINT32 enabledHttpSecurityProtocolFlags;
+    SIZE_T thumbprintCount;
+    XNetworkingThumbprint* thumbprints;
+} XNetworkingSecurityInformation;
+
+typedef struct XNetworkingConnectivityHint 
+{
+    XNetworkingConnectivityLevelHint connectivityLevel;
+    XNetworkingConnectivityCostHint connectivityCost;
+    UINT32 ianaInterfaceType;
+    BOOLEAN networkInitialized;
+    BOOLEAN approachingDataLimit;
+    BOOLEAN overDataLimit;
+    BOOLEAN roaming;
+} XNetworkingConnectivityHint;
+
+typedef enum XNetworkingConfigurationSetting
+{  
+    MaxTitleTcpQueuedReceiveBufferSize = 0,  
+    MaxSystemTcpQueuedReceiveBufferSize = 1,  
+    MaxToolsTcpQueuedReceiveBufferSize = 2,  
+} XNetworkingConfigurationSetting;
+
+typedef enum XNetworkingStatisticsType  
+{  
+    TitleTcpQueuedReceivedBufferUsage = 0,  
+    SystemTcpQueuedReceivedBufferUsage = 1,  
+    ToolsTcpQueuedReceivedBufferUsage = 2,  
+} XNetworkingStatisticsType;
+
+typedef struct XNetworkingTcpQueuedReceivedBufferUsageStatistics 
+{  
+    UINT64 numBytesCurrentlyQueued;  
+    UINT64 peakNumBytesEverQueued;  
+    UINT64 totalNumBytesQueued;  
+    UINT64 numBytesDroppedForExceedingConfiguredMax;  
+    UINT64 numBytesDroppedDueToAnyFailure;  
+} XNetworkingTcpQueuedReceivedBufferUsageStatistics;
+
+typedef union XNetworkingStatisticsBuffer 
+{  
+    XNetworkingTcpQueuedReceivedBufferUsageStatistics tcpQueuedReceiveBufferUsage;  
+} XNetworkingStatisticsBuffer;
+
+typedef void CALLBACK XNetworkingPreferredLocalUdpMultiplayerPortChangedCallback(_In_opt_ PVOID context, _In_ UINT16 preferredLocalUdpMultiplayerPort);
+typedef void CALLBACK XNetworkingConnectivityHintChangedCallback(_In_opt_ PVOID context, _In_ const XNetworkingConnectivityHint* connectivityHint);
+#endif
\ No newline at end of file
diff --git a/include/xtaskqueue.h b/include/xtaskqueue.h
new file mode 100644
index 00000000000..49bba4c9ab4
--- /dev/null
+++ b/include/xtaskqueue.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) the Wine project
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_XTASKQUEUE_H
+#define __WINE_XTASKQUEUE_H
+
+#include <stdint.h>
+#include <winerror.h>
+#include <windef.h>
+
+typedef struct XTaskQueueObject* XTaskQueueHandle;
+
+typedef struct XTaskQueuePortObject* XTaskQueuePortHandle;
+
+typedef enum XTaskQueueDispatchMode
+{
+    Manual,
+    ThreadPool,
+    SerializedThreadPool,
+    Immediate
+} XTaskQueueDispatchMode;
+
+typedef enum XTaskQueuePort
+{
+    Work,
+    Completion
+} XTaskQueuePort;
+
+typedef enum XTaskQueuePortStatus
+{
+    PortStatus_Active,
+    PortStatus_Canceled,
+    PortStatus_Terminating,
+    PortStatus_Terminated
+} XTaskQueuePortStatus;
+
+typedef struct XTaskQueueRegistrationToken
+{
+    uint64_t token;
+} XTaskQueueRegistrationToken;
+
+typedef void CALLBACK XTaskQueueCallback(_In_opt_ void* context, _In_ BOOL canceled);
+typedef void CALLBACK XTaskQueueMonitorCallback(_In_opt_ void* context, _In_ XTaskQueueHandle queue, _In_ XTaskQueuePort port);
+typedef void CALLBACK XTaskQueueTerminatedCallback(_In_opt_ void* context);
+
+#endif
\ No newline at end of file
